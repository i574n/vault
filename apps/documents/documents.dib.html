<!DOCTYPE html>

<html lang="en">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>documents.dib</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<style type="text/css">
    pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: var(--jp-cell-editor-active-background) }
.highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) }
.highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */
.highlight .err { color: var(--jp-mirror-editor-error-color) } /* Error */
.highlight .k { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword */
.highlight .o { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator */
.highlight .p { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation */
.highlight .ch { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Multiline */
.highlight .cp { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Single */
.highlight .cs { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Special */
.highlight .kc { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Type */
.highlight .m { color: var(--jp-mirror-editor-number-color) } /* Literal.Number */
.highlight .s { color: var(--jp-mirror-editor-string-color) } /* Literal.String */
.highlight .ow { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator.Word */
.highlight .pm { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation.Marker */
.highlight .w { color: var(--jp-mirror-editor-variable-color) } /* Text.Whitespace */
.highlight .mb { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Bin */
.highlight .mf { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Float */
.highlight .mh { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Hex */
.highlight .mi { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer */
.highlight .mo { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Oct */
.highlight .sa { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Affix */
.highlight .sb { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Backtick */
.highlight .sc { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Char */
.highlight .dl { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Delimiter */
.highlight .sd { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Doc */
.highlight .s2 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Double */
.highlight .se { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Escape */
.highlight .sh { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Heredoc */
.highlight .si { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Interpol */
.highlight .sx { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Other */
.highlight .sr { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Regex */
.highlight .s1 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Single */
.highlight .ss { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Symbol */
.highlight .il { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer.Long */
  </style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
 * Mozilla scrollbar styling
 */

/* use standard opaque scrollbars for most nodes */
[data-jp-theme-scrollbars='true'] {
  scrollbar-color: rgb(var(--jp-scrollbar-thumb-color))
    var(--jp-scrollbar-background-color);
}

/* for code nodes, use a transparent style of scrollbar. These selectors
 * will match lower in the tree, and so will override the above */
[data-jp-theme-scrollbars='true'] .CodeMirror-hscrollbar,
[data-jp-theme-scrollbars='true'] .CodeMirror-vscrollbar {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
}

/* tiny scrollbar */

.jp-scrollbar-tiny {
  scrollbar-color: rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent;
  scrollbar-width: thin;
}

/* tiny scrollbar */

.jp-scrollbar-tiny::-webkit-scrollbar,
.jp-scrollbar-tiny::-webkit-scrollbar-corner {
  background-color: transparent;
  height: 4px;
  width: 4px;
}

.jp-scrollbar-tiny::-webkit-scrollbar-thumb {
  background: rgba(var(--jp-scrollbar-thumb-color), 0.5);
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:horizontal {
  border-left: 0 solid transparent;
  border-right: 0 solid transparent;
}

.jp-scrollbar-tiny::-webkit-scrollbar-track:vertical {
  border-top: 0 solid transparent;
  border-bottom: 0 solid transparent;
}

/*
 * Lumino
 */

.lm-ScrollBar[data-orientation='horizontal'] {
  min-height: 16px;
  max-height: 16px;
  min-width: 45px;
  border-top: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] {
  min-width: 16px;
  max-width: 16px;
  min-height: 45px;
  border-left: 1px solid #a0a0a0;
}

.lm-ScrollBar-button {
  background-color: #f0f0f0;
  background-position: center center;
  min-height: 15px;
  max-height: 15px;
  min-width: 15px;
  max-width: 15px;
}

.lm-ScrollBar-button:hover {
  background-color: #dadada;
}

.lm-ScrollBar-button.lm-mod-active {
  background-color: #cdcdcd;
}

.lm-ScrollBar-track {
  background: #f0f0f0;
}

.lm-ScrollBar-thumb {
  background: #cdcdcd;
}

.lm-ScrollBar-thumb:hover {
  background: #bababa;
}

.lm-ScrollBar-thumb.lm-mod-active {
  background: #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal'] .lm-ScrollBar-thumb {
  height: 100%;
  min-width: 15px;
  border-left: 1px solid #a0a0a0;
  border-right: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='vertical'] .lm-ScrollBar-thumb {
  width: 100%;
  min-height: 15px;
  border-top: 1px solid #a0a0a0;
  border-bottom: 1px solid #a0a0a0;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-left);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='horizontal']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-right);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='decrement'] {
  background-image: var(--jp-icon-caret-up);
  background-size: 17px;
}

.lm-ScrollBar[data-orientation='vertical']
  .lm-ScrollBar-button[data-action='increment'] {
  background-image: var(--jp-icon-caret-down);
  background-size: 17px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Widget {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.lm-Widget.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.lm-AccordionPanel[data-orientation='horizontal'] > .lm-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  display: flex;
  flex-direction: column;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-CommandPalette-search {
  flex: 0 0 auto;
}

.lm-CommandPalette-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  min-height: 0;
  overflow: auto;
  list-style-type: none;
}

.lm-CommandPalette-header {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-CommandPalette-item {
  display: flex;
  flex-direction: row;
}

.lm-CommandPalette-itemIcon {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemContent {
  flex: 1 1 auto;
  overflow: hidden;
}

.lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemLabel {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.lm-close-icon {
  border: 1px solid transparent;
  background-color: transparent;
  position: absolute;
  z-index: 1;
  right: 3%;
  top: 0;
  bottom: 0;
  margin: auto;
  padding: 7px 0;
  display: none;
  vertical-align: middle;
  outline: 0;
  cursor: pointer;
}
.lm-close-icon:after {
  content: 'X';
  display: block;
  width: 15px;
  height: 15px;
  text-align: center;
  color: #000;
  font-weight: normal;
  font-size: 12px;
  cursor: pointer;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-DockPanel {
  z-index: 0;
}

.lm-DockPanel-widget {
  z-index: 0;
}

.lm-DockPanel-tabBar {
  z-index: 1;
}

.lm-DockPanel-handle {
  z-index: 2;
}

.lm-DockPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-DockPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-DockPanel-handle[data-orientation='horizontal'] {
  cursor: ew-resize;
}

.lm-DockPanel-handle[data-orientation='vertical'] {
  cursor: ns-resize;
}

.lm-DockPanel-handle[data-orientation='horizontal']:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-DockPanel-handle[data-orientation='vertical']:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

.lm-DockPanel-overlay {
  z-index: 3;
  box-sizing: border-box;
  pointer-events: none;
}

.lm-DockPanel-overlay.lm-mod-hidden {
  display: none !important;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-Menu {
  z-index: 10000;
  position: absolute;
  white-space: nowrap;
  overflow-x: hidden;
  overflow-y: auto;
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-Menu-content {
  margin: 0;
  padding: 0;
  display: table;
  list-style-type: none;
}

.lm-Menu-item {
  display: table-row;
}

.lm-Menu-item.lm-mod-hidden,
.lm-Menu-item.lm-mod-collapsed {
  display: none !important;
}

.lm-Menu-itemIcon,
.lm-Menu-itemSubmenuIcon {
  display: table-cell;
  text-align: center;
}

.lm-Menu-itemLabel {
  display: table-cell;
  text-align: left;
}

.lm-Menu-itemShortcut {
  display: table-cell;
  text-align: right;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-MenuBar {
  outline: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-MenuBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: row;
  list-style-type: none;
}

.lm-MenuBar-item {
  box-sizing: border-box;
}

.lm-MenuBar-itemIcon,
.lm-MenuBar-itemLabel {
  display: inline-block;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-ScrollBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-ScrollBar[data-orientation='horizontal'] {
  flex-direction: row;
}

.lm-ScrollBar[data-orientation='vertical'] {
  flex-direction: column;
}

.lm-ScrollBar-button {
  box-sizing: border-box;
  flex: 0 0 auto;
}

.lm-ScrollBar-track {
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  flex: 1 1 auto;
}

.lm-ScrollBar-thumb {
  box-sizing: border-box;
  position: absolute;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-SplitPanel-child {
  z-index: 0;
}

.lm-SplitPanel-handle {
  z-index: 1;
}

.lm-SplitPanel-handle.lm-mod-hidden {
  display: none !important;
}

.lm-SplitPanel-handle:after {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  content: '';
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle {
  cursor: ew-resize;
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle {
  cursor: ns-resize;
}

.lm-SplitPanel[data-orientation='horizontal'] > .lm-SplitPanel-handle:after {
  left: 50%;
  min-width: 8px;
  transform: translateX(-50%);
}

.lm-SplitPanel[data-orientation='vertical'] > .lm-SplitPanel-handle:after {
  top: 50%;
  min-height: 8px;
  transform: translateY(-50%);
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabBar {
  display: flex;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.lm-TabBar[data-orientation='horizontal'] {
  flex-direction: row;
  align-items: flex-end;
}

.lm-TabBar[data-orientation='vertical'] {
  flex-direction: column;
  align-items: flex-end;
}

.lm-TabBar-content {
  margin: 0;
  padding: 0;
  display: flex;
  flex: 1 1 auto;
  list-style-type: none;
}

.lm-TabBar[data-orientation='horizontal'] > .lm-TabBar-content {
  flex-direction: row;
}

.lm-TabBar[data-orientation='vertical'] > .lm-TabBar-content {
  flex-direction: column;
}

.lm-TabBar-tab {
  display: flex;
  flex-direction: row;
  box-sizing: border-box;
  overflow: hidden;
  touch-action: none; /* Disable native Drag/Drop */
}

.lm-TabBar-tabIcon,
.lm-TabBar-tabCloseIcon {
  flex: 0 0 auto;
}

.lm-TabBar-tabLabel {
  flex: 1 1 auto;
  overflow: hidden;
  white-space: nowrap;
}

.lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
}

.lm-TabBar-tab.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar-addButton.lm-mod-hidden {
  display: none !important;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab {
  position: relative;
}

.lm-TabBar.lm-mod-dragging[data-orientation='horizontal'] .lm-TabBar-tab {
  left: 0;
  transition: left 150ms ease;
}

.lm-TabBar.lm-mod-dragging[data-orientation='vertical'] .lm-TabBar-tab {
  top: 0;
  transition: top 150ms ease;
}

.lm-TabBar.lm-mod-dragging .lm-TabBar-tab.lm-mod-dragging {
  transition: none;
}

.lm-TabBar-tabLabel .lm-TabBar-tabInput {
  user-select: all;
  width: 100%;
  box-sizing: border-box;
  background: inherit;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-TabPanel-tabBar {
  z-index: 1;
}

.lm-TabPanel-stackedPanel {
  z-index: 0;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapse {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

.jp-Collapse-header {
  padding: 1px 12px;
  background-color: var(--jp-layout-color1);
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  align-items: center;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  text-transform: uppercase;
  user-select: none;
}

.jp-Collapser-icon {
  height: 16px;
}

.jp-Collapse-header-collapsed .jp-Collapser-icon {
  transform: rotate(-90deg);
  margin: auto 0;
}

.jp-Collapser-title {
  line-height: 25px;
}

.jp-Collapse-contents {
  padding: 0 12px;
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* This file was auto-generated by ensureUiComponents() in @jupyterlab/buildutils */

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

/* Icons urls */

:root {
  --jp-icon-add-above: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5MikiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik00Ljc1IDQuOTMwNjZINi42MjVWNi44MDU2NkM2LjYyNSA3LjAxMTkxIDYuNzkzNzUgNy4xODA2NiA3IDcuMTgwNjZDNy4yMDYyNSA3LjE4MDY2IDcuMzc1IDcuMDExOTEgNy4zNzUgNi44MDU2NlY0LjkzMDY2SDkuMjVDOS40NTYyNSA0LjkzMDY2IDkuNjI1IDQuNzYxOTEgOS42MjUgNC41NTU2NkM5LjYyNSA0LjM0OTQxIDkuNDU2MjUgNC4xODA2NiA5LjI1IDQuMTgwNjZINy4zNzVWMi4zMDU2NkM3LjM3NSAyLjA5OTQxIDcuMjA2MjUgMS45MzA2NiA3IDEuOTMwNjZDNi43OTM3NSAxLjkzMDY2IDYuNjI1IDIuMDk5NDEgNi42MjUgMi4zMDU2NlY0LjE4MDY2SDQuNzVDNC41NDM3NSA0LjE4MDY2IDQuMzc1IDQuMzQ5NDEgNC4zNzUgNC41NTU2NkM0LjM3NSA0Ljc2MTkxIDQuNTQzNzUgNC45MzA2NiA0Ljc1IDQuOTMwNjZaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC43Ii8+CjwvZz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjUgOS41VjExLjVMMi41IDExLjVWOS41TDExLjUgOS41Wk0xMiA4QzEyLjU1MjMgOCAxMyA4LjQ0NzcyIDEzIDlWMTJDMTMgMTIuNTUyMyAxMi41NTIzIDEzIDEyIDEzTDIgMTNDMS40NDc3MiAxMyAxIDEyLjU1MjMgMSAxMlY5QzEgOC40NDc3MiAxLjQ0NzcxIDggMiA4TDEyIDhaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5MiI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDAgMCAxIDEwIDEuNTU1NjYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==);
  --jp-icon-add-below: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzN18xOTQ5OCkiPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGQ9Ik05LjI1IDEwLjA2OTNMNy4zNzUgMTAuMDY5M0w3LjM3NSA4LjE5NDM0QzcuMzc1IDcuOTg4MDkgNy4yMDYyNSA3LjgxOTM0IDcgNy44MTkzNEM2Ljc5Mzc1IDcuODE5MzQgNi42MjUgNy45ODgwOSA2LjYyNSA4LjE5NDM0TDYuNjI1IDEwLjA2OTNMNC43NSAxMC4wNjkzQzQuNTQzNzUgMTAuMDY5MyA0LjM3NSAxMC4yMzgxIDQuMzc1IDEwLjQ0NDNDNC4zNzUgMTAuNjUwNiA0LjU0Mzc1IDEwLjgxOTMgNC43NSAxMC44MTkzTDYuNjI1IDEwLjgxOTNMNi42MjUgMTIuNjk0M0M2LjYyNSAxMi45MDA2IDYuNzkzNzUgMTMuMDY5MyA3IDEzLjA2OTNDNy4yMDYyNSAxMy4wNjkzIDcuMzc1IDEyLjkwMDYgNy4zNzUgMTIuNjk0M0w3LjM3NSAxMC44MTkzTDkuMjUgMTAuODE5M0M5LjQ1NjI1IDEwLjgxOTMgOS42MjUgMTAuNjUwNiA5LjYyNSAxMC40NDQzQzkuNjI1IDEwLjIzODEgOS40NTYyNSAxMC4wNjkzIDkuMjUgMTAuMDY5M1oiIGZpbGw9IiM2MTYxNjEiIHN0cm9rZT0iIzYxNjE2MSIgc3Ryb2tlLXdpZHRoPSIwLjciLz4KPC9nPgo8cGF0aCBjbGFzcz0ianAtaWNvbjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMi41IDUuNUwyLjUgMy41TDExLjUgMy41TDExLjUgNS41TDIuNSA1LjVaTTIgN0MxLjQ0NzcyIDcgMSA2LjU1MjI4IDEgNkwxIDNDMSAyLjQ0NzcyIDEuNDQ3NzIgMiAyIDJMMTIgMkMxMi41NTIzIDIgMTMgMi40NDc3MiAxMyAzTDEzIDZDMTMgNi41NTIyOSAxMi41NTIzIDcgMTIgN0wyIDdaIiBmaWxsPSIjNjE2MTYxIi8+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzN18xOTQ5OCI+CjxyZWN0IGNsYXNzPSJqcC1pY29uMyIgd2lkdGg9IjYiIGhlaWdodD0iNiIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMS43NDg0NmUtMDcgMS43NDg0NmUtMDcgLTEgNCAxMy40NDQzKSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=);
  --jp-icon-add: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bell: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiPgogICA8cGF0aCBjbGFzcz0ianAtaWNvbjIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzMzMzMzIgogICAgICBkPSJtOCAwLjI5Yy0xLjQgMC0yLjcgMC43My0zLjYgMS44LTEuMiAxLjUtMS40IDMuNC0xLjUgNS4yLTAuMTggMi4yLTAuNDQgNC0yLjMgNS4zbDAuMjggMS4zaDVjMC4wMjYgMC42NiAwLjMyIDEuMSAwLjcxIDEuNSAwLjg0IDAuNjEgMiAwLjYxIDIuOCAwIDAuNTItMC40IDAuNi0xIDAuNzEtMS41aDVsMC4yOC0xLjNjLTEuOS0wLjk3LTIuMi0zLjMtMi4zLTUuMy0wLjEzLTEuOC0wLjI2LTMuNy0xLjUtNS4yLTAuODUtMS0yLjItMS44LTMuNi0xLjh6bTAgMS40YzAuODggMCAxLjkgMC41NSAyLjUgMS4zIDAuODggMS4xIDEuMSAyLjcgMS4yIDQuNCAwLjEzIDEuNyAwLjIzIDMuNiAxLjMgNS4yaC0xMGMxLjEtMS42IDEuMi0zLjQgMS4zLTUuMiAwLjEzLTEuNyAwLjMtMy4zIDEuMi00LjQgMC41OS0wLjcyIDEuNi0xLjMgMi41LTEuM3ptLTAuNzQgMTJoMS41Yy0wLjAwMTUgMC4yOCAwLjAxNSAwLjc5LTAuNzQgMC43OS0wLjczIDAuMDAxNi0wLjcyLTAuNTMtMC43NC0wLjc5eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-bug-dot: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiPgogICAgICAgIDxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuMTkgOEgyMFYxMEgxNy45MUMxNy45NiAxMC4zMyAxOCAxMC42NiAxOCAxMVYxMkgyMFYxNEgxOC41SDE4VjE0LjAyNzVDMTUuNzUgMTQuMjc2MiAxNCAxNi4xODM3IDE0IDE4LjVDMTQgMTkuMjA4IDE0LjE2MzUgMTkuODc3OSAxNC40NTQ5IDIwLjQ3MzlDMTMuNzA2MyAyMC44MTE3IDEyLjg3NTcgMjEgMTIgMjFDOS43OCAyMSA3Ljg1IDE5Ljc5IDYuODEgMThINFYxNkg2LjA5QzYuMDQgMTUuNjcgNiAxNS4zNCA2IDE1VjE0SDRWMTJINlYxMUM2IDEwLjY2IDYuMDQgMTAuMzMgNi4wOSAxMEg0VjhINi44MUM3LjI2IDcuMjIgNy44OCA2LjU1IDguNjIgNi4wNEw3IDQuNDFMOC40MSAzTDEwLjU5IDUuMTdDMTEuMDQgNS4wNiAxMS41MSA1IDEyIDVDMTIuNDkgNSAxMi45NiA1LjA2IDEzLjQyIDUuMTdMMTUuNTkgM0wxNyA0LjQxTDE1LjM3IDYuMDRDMTYuMTIgNi41NSAxNi43NCA3LjIyIDE3LjE5IDhaTTEwIDE2SDE0VjE0SDEwVjE2Wk0xMCAxMkgxNFYxMEgxMFYxMloiIGZpbGw9IiM2MTYxNjEiLz4KICAgICAgICA8cGF0aCBkPSJNMjIgMTguNUMyMiAyMC40MzMgMjAuNDMzIDIyIDE4LjUgMjJDMTYuNTY3IDIyIDE1IDIwLjQzMyAxNSAxOC41QzE1IDE2LjU2NyAxNi41NjcgMTUgMTguNSAxNUMyMC40MzMgMTUgMjIgMTYuNTY3IDIyIDE4LjVaIiBmaWxsPSIjNjE2MTYxIi8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-bug: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yMCA4aC0yLjgxYy0uNDUtLjc4LTEuMDctMS40NS0xLjgyLTEuOTZMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdDMTIuOTYgNS4wNiAxMi40OSA1IDEyIDVjLS40OSAwLS45Ni4wNi0xLjQxLjE3TDguNDEgMyA3IDQuNDFsMS42MiAxLjYzQzcuODggNi41NSA3LjI2IDcuMjIgNi44MSA4SDR2MmgyLjA5Yy0uMDUuMzMtLjA5LjY2LS4wOSAxdjFINHYyaDJ2MWMwIC4zNC4wNC42Ny4wOSAxSDR2MmgyLjgxYzEuMDQgMS43OSAyLjk3IDMgNS4xOSAzczQuMTUtMS4yMSA1LjE5LTNIMjB2LTJoLTIuMDljLjA1LS4zMy4wOS0uNjYuMDktMXYtMWgydi0yaC0ydi0xYzAtLjM0LS4wNC0uNjctLjA5LTFIMjBWOHptLTYgOGgtNHYtMmg0djJ6bTAtNGgtNHYtMmg0djJ6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-build: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE0LjkgMTcuNDVDMTYuMjUgMTcuNDUgMTcuMzUgMTYuMzUgMTcuMzUgMTVDMTcuMzUgMTMuNjUgMTYuMjUgMTIuNTUgMTQuOSAxMi41NUMxMy41NCAxMi41NSAxMi40NSAxMy42NSAxMi40NSAxNUMxMi40NSAxNi4zNSAxMy41NCAxNy40NSAxNC45IDE3LjQ1Wk0yMC4xIDE1LjY4TDIxLjU4IDE2Ljg0QzIxLjcxIDE2Ljk1IDIxLjc1IDE3LjEzIDIxLjY2IDE3LjI5TDIwLjI2IDE5LjcxQzIwLjE3IDE5Ljg2IDIwIDE5LjkyIDE5LjgzIDE5Ljg2TDE4LjA5IDE5LjE2QzE3LjczIDE5LjQ0IDE3LjMzIDE5LjY3IDE2LjkxIDE5Ljg1TDE2LjY0IDIxLjdDMTYuNjIgMjEuODcgMTYuNDcgMjIgMTYuMyAyMkgxMy41QzEzLjMyIDIyIDEzLjE4IDIxLjg3IDEzLjE1IDIxLjdMMTIuODkgMTkuODVDMTIuNDYgMTkuNjcgMTIuMDcgMTkuNDQgMTEuNzEgMTkuMTZMOS45NjAwMiAxOS44NkM5LjgxMDAyIDE5LjkyIDkuNjIwMDIgMTkuODYgOS41NDAwMiAxOS43MUw4LjE0MDAyIDE3LjI5QzguMDUwMDIgMTcuMTMgOC4wOTAwMiAxNi45NSA4LjIyMDAyIDE2Ljg0TDkuNzAwMDIgMTUuNjhMOS42NTAwMSAxNUw5LjcwMDAyIDE0LjMxTDguMjIwMDIgMTMuMTZDOC4wOTAwMiAxMy4wNSA4LjA1MDAyIDEyLjg2IDguMTQwMDIgMTIuNzFMOS41NDAwMiAxMC4yOUM5LjYyMDAyIDEwLjEzIDkuODEwMDIgMTAuMDcgOS45NjAwMiAxMC4xM0wxMS43MSAxMC44NEMxMi4wNyAxMC41NiAxMi40NiAxMC4zMiAxMi44OSAxMC4xNUwxMy4xNSA4LjI4OTk4QzEzLjE4IDguMTI5OTggMTMuMzIgNy45OTk5OCAxMy41IDcuOTk5OThIMTYuM0MxNi40NyA3Ljk5OTk4IDE2LjYyIDguMTI5OTggMTYuNjQgOC4yODk5OEwxNi45MSAxMC4xNUMxNy4zMyAxMC4zMiAxNy43MyAxMC41NiAxOC4wOSAxMC44NEwxOS44MyAxMC4xM0MyMCAxMC4wNyAyMC4xNyAxMC4xMyAyMC4yNiAxMC4yOUwyMS42NiAxMi43MUMyMS43NSAxMi44NiAyMS43MSAxMy4wNSAyMS41OCAxMy4xNkwyMC4xIDE0LjMxTDIwLjE1IDE1TDIwLjEgMTUuNjhaIi8+CiAgICA8cGF0aCBkPSJNNy4zMjk2NiA3LjQ0NDU0QzguMDgzMSA3LjAwOTU0IDguMzM5MzIgNi4wNTMzMiA3LjkwNDMyIDUuMjk5ODhDNy40NjkzMiA0LjU0NjQzIDYuNTA4MSA0LjI4MTU2IDUuNzU0NjYgNC43MTY1NkM1LjM5MTc2IDQuOTI2MDggNS4xMjY5NSA1LjI3MTE4IDUuMDE4NDkgNS42NzU5NEM0LjkxMDA0IDYuMDgwNzEgNC45NjY4MiA2LjUxMTk4IDUuMTc2MzQgNi44NzQ4OEM1LjYxMTM0IDcuNjI4MzIgNi41NzYyMiA3Ljg3OTU0IDcuMzI5NjYgNy40NDQ1NFpNOS42NTcxOCA0Ljc5NTkzTDEwLjg2NzIgNC45NTE3OUMxMC45NjI4IDQuOTc3NDEgMTEuMDQwMiA1LjA3MTMzIDExLjAzODIgNS4xODc5M0wxMS4wMzg4IDYuOTg4OTNDMTEuMDQ1NSA3LjEwMDU0IDEwLjk2MTYgNy4xOTUxOCAxMC44NTUgNy4yMTA1NEw5LjY2MDAxIDcuMzgwODNMOS4yMzkxNSA4LjEzMTg4TDkuNjY5NjEgOS4yNTc0NUM5LjcwNzI5IDkuMzYyNzEgOS42NjkzNCA5LjQ3Njk5IDkuNTc0MDggOS41MzE5OUw4LjAxNTIzIDEwLjQzMkM3LjkxMTMxIDEwLjQ5MiA3Ljc5MzM3IDEwLjQ2NzcgNy43MjEwNSAxMC4zODI0TDYuOTg3NDggOS40MzE4OEw2LjEwOTMxIDkuNDMwODNMNS4zNDcwNCAxMC4zOTA1QzUuMjg5MDkgMTAuNDcwMiA1LjE3MzgzIDEwLjQ5MDUgNS4wNzE4NyAxMC40MzM5TDMuNTEyNDUgOS41MzI5M0MzLjQxMDQ5IDkuNDc2MzMgMy4zNzY0NyA5LjM1NzQxIDMuNDEwNzUgOS4yNTY3OUwzLjg2MzQ3IDguMTQwOTNMMy42MTc0OSA3Ljc3NDg4TDMuNDIzNDcgNy4zNzg4M0wyLjIzMDc1IDcuMjEyOTdDMi4xMjY0NyA3LjE5MjM1IDIuMDQwNDkgNy4xMDM0MiAyLjA0MjQ1IDYuOTg2ODJMMi4wNDE4NyA1LjE4NTgyQzIuMDQzODMgNS4wNjkyMiAyLjExOTA5IDQuOTc5NTggMi4yMTcwNCA0Ljk2OTIyTDMuNDIwNjUgNC43OTM5M0wzLjg2NzQ5IDQuMDI3ODhMMy40MTEwNSAyLjkxNzMxQzMuMzczMzcgMi44MTIwNCAzLjQxMTMxIDIuNjk3NzYgMy41MTUyMyAyLjYzNzc2TDUuMDc0MDggMS43Mzc3NkM1LjE2OTM0IDEuNjgyNzYgNS4yODcyOSAxLjcwNzA0IDUuMzU5NjEgMS43OTIzMUw2LjExOTE1IDIuNzI3ODhMNi45ODAwMSAyLjczODkzTDcuNzI0OTYgMS43ODkyMkM3Ljc5MTU2IDEuNzA0NTggNy45MTU0OCAxLjY3OTIyIDguMDA4NzkgMS43NDA4Mkw5LjU2ODIxIDIuNjQxODJDOS42NzAxNyAyLjY5ODQyIDkuNzEyODUgMi44MTIzNCA5LjY4NzIzIDIuOTA3OTdMOS4yMTcxOCA0LjAzMzgzTDkuNDYzMTYgNC4zOTk4OEw5LjY1NzE4IDQuNzk1OTNaIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iOS45LDEzLjYgMy42LDcuNCA0LjQsNi42IDkuOSwxMi4yIDE1LjQsNi43IDE2LjEsNy40ICIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNS45TDksOS43bDMuOC0zLjhsMS4yLDEuMmwtNC45LDVsLTQuOS01TDUuMiw1Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-caret-down: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNy41TDksMTEuMmwzLjgtMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-left: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik0xMC44LDEyLjhMNy4xLDlsMy44LTMuOGwwLDcuNkgxMC44eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-right: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik03LjIsNS4yTDEwLjksOWwtMy44LDMuOFY1LjJINy4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-caret-up-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMTUuNCwxMy4zIDkuOSw3LjcgNC40LDEzLjIgMy42LDEyLjUgOS45LDYuMyAxNi4xLDEyLjYgIi8+Cgk8L2c+Cjwvc3ZnPgo=);
  --jp-icon-caret-up: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik01LjIsMTAuNUw5LDYuOGwzLjgsMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-case-sensitive: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWFjY2VudDIiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTcuNiw4aDAuOWwzLjUsOGgtMS4xTDEwLDE0SDZsLTAuOSwySDRMNy42LDh6IE04LDkuMUw2LjQsMTNoMy4yTDgsOS4xeiIvPgogICAgPHBhdGggZD0iTTE2LjYsOS44Yy0wLjIsMC4xLTAuNCwwLjEtMC43LDAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0wLjEtMC4xLTAuMi0wLjQtMC4yLTAuNyBjLTAuMywwLjMtMC42LDAuNS0wLjksMC43Yy0wLjMsMC4xLTAuNywwLjItMS4xLDAuMmMtMC4zLDAtMC41LDAtMC43LTAuMWMtMC4yLTAuMS0wLjQtMC4yLTAuNi0wLjNjLTAuMi0wLjEtMC4zLTAuMy0wLjQtMC41IGMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjdjMC0wLjMsMC4xLTAuNiwwLjItMC44YzAuMS0wLjIsMC4zLTAuNCwwLjQtMC41QzEyLDcsMTIuMiw2LjksMTIuNSw2LjhjMC4yLTAuMSwwLjUtMC4xLDAuNy0wLjIgYzAuMy0wLjEsMC41LTAuMSwwLjctMC4xYzAuMiwwLDAuNC0wLjEsMC42LTAuMWMwLjIsMCwwLjMtMC4xLDAuNC0wLjJjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC0xLTEuMS0xLTEuMy0xIGMtMC40LDAtMS40LDAtMS40LDEuMmgtMC45YzAtMC40LDAuMS0wLjcsMC4yLTFjMC4xLTAuMiwwLjMtMC40LDAuNS0wLjZjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjNDMTMuMyw0LDEzLjYsNCwxMy45LDQgYzAuMywwLDAuNSwwLDAuOCwwLjFjMC4zLDAsMC41LDAuMSwwLjcsMC4yYzAuMiwwLjEsMC40LDAuMywwLjUsMC41QzE2LDUsMTYsNS4yLDE2LDUuNnYyLjljMCwwLjIsMCwwLjQsMCwwLjUgYzAsMC4xLDAuMSwwLjIsMC4zLDAuMmMwLjEsMCwwLjIsMCwwLjMsMFY5Ljh6IE0xNS4yLDYuOWMtMS4yLDAuNi0zLjEsMC4yLTMuMSwxLjRjMCwxLjQsMy4xLDEsMy4xLTAuNVY2Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-circle-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-circle: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-clear: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8bWFzayBpZD0iZG9udXRIb2xlIj4KICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIC8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSJibGFjayIvPgogIDwvbWFzaz4KCiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxyZWN0IGhlaWdodD0iMTgiIHdpZHRoPSIyIiB4PSIxMSIgeT0iMyIgdHJhbnNmb3JtPSJyb3RhdGUoMzE1LCAxMiwgMTIpIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgbWFzaz0idXJsKCNkb251dEhvbGUpIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-close: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1ub25lIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIGpwLWljb24zLWhvdmVyIiBmaWxsPSJub25lIj4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjExIi8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIGpwLWljb24tYWNjZW50Mi1ob3ZlciIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogIDwvZz4KCiAgPGcgY2xhc3M9ImpwLWljb24tbm9uZSBqcC1pY29uLWJ1c3kiIGZpbGw9Im5vbmUiPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICA8cGF0aCBkPSJNNi41OSwzLjQxTDIsOEw2LjU5LDEyLjZMOCwxMS4xOEw0LjgyLDhMOCw0LjgyTDYuNTksMy40MU0xMi40MSwzLjQxTDExLDQuODJMMTQuMTgsOEwxMSwxMS4xOEwxMi40MSwxMi42TDE3LDhMMTIuNDEsMy40MU0yMS41OSwxMS41OUwxMy41LDE5LjY4TDkuODMsMTZMOC40MiwxNy40MUwxMy41LDIyLjVMMjMsMTNMMjEuNTksMTEuNTlaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-code: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTExLjQgMTguNkw2LjggMTRMMTEuNCA5LjRMMTAgOEw0IDE0TDEwIDIwTDExLjQgMTguNlpNMTYuNiAxOC42TDIxLjIgMTRMMTYuNiA5LjRMMTggOEwyNCAxNEwxOCAyMEwxNi42IDE4LjZWMTguNloiLz4KCTwvZz4KPC9zdmc+Cg==);
  --jp-icon-collapse-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNNiAxM3YyaDh2LTJ6IiAvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-console: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwMCAyMDAiPgogIDxnIGNsYXNzPSJqcC1jb25zb2xlLWljb24tYmFja2dyb3VuZC1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMjg4RDEiPgogICAgPHBhdGggZD0iTTIwIDE5LjhoMTYwdjE1OS45SDIweiIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtY29uc29sZS1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIj4KICAgIDxwYXRoIGQ9Ik0xMDUgMTI3LjNoNDB2MTIuOGgtNDB6TTUxLjEgNzdMNzQgOTkuOWwtMjMuMyAyMy4zIDEwLjUgMTAuNSAyMy4zLTIzLjNMOTUgOTkuOSA4NC41IDg5LjQgNjEuNiA2Ni41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copy: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTExLjksMUgzLjJDMi40LDEsMS43LDEuNywxLjcsMi41djEwLjJoMS41VjIuNWg4LjdWMXogTTE0LjEsMy45aC04Yy0wLjgsMC0xLjUsMC43LTEuNSwxLjV2MTAuMmMwLDAuOCwwLjcsMS41LDEuNSwxLjVoOCBjMC44LDAsMS41LTAuNywxLjUtMS41VjUuNEMxNS41LDQuNiwxNC45LDMuOSwxNC4xLDMuOXogTTE0LjEsMTUuNWgtOFY1LjRoOFYxNS41eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-copyright: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCI+CiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0xMS44OCw5LjE0YzEuMjgsMC4wNiwxLjYxLDEuMTUsMS42MywxLjY2aDEuNzljLTAuMDgtMS45OC0xLjQ5LTMuMTktMy40NS0zLjE5QzkuNjQsNy42MSw4LDksOCwxMi4xNCBjMCwxLjk0LDAuOTMsNC4yNCwzLjg0LDQuMjRjMi4yMiwwLDMuNDEtMS42NSwzLjQ0LTIuOTVoLTEuNzljLTAuMDMsMC41OS0wLjQ1LDEuMzgtMS42MywxLjQ0QzEwLjU1LDE0LjgzLDEwLDEzLjgxLDEwLDEyLjE0IEMxMCw5LjI1LDExLjI4LDkuMTYsMTEuODgsOS4xNHogTTEyLDJDNi40OCwyLDIsNi40OCwyLDEyczQuNDgsMTAsMTAsMTBzMTAtNC40OCwxMC0xMFMxNy41MiwyLDEyLDJ6IE0xMiwyMGMtNC40MSwwLTgtMy41OS04LTggczMuNTktOCw4LThzOCwzLjU5LDgsOFMxNi40MSwyMCwxMiwyMHoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-cut: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkuNjQgNy42NGMuMjMtLjUuMzYtMS4wNS4zNi0xLjY0IDAtMi4yMS0xLjc5LTQtNC00UzIgMy43OSAyIDZzMS43OSA0IDQgNGMuNTkgMCAxLjE0LS4xMyAxLjY0LS4zNkwxMCAxMmwtMi4zNiAyLjM2QzcuMTQgMTQuMTMgNi41OSAxNCA2IDE0Yy0yLjIxIDAtNCAxLjc5LTQgNHMxLjc5IDQgNCA0IDQtMS43OSA0LTRjMC0uNTktLjEzLTEuMTQtLjM2LTEuNjRMMTIgMTRsNyA3aDN2LTFMOS42NCA3LjY0ek02IDhjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTAgMTJjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTYtNy41Yy0uMjggMC0uNS0uMjItLjUtLjVzLjIyLS41LjUtLjUuNS4yMi41LjUtLjIyLjUtLjUuNXpNMTkgM2wtNiA2IDIgMiA3LTdWM3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-delete: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjI2MjYyIiBkPSJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyek0xOSA0aC0zLjVsLTEtMWgtNWwtMSAxSDV2MmgxNFY0eiIgLz4KPC9zdmc+Cg==);
  --jp-icon-download: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-duplicate: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIuNzk5OTggMC44NzVIOC44OTU4MkM5LjIwMDYxIDAuODc1IDkuNDQ5OTggMS4xMzkxNCA5LjQ0OTk4IDEuNDYxOThDOS40NDk5OCAxLjc4NDgyIDkuMjAwNjEgMi4wNDg5NiA4Ljg5NTgyIDIuMDQ4OTZIMy4zNTQxNUMzLjA0OTM2IDIuMDQ4OTYgMi43OTk5OCAyLjMxMzEgMi43OTk5OCAyLjYzNTk0VjkuNjc5NjlDMi43OTk5OCAxMC4wMDI1IDIuNTUwNjEgMTAuMjY2NyAyLjI0NTgyIDEwLjI2NjdDMS45NDEwMyAxMC4yNjY3IDEuNjkxNjUgMTAuMDAyNSAxLjY5MTY1IDkuNjc5NjlWMi4wNDg5NkMxLjY5MTY1IDEuNDAzMjggMi4xOTA0IDAuODc1IDIuNzk5OTggMC44NzVaTTUuMzY2NjUgMTEuOVY0LjU1SDExLjA4MzNWMTEuOUg1LjM2NjY1Wk00LjE0MTY1IDQuMTQxNjdDNC4xNDE2NSAzLjY5MDYzIDQuNTA3MjggMy4zMjUgNC45NTgzMiAzLjMyNUgxMS40OTE3QzExLjk0MjcgMy4zMjUgMTIuMzA4MyAzLjY5MDYzIDEyLjMwODMgNC4xNDE2N1YxMi4zMDgzQzEyLjMwODMgMTIuNzU5NCAxMS45NDI3IDEzLjEyNSAxMS40OTE3IDEzLjEyNUg0Ljk1ODMyQzQuNTA3MjggMTMuMTI1IDQuMTQxNjUgMTIuNzU5NCA0LjE0MTY1IDEyLjMwODNWNC4xNDE2N1oiIGZpbGw9IiM2MTYxNjEiLz4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNOS40MzU3NCA4LjI2NTA3SDguMzY0MzFWOS4zMzY1QzguMzY0MzEgOS40NTQzNSA4LjI2Nzg4IDkuNTUwNzggOC4xNTAwMiA5LjU1MDc4QzguMDMyMTcgOS41NTA3OCA3LjkzNTc0IDkuNDU0MzUgNy45MzU3NCA5LjMzNjVWOC4yNjUwN0g2Ljg2NDMxQzYuNzQ2NDUgOC4yNjUwNyA2LjY1MDAyIDguMTY4NjQgNi42NTAwMiA4LjA1MDc4QzYuNjUwMDIgNy45MzI5MiA2Ljc0NjQ1IDcuODM2NSA2Ljg2NDMxIDcuODM2NUg3LjkzNTc0VjYuNzY1MDdDNy45MzU3NCA2LjY0NzIxIDguMDMyMTcgNi41NTA3OCA4LjE1MDAyIDYuNTUwNzhDOC4yNjc4OCA2LjU1MDc4IDguMzY0MzEgNi42NDcyMSA4LjM2NDMxIDYuNzY1MDdWNy44MzY1SDkuNDM1NzRDOS41NTM2IDcuODM2NSA5LjY1MDAyIDcuOTMyOTIgOS42NTAwMiA4LjA1MDc4QzkuNjUwMDIgOC4xNjg2NCA5LjU1MzYgOC4yNjUwNyA5LjQzNTc0IDguMjY1MDdaIiBmaWxsPSIjNjE2MTYxIiBzdHJva2U9IiM2MTYxNjEiIHN0cm9rZS13aWR0aD0iMC41Ii8+Cjwvc3ZnPgo=);
  --jp-icon-edit: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3oiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-ellipses: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjEyIiByPSIyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-error: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjE5IiByPSIyIi8+PHBhdGggZD0iTTEwIDNoNHYxMmgtNHoiLz48L2c+CjxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMjR2MjRIMHoiLz4KPC9zdmc+Cg==);
  --jp-icon-expand-all: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTggMmMxIDAgMTEgMCAxMiAwczIgMSAyIDJjMCAxIDAgMTEgMCAxMnMwIDItMiAyQzIwIDE0IDIwIDQgMjAgNFMxMCA0IDYgNGMwLTIgMS0yIDItMnoiIC8+CiAgICAgICAgPHBhdGgKICAgICAgICAgICAgZD0iTTE4IDhjMC0xLTEtMi0yLTJTNSA2IDQgNnMtMiAxLTIgMmMwIDEgMCAxMSAwIDEyczEgMiAyIDJjMSAwIDExIDAgMTIgMHMyLTEgMi0yYzAtMSAwLTExIDAtMTJ6bS0yIDB2MTJINFY4eiIgLz4KICAgICAgICA8cGF0aCBkPSJNMTEgMTBIOXYzSDZ2MmgzdjNoMnYtM2gzdi0yaC0zeiIgLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-extension: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwLjUgMTFIMTlWN2MwLTEuMS0uOS0yLTItMmgtNFYzLjVDMTMgMi4xMiAxMS44OCAxIDEwLjUgMVM4IDIuMTIgOCAzLjVWNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAydjMuOEgzLjVjMS40OSAwIDIuNyAxLjIxIDIuNyAyLjdzLTEuMjEgMi43LTIuNyAyLjdIMlYyMGMwIDEuMS45IDIgMiAyaDMuOHYtMS41YzAtMS40OSAxLjIxLTIuNyAyLjctMi43IDEuNDkgMCAyLjcgMS4yMSAyLjcgMi43VjIySDE3YzEuMSAwIDItLjkgMi0ydi00aDEuNWMxLjM4IDAgMi41LTEuMTIgMi41LTIuNVMyMS44OCAxMSAyMC41IDExeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-fast-forward: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-file-upload: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-file: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuMyA4LjJsLTUuNS01LjVjLS4zLS4zLS43LS41LTEuMi0uNUgzLjljLS44LjEtMS42LjktMS42IDEuOHYxNC4xYzAgLjkuNyAxLjYgMS42IDEuNmgxNC4yYy45IDAgMS42LS43IDEuNi0xLjZWOS40Yy4xLS41LS4xLS45LS40LTEuMnptLTUuOC0zLjNsMy40IDMuNmgtMy40VjQuOXptMy45IDEyLjdINC43Yy0uMSAwLS4yIDAtLjItLjJWNC43YzAtLjIuMS0uMy4yLS4zaDcuMnY0LjRzMCAuOC4zIDEuMWMuMy4zIDEuMS4zIDEuMS4zaDQuM3Y3LjJzLS4xLjItLjIuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-filter-dot: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWRvdCIgZmlsbD0iI0ZGRiI+CiAgICA8Y2lyY2xlIGN4PSIxOCIgY3k9IjE3IiByPSIzIj48L2NpcmNsZT4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-filter-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEwIDE4aDR2LTJoLTR2MnpNMyA2djJoMThWNkgzem0zIDdoMTJ2LTJINnYyeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-filter: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTE0LDEyVjE5Ljg4QzE0LjA0LDIwLjE4IDEzLjk0LDIwLjUgMTMuNzEsMjAuNzFDMTMuMzIsMjEuMSAxMi42OSwyMS4xIDEyLjMsMjAuNzFMMTAuMjksMTguN0MxMC4wNiwxOC40NyA5Ljk2LDE4LjE2IDEwLDE3Ljg3VjEySDkuOTdMNC4yMSw0LjYyQzMuODcsNC4xOSAzLjk1LDMuNTYgNC4zOCwzLjIyQzQuNTcsMy4wOCA0Ljc4LDMgNSwzVjNIMTlWM0MxOS4yMiwzIDE5LjQzLDMuMDggMTkuNjIsMy4yMkMyMC4wNSwzLjU2IDIwLjEzLDQuMTkgMTkuNzksNC42MkwxNC4wMywxMkgxNFoiIC8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-folder-favorite: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+PHBhdGggY2xhc3M9ImpwLWljb24zIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxNjE2MSIgZD0iTTIwIDZoLThsLTItMkg0Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0yVjhjMC0xLjEtLjktMi0yLTJ6bS0yLjA2IDExTDE1IDE1LjI4IDEyLjA2IDE3bC43OC0zLjMzLTIuNTktMi4yNCAzLjQxLS4yOUwxNSA4bDEuMzQgMy4xNCAzLjQxLjI5LTIuNTkgMi4yNC43OCAzLjMzeiIvPgo8L3N2Zz4K);
  --jp-icon-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-home: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCIgZmlsbD0iIzAwMDAwMCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGNsYXNzPSJqcC1pY29uMyBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-html5: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMDAiIGQ9Ik0xMDguNCAwaDIzdjIyLjhoMjEuMlYwaDIzdjY5aC0yM1Y0NmgtMjF2MjNoLTIzLjJNMjA2IDIzaC0yMC4zVjBoNjMuN3YyM0gyMjl2NDZoLTIzbTUzLjUtNjloMjQuMWwxNC44IDI0LjNMMzEzLjIgMGgyNC4xdjY5aC0yM1YzNC44bC0xNi4xIDI0LjgtMTYuMS0yNC44VjY5aC0yMi42bTg5LjItNjloMjN2NDYuMmgzMi42VjY5aC01NS42Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2U0NGQyNiIgZD0iTTEwNy42IDQ3MWwtMzMtMzcwLjRoMzYyLjhsLTMzIDM3MC4yTDI1NS43IDUxMiIvPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNmMTY1MjkiIGQ9Ik0yNTYgNDgwLjVWMTMxaDE0OC4zTDM3NiA0NDciLz4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNlYmViZWIiIGQ9Ik0xNDIgMTc2LjNoMTE0djQ1LjRoLTY0LjJsNC4yIDQ2LjVoNjB2NDUuM0gxNTQuNG0yIDIyLjhIMjAybDMuMiAzNi4zIDUwLjggMTMuNnY0Ny40bC05My4yLTI2Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIiBkPSJNMzY5LjYgMTc2LjNIMjU1Ljh2NDUuNGgxMDkuNm0tNC4xIDQ2LjVIMjU1Ljh2NDUuNGg1NmwtNS4zIDU5LTUwLjcgMTMuNnY0Ny4ybDkzLTI1LjgiLz4KPC9zdmc+Cg==);
  --jp-icon-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1icmFuZDQganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNGRkYiIGQ9Ik0yLjIgMi4yaDE3LjV2MTcuNUgyLjJ6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzNGNTFCNSIgZD0iTTIuMiAyLjJ2MTcuNWgxNy41bC4xLTE3LjVIMi4yem0xMi4xIDIuMmMxLjIgMCAyLjIgMSAyLjIgMi4ycy0xIDIuMi0yLjIgMi4yLTIuMi0xLTIuMi0yLjIgMS0yLjIgMi4yLTIuMnpNNC40IDE3LjZsMy4zLTguOCAzLjMgNi42IDIuMi0zLjIgNC40IDUuNEg0LjR6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-info: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUwLjk3OCA1MC45NzgiPgoJPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KCQk8cGF0aCBkPSJNNDMuNTIsNy40NThDMzguNzExLDIuNjQ4LDMyLjMwNywwLDI1LjQ4OSwwQzE4LjY3LDAsMTIuMjY2LDIuNjQ4LDcuNDU4LDcuNDU4CgkJCWMtOS45NDMsOS45NDEtOS45NDMsMjYuMTE5LDAsMzYuMDYyYzQuODA5LDQuODA5LDExLjIxMiw3LjQ1NiwxOC4wMzEsNy40NThjMCwwLDAuMDAxLDAsMC4wMDIsMAoJCQljNi44MTYsMCwxMy4yMjEtMi42NDgsMTguMDI5LTcuNDU4YzQuODA5LTQuODA5LDcuNDU3LTExLjIxMiw3LjQ1Ny0xOC4wM0M1MC45NzcsMTguNjcsNDguMzI4LDEyLjI2Niw0My41Miw3LjQ1OHoKCQkJIE00Mi4xMDYsNDIuMTA1Yy00LjQzMiw0LjQzMS0xMC4zMzIsNi44NzItMTYuNjE1LDYuODcyaC0wLjAwMmMtNi4yODUtMC4wMDEtMTIuMTg3LTIuNDQxLTE2LjYxNy02Ljg3MgoJCQljLTkuMTYyLTkuMTYzLTkuMTYyLTI0LjA3MSwwLTMzLjIzM0MxMy4zMDMsNC40NCwxOS4yMDQsMiwyNS40ODksMmM2LjI4NCwwLDEyLjE4NiwyLjQ0LDE2LjYxNyw2Ljg3MgoJCQljNC40MzEsNC40MzEsNi44NzEsMTAuMzMyLDYuODcxLDE2LjYxN0M0OC45NzcsMzEuNzcyLDQ2LjUzNiwzNy42NzUsNDIuMTA2LDQyLjEwNXoiLz4KCQk8cGF0aCBkPSJNMjMuNTc4LDMyLjIxOGMtMC4wMjMtMS43MzQsMC4xNDMtMy4wNTksMC40OTYtMy45NzJjMC4zNTMtMC45MTMsMS4xMS0xLjk5NywyLjI3Mi0zLjI1MwoJCQljMC40NjgtMC41MzYsMC45MjMtMS4wNjIsMS4zNjctMS41NzVjMC42MjYtMC43NTMsMS4xMDQtMS40NzgsMS40MzYtMi4xNzVjMC4zMzEtMC43MDcsMC40OTUtMS41NDEsMC40OTUtMi41CgkJCWMwLTEuMDk2LTAuMjYtMi4wODgtMC43NzktMi45NzljLTAuNTY1LTAuODc5LTEuNTAxLTEuMzM2LTIuODA2LTEuMzY5Yy0xLjgwMiwwLjA1Ny0yLjk4NSwwLjY2Ny0zLjU1LDEuODMyCgkJCWMtMC4zMDEsMC41MzUtMC41MDMsMS4xNDEtMC42MDcsMS44MTRjLTAuMTM5LDAuNzA3LTAuMjA3LDEuNDMyLTAuMjA3LDIuMTc0aC0yLjkzN2MtMC4wOTEtMi4yMDgsMC40MDctNC4xMTQsMS40OTMtNS43MTkKCQkJYzEuMDYyLTEuNjQsMi44NTUtMi40ODEsNS4zNzgtMi41MjdjMi4xNiwwLjAyMywzLjg3NCwwLjYwOCw1LjE0MSwxLjc1OGMxLjI3OCwxLjE2LDEuOTI5LDIuNzY0LDEuOTUsNC44MTEKCQkJYzAsMS4xNDItMC4xMzcsMi4xMTEtMC40MSwyLjkxMWMtMC4zMDksMC44NDUtMC43MzEsMS41OTMtMS4yNjgsMi4yNDNjLTAuNDkyLDAuNjUtMS4wNjgsMS4zMTgtMS43MywyLjAwMgoJCQljLTAuNjUsMC42OTctMS4zMTMsMS40NzktMS45ODcsMi4zNDZjLTAuMjM5LDAuMzc3LTAuNDI5LDAuNzc3LTAuNTY1LDEuMTk5Yy0wLjE2LDAuOTU5LTAuMjE3LDEuOTUxLTAuMTcxLDIuOTc5CgkJCUMyNi41ODksMzIuMjE4LDIzLjU3OCwzMi4yMTgsMjMuNTc4LDMyLjIxOHogTTIzLjU3OCwzOC4yMnYtMy40ODRoMy4wNzZ2My40ODRIMjMuNTc4eiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-inspector: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaW5zcGVjdG9yLWljb24tY29sb3IganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tNSAxNEg0di00aDExdjR6bTAtNUg0VjloMTF2NHptNSA1aC00VjloNHY5eiIvPgo8L3N2Zz4K);
  --jp-icon-json: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtanNvbi1pY29uLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0Y5QTgyNSI+CiAgICA8cGF0aCBkPSJNMjAuMiAxMS44Yy0xLjYgMC0xLjcuNS0xLjcgMSAwIC40LjEuOS4xIDEuMy4xLjUuMS45LjEgMS4zIDAgMS43LTEuNCAyLjMtMy41IDIuM2gtLjl2LTEuOWguNWMxLjEgMCAxLjQgMCAxLjQtLjggMC0uMyAwLS42LS4xLTEgMC0uNC0uMS0uOC0uMS0xLjIgMC0xLjMgMC0xLjggMS4zLTItMS4zLS4yLTEuMy0uNy0xLjMtMiAwLS40LjEtLjguMS0xLjIuMS0uNC4xLS43LjEtMSAwLS44LS40LS43LTEuNC0uOGgtLjVWNC4xaC45YzIuMiAwIDMuNS43IDMuNSAyLjMgMCAuNC0uMS45LS4xIDEuMy0uMS41LS4xLjktLjEgMS4zIDAgLjUuMiAxIDEuNyAxdjEuOHpNMS44IDEwLjFjMS42IDAgMS43LS41IDEuNy0xIDAtLjQtLjEtLjktLjEtMS4zLS4xLS41LS4xLS45LS4xLTEuMyAwLTEuNiAxLjQtMi4zIDMuNS0yLjNoLjl2MS45aC0uNWMtMSAwLTEuNCAwLTEuNC44IDAgLjMgMCAuNi4xIDEgMCAuMi4xLjYuMSAxIDAgMS4zIDAgMS44LTEuMyAyQzYgMTEuMiA2IDExLjcgNiAxM2MwIC40LS4xLjgtLjEgMS4yLS4xLjMtLjEuNy0uMSAxIDAgLjguMy44IDEuNC44aC41djEuOWgtLjljLTIuMSAwLTMuNS0uNi0zLjUtMi4zIDAtLjQuMS0uOS4xLTEuMy4xLS41LjEtLjkuMS0xLjMgMC0uNS0uMi0xLTEuNy0xdi0xLjl6Ii8+CiAgICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjEzLjgiIHI9IjIuMSIvPgogICAgPGNpcmNsZSBjeD0iMTEiIGN5PSI4LjIiIHI9IjIuMSIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-julia: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDMyNSAzMDAiPgogIDxnIGNsYXNzPSJqcC1icmFuZDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjY2IzYzMzIj4KICAgIDxwYXRoIGQ9Ik0gMTUwLjg5ODQzOCAyMjUgQyAxNTAuODk4NDM4IDI2Ni40MjE4NzUgMTE3LjMyMDMxMiAzMDAgNzUuODk4NDM4IDMwMCBDIDM0LjQ3NjU2MiAzMDAgMC44OTg0MzggMjY2LjQyMTg3NSAwLjg5ODQzOCAyMjUgQyAwLjg5ODQzOCAxODMuNTc4MTI1IDM0LjQ3NjU2MiAxNTAgNzUuODk4NDM4IDE1MCBDIDExNy4zMjAzMTIgMTUwIDE1MC44OTg0MzggMTgzLjU3ODEyNSAxNTAuODk4NDM4IDIyNSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzM4OTgyNiI+CiAgICA8cGF0aCBkPSJNIDIzNy41IDc1IEMgMjM3LjUgMTE2LjQyMTg3NSAyMDMuOTIxODc1IDE1MCAxNjIuNSAxNTAgQyAxMjEuMDc4MTI1IDE1MCA4Ny41IDExNi40MjE4NzUgODcuNSA3NSBDIDg3LjUgMzMuNTc4MTI1IDEyMS4wNzgxMjUgMCAxNjIuNSAwIEMgMjAzLjkyMTg3NSAwIDIzNy41IDMzLjU3ODEyNSAyMzcuNSA3NSIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzk1NThiMiI+CiAgICA8cGF0aCBkPSJNIDMyNC4xMDE1NjIgMjI1IEMgMzI0LjEwMTU2MiAyNjYuNDIxODc1IDI5MC41MjM0MzggMzAwIDI0OS4xMDE1NjIgMzAwIEMgMjA3LjY3OTY4OCAzMDAgMTc0LjEwMTU2MiAyNjYuNDIxODc1IDE3NC4xMDE1NjIgMjI1IEMgMTc0LjEwMTU2MiAxODMuNTc4MTI1IDIwNy42Nzk2ODggMTUwIDI0OS4xMDE1NjIgMTUwIEMgMjkwLjUyMzQzOCAxNTAgMzI0LjEwMTU2MiAxODMuNTc4MTI1IDMyNC4xMDE1NjIgMjI1Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-jupyter-favicon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE2NSIgdmlld0JveD0iMCAwIDE1MiAxNjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgPGcgY2xhc3M9ImpwLWp1cHl0ZXItaWNvbi1jb2xvciIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA3ODk0NywgMTEwLjU4MjkyNykiIGQ9Ik03NS45NDIyODQyLDI5LjU4MDQ1NjEgQzQzLjMwMjM5NDcsMjkuNTgwNDU2MSAxNC43OTY3ODMyLDE3LjY1MzQ2MzQgMCwwIEM1LjUxMDgzMjExLDE1Ljg0MDY4MjkgMTUuNzgxNTM4OSwyOS41NjY3NzMyIDI5LjM5MDQ5NDcsMzkuMjc4NDE3MSBDNDIuOTk5Nyw0OC45ODk4NTM3IDU5LjI3MzcsNTQuMjA2NzgwNSA3NS45NjA1Nzg5LDU0LjIwNjc4MDUgQzkyLjY0NzQ1NzksNTQuMjA2NzgwNSAxMDguOTIxNDU4LDQ4Ljk4OTg1MzcgMTIyLjUzMDY2MywzOS4yNzg0MTcxIEMxMzYuMTM5NDUzLDI5LjU2Njc3MzIgMTQ2LjQxMDI4NCwxNS44NDA2ODI5IDE1MS45MjExNTgsMCBDMTM3LjA4Nzg2OCwxNy42NTM0NjM0IDEwOC41ODI1ODksMjkuNTgwNDU2MSA3NS45NDIyODQyLDI5LjU4MDQ1NjEgTDc1Ljk0MjI4NDIsMjkuNTgwNDU2MSBaIiAvPgogICAgPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMzczNjgsIDAuNzA0ODc4KSIgZD0iTTc1Ljk3ODQ1NzksMjQuNjI2NDA3MyBDMTA4LjYxODc2MywyNC42MjY0MDczIDEzNy4xMjQ0NTgsMzYuNTUzNDQxNSAxNTEuOTIxMTU4LDU0LjIwNjc4MDUgQzE0Ni40MTAyODQsMzguMzY2MjIyIDEzNi4xMzk0NTMsMjQuNjQwMTMxNyAxMjIuNTMwNjYzLDE0LjkyODQ4NzggQzEwOC45MjE0NTgsNS4yMTY4NDM5IDkyLjY0NzQ1NzksMCA3NS45NjA1Nzg5LDAgQzU5LjI3MzcsMCA0Mi45OTk3LDUuMjE2ODQzOSAyOS4zOTA0OTQ3LDE0LjkyODQ4NzggQzE1Ljc4MTUzODksMjQuNjQwMTMxNyA1LjUxMDgzMjExLDM4LjM2NjIyMiAwLDU0LjIwNjc4MDUgQzE0LjgzMzA4MTYsMzYuNTg5OTI5MyA0My4zMzg1Njg0LDI0LjYyNjQwNzMgNzUuOTc4NDU3OSwyNC42MjY0MDczIEw3NS45Nzg0NTc5LDI0LjYyNjQwNzMgWiIgLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-jupyter: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzkiIGhlaWdodD0iNTEiIHZpZXdCb3g9IjAgMCAzOSA1MSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzOCAtMjI4MSkiPgogICAgIDxnIGNsYXNzPSJqcC1qdXB5dGVyLWljb24tY29sb3IiIGZpbGw9IiNGMzc3MjYiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5Ljc0IDIzMTEuOTgpIiBkPSJNIDE4LjI2NDYgNy4xMzQxMUMgMTAuNDE0NSA3LjEzNDExIDMuNTU4NzIgNC4yNTc2IDAgMEMgMS4zMjUzOSAzLjgyMDQgMy43OTU1NiA3LjEzMDgxIDcuMDY4NiA5LjQ3MzAzQyAxMC4zNDE3IDExLjgxNTIgMTQuMjU1NyAxMy4wNzM0IDE4LjI2OSAxMy4wNzM0QyAyMi4yODIzIDEzLjA3MzQgMjYuMTk2MyAxMS44MTUyIDI5LjQ2OTQgOS40NzMwM0MgMzIuNzQyNCA3LjEzMDgxIDM1LjIxMjYgMy44MjA0IDM2LjUzOCAwQyAzMi45NzA1IDQuMjU3NiAyNi4xMTQ4IDcuMTM0MTEgMTguMjY0NiA3LjEzNDExWiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5LjczIDIyODUuNDgpIiBkPSJNIDE4LjI3MzMgNS45MzkzMUMgMjYuMTIzNSA1LjkzOTMxIDMyLjk3OTMgOC44MTU4MyAzNi41MzggMTMuMDczNEMgMzUuMjEyNiA5LjI1MzAzIDMyLjc0MjQgNS45NDI2MiAyOS40Njk0IDMuNjAwNEMgMjYuMTk2MyAxLjI1ODE4IDIyLjI4MjMgMCAxOC4yNjkgMEMgMTQuMjU1NyAwIDEwLjM0MTcgMS4yNTgxOCA3LjA2ODYgMy42MDA0QyAzLjc5NTU2IDUuOTQyNjIgMS4zMjUzOSA5LjI1MzAzIDAgMTMuMDczNEMgMy41Njc0NSA4LjgyNDYzIDEwLjQyMzIgNS45MzkzMSAxOC4yNzMzIDUuOTM5MzFaIi8+CiAgICA8L2c+CiAgICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjY5LjMgMjI4MS4zMSkiIGQ9Ik0gNS44OTM1MyAyLjg0NEMgNS45MTg4OSAzLjQzMTY1IDUuNzcwODUgNC4wMTM2NyA1LjQ2ODE1IDQuNTE2NDVDIDUuMTY1NDUgNS4wMTkyMiA0LjcyMTY4IDUuNDIwMTUgNC4xOTI5OSA1LjY2ODUxQyAzLjY2NDMgNS45MTY4OCAzLjA3NDQ0IDYuMDAxNTEgMi40OTgwNSA1LjkxMTcxQyAxLjkyMTY2IDUuODIxOSAxLjM4NDYzIDUuNTYxNyAwLjk1NDg5OCA1LjE2NDAxQyAwLjUyNTE3IDQuNzY2MzMgMC4yMjIwNTYgNC4yNDkwMyAwLjA4MzkwMzcgMy42Nzc1N0MgLTAuMDU0MjQ4MyAzLjEwNjExIC0wLjAyMTIzIDIuNTA2MTcgMC4xNzg3ODEgMS45NTM2NEMgMC4zNzg3OTMgMS40MDExIDAuNzM2ODA5IDAuOTIwODE3IDEuMjA3NTQgMC41NzM1MzhDIDEuNjc4MjYgMC4yMjYyNTkgMi4yNDA1NSAwLjAyNzU5MTkgMi44MjMyNiAwLjAwMjY3MjI5QyAzLjYwMzg5IC0wLjAzMDcxMTUgNC4zNjU3MyAwLjI0OTc4OSA0Ljk0MTQyIDAuNzgyNTUxQyA1LjUxNzExIDEuMzE1MzEgNS44NTk1NiAyLjA1Njc2IDUuODkzNTMgMi44NDRaIi8+CiAgICAgIDxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MzkuOCAyMzIzLjgxKSIgZD0iTSA3LjQyNzg5IDMuNTgzMzhDIDcuNDYwMDggNC4zMjQzIDcuMjczNTUgNS4wNTgxOSA2Ljg5MTkzIDUuNjkyMTNDIDYuNTEwMzEgNi4zMjYwNyA1Ljk1MDc1IDYuODMxNTYgNS4yODQxMSA3LjE0NDZDIDQuNjE3NDcgNy40NTc2MyAzLjg3MzcxIDcuNTY0MTQgMy4xNDcwMiA3LjQ1MDYzQyAyLjQyMDMyIDcuMzM3MTIgMS43NDMzNiA3LjAwODcgMS4yMDE4NCA2LjUwNjk1QyAwLjY2MDMyOCA2LjAwNTIgMC4yNzg2MSA1LjM1MjY4IDAuMTA1MDE3IDQuNjMyMDJDIC0wLjA2ODU3NTcgMy45MTEzNSAtMC4wMjYyMzYxIDMuMTU0OTQgMC4yMjY2NzUgMi40NTg1NkMgMC40Nzk1ODcgMS43NjIxNyAwLjkzMTY5NyAxLjE1NzEzIDEuNTI1NzYgMC43MjAwMzNDIDIuMTE5ODMgMC4yODI5MzUgMi44MjkxNCAwLjAzMzQzOTUgMy41NjM4OSAwLjAwMzEzMzQ0QyA0LjU0NjY3IC0wLjAzNzQwMzMgNS41MDUyOSAwLjMxNjcwNiA2LjIyOTYxIDAuOTg3ODM1QyA2Ljk1MzkzIDEuNjU4OTYgNy4zODQ4NCAyLjU5MjM1IDcuNDI3ODkgMy41ODMzOEwgNy40Mjc4OSAzLjU4MzM4WiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM4LjM2IDIyODYuMDYpIiBkPSJNIDIuMjc0NzEgNC4zOTYyOUMgMS44NDM2MyA0LjQxNTA4IDEuNDE2NzEgNC4zMDQ0NSAxLjA0Nzk5IDQuMDc4NDNDIDAuNjc5MjY4IDMuODUyNCAwLjM4NTMyOCAzLjUyMTE0IDAuMjAzMzcxIDMuMTI2NTZDIDAuMDIxNDEzNiAyLjczMTk4IC0wLjA0MDM3OTggMi4yOTE4MyAwLjAyNTgxMTYgMS44NjE4MUMgMC4wOTIwMDMxIDEuNDMxOCAwLjI4MzIwNCAxLjAzMTI2IDAuNTc1MjEzIDAuNzEwODgzQyAwLjg2NzIyMiAwLjM5MDUxIDEuMjQ2OTEgMC4xNjQ3MDggMS42NjYyMiAwLjA2MjA1OTJDIDIuMDg1NTMgLTAuMDQwNTg5NyAyLjUyNTYxIC0wLjAxNTQ3MTQgMi45MzA3NiAwLjEzNDIzNUMgMy4zMzU5MSAwLjI4Mzk0MSAzLjY4NzkyIDAuNTUxNTA1IDMuOTQyMjIgMC45MDMwNkMgNC4xOTY1MiAxLjI1NDYyIDQuMzQxNjkgMS42NzQzNiA0LjM1OTM1IDIuMTA5MTZDIDQuMzgyOTkgMi42OTEwNyA0LjE3Njc4IDMuMjU4NjkgMy43ODU5NyAzLjY4NzQ2QyAzLjM5NTE2IDQuMTE2MjQgMi44NTE2NiA0LjM3MTE2IDIuMjc0NzEgNC4zOTYyOUwgMi4yNzQ3MSA0LjM5NjI5WiIvPgogICAgPC9nPgogIDwvZz4+Cjwvc3ZnPgo=);
  --jp-icon-jupyterlab-wordmark: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIHZpZXdCb3g9IjAgMCAxODYwLjggNDc1Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0RTRFNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MC4xMzY0MDEsIDY0LjI3MTQ5MykiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDU4Ljg3NTU2NikiPgogICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA4NzYwMywgMC4xNDAyOTQpIj4KICAgICAgICA8cGF0aCBkPSJNLTQyNi45LDE2OS44YzAsNDguNy0zLjcsNjQuNy0xMy42LDc2LjRjLTEwLjgsMTAtMjUsMTUuNS0zOS43LDE1LjVsMy43LDI5IGMyMi44LDAuMyw0NC44LTcuOSw2MS45LTIzLjFjMTcuOC0xOC41LDI0LTQ0LjEsMjQtODMuM1YwSC00Mjd2MTcwLjFMLTQyNi45LDE2OS44TC00MjYuOSwxNjkuOHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjA0NTI5NiwgNTYuODM3MTA0KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTYyNDUzLCAxLjc5OTg0MikiPgogICAgICAgIDxwYXRoIGQ9Ik0tMzEyLDE0OGMwLDIxLDAsMzkuNSwxLjcsNTUuNGgtMzEuOGwtMi4xLTMzLjNoLTAuOGMtNi43LDExLjYtMTYuNCwyMS4zLTI4LDI3LjkgYy0xMS42LDYuNi0yNC44LDEwLTM4LjIsOS44Yy0zMS40LDAtNjktMTcuNy02OS04OVYwaDM2LjR2MTEyLjdjMCwzOC43LDExLjYsNjQuNyw0NC42LDY0LjdjMTAuMy0wLjIsMjAuNC0zLjUsMjguOS05LjQgYzguNS01LjksMTUuMS0xNC4zLDE4LjktMjMuOWMyLjItNi4xLDMuMy0xMi41LDMuMy0xOC45VjAuMmgzNi40VjE0OEgtMzEyTC0zMTIsMTQ4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOTAuMDEzMzIyLCA1My40Nzk2MzgpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS43MDY0NTgsIDAuMjMxNDI1KSI+CiAgICAgICAgPHBhdGggZD0iTS00NzguNiw3MS40YzAtMjYtMC44LTQ3LTEuNy02Ni43aDMyLjdsMS43LDM0LjhoMC44YzcuMS0xMi41LDE3LjUtMjIuOCwzMC4xLTI5LjcgYzEyLjUtNywyNi43LTEwLjMsNDEtOS44YzQ4LjMsMCw4NC43LDQxLjcsODQuNywxMDMuM2MwLDczLjEtNDMuNywxMDkuMi05MSwxMDkuMmMtMTIuMSwwLjUtMjQuMi0yLjItMzUtNy44IGMtMTAuOC01LjYtMTkuOS0xMy45LTI2LjYtMjQuMmgtMC44VjI5MWgtMzZ2LTIyMEwtNDc4LjYsNzEuNEwtNDc4LjYsNzEuNHogTS00NDIuNiwxMjUuNmMwLjEsNS4xLDAuNiwxMC4xLDEuNywxNS4xIGMzLDEyLjMsOS45LDIzLjMsMTkuOCwzMS4xYzkuOSw3LjgsMjIuMSwxMi4xLDM0LjcsMTIuMWMzOC41LDAsNjAuNy0zMS45LDYwLjctNzguNWMwLTQwLjctMjEuMS03NS42LTU5LjUtNzUuNiBjLTEyLjksMC40LTI1LjMsNS4xLTM1LjMsMTMuNGMtOS45LDguMy0xNi45LDE5LjctMTkuNiwzMi40Yy0xLjUsNC45LTIuMywxMC0yLjUsMTUuMVYxMjUuNkwtNDQyLjYsMTI1LjZMLTQ0Mi42LDEyNS42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDYuNzQwNzI2LCA1Ni44MzcxMDQpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC43NTEyMjYsIDEuOTg5Mjk5KSI+CiAgICAgICAgPHBhdGggZD0iTS00NDAuOCwwbDQzLjcsMTIwLjFjNC41LDEzLjQsOS41LDI5LjQsMTIuOCw0MS43aDAuOGMzLjctMTIuMiw3LjktMjcuNywxMi44LTQyLjQgbDM5LjctMTE5LjJoMzguNUwtMzQ2LjksMTQ1Yy0yNiw2OS43LTQzLjcsMTA1LjQtNjguNiwxMjcuMmMtMTIuNSwxMS43LTI3LjksMjAtNDQuNiwyMy45bC05LjEtMzEuMSBjMTEuNy0zLjksMjIuNS0xMC4xLDMxLjgtMTguMWMxMy4yLTExLjEsMjMuNy0yNS4yLDMwLjYtNDEuMmMxLjUtMi44LDIuNS01LjcsMi45LTguOGMtMC4zLTMuMy0xLjItNi42LTIuNS05LjdMLTQ4MC4yLDAuMSBoMzkuN0wtNDQwLjgsMEwtNDQwLjgsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODIyLjc0ODEwNCwgMC4wMDAwMDApIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS40NjQwNTAsIDAuMzc4OTE0KSI+CiAgICAgICAgPHBhdGggZD0iTS00MTMuNywwdjU4LjNoNTJ2MjguMmgtNTJWMTk2YzAsMjUsNywzOS41LDI3LjMsMzkuNWM3LjEsMC4xLDE0LjItMC43LDIxLjEtMi41IGwxLjcsMjcuN2MtMTAuMywzLjctMjEuMyw1LjQtMzIuMiw1Yy03LjMsMC40LTE0LjYtMC43LTIxLjMtMy40Yy02LjgtMi43LTEyLjktNi44LTE3LjktMTIuMWMtMTAuMy0xMC45LTE0LjEtMjktMTQuMS01Mi45IFY4Ni41aC0zMVY1OC4zaDMxVjkuNkwtNDEzLjcsMEwtNDEzLjcsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTc0LjQzMzI4NiwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuOTkwMDM0LCAwLjYxMDMzOSkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDQ1LjgsMTEzYzAuOCw1MCwzMi4yLDcwLjYsNjguNiw3MC42YzE5LDAuNiwzNy45LTMsNTUuMy0xMC41bDYuMiwyNi40IGMtMjAuOSw4LjktNDMuNSwxMy4xLTY2LjIsMTIuNmMtNjEuNSwwLTk4LjMtNDEuMi05OC4zLTEwMi41Qy00ODAuMiw0OC4yLTQ0NC43LDAtMzg2LjUsMGM2NS4yLDAsODIuNyw1OC4zLDgyLjcsOTUuNyBjLTAuMSw1LjgtMC41LDExLjUtMS4yLDE3LjJoLTE0MC42SC00NDUuOEwtNDQ1LjgsMTEzeiBNLTMzOS4yLDg2LjZjMC40LTIzLjUtOS41LTYwLjEtNTAuNC02MC4xIGMtMzYuOCwwLTUyLjgsMzQuNC01NS43LDYwLjFILTMzOS4yTC0zMzkuMiw4Ni42TC0zMzkuMiw4Ni42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAxLjk2MTA1OCwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMTc5NjQwLCAwLjcwNTA2OCkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDc4LjYsNjhjMC0yMy45LTAuNC00NC41LTEuNy02My40aDMxLjhsMS4yLDM5LjloMS43YzkuMS0yNy4zLDMxLTQ0LjUsNTUuMy00NC41IGMzLjUtMC4xLDcsMC40LDEwLjMsMS4ydjM0LjhjLTQuMS0wLjktOC4yLTEuMy0xMi40LTEuMmMtMjUuNiwwLTQzLjcsMTkuNy00OC43LDQ3LjRjLTEsNS43LTEuNiwxMS41LTEuNywxNy4ydjEwOC4zaC0zNlY2OCBMLTQ3OC42LDY4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCBkPSJNMTM1Mi4zLDMyNi4yaDM3VjI4aC0zN1YzMjYuMnogTTE2MDQuOCwzMjYuMmMtMi41LTEzLjktMy40LTMxLjEtMy40LTQ4Ljd2LTc2IGMwLTQwLjctMTUuMS04My4xLTc3LjMtODMuMWMtMjUuNiwwLTUwLDcuMS02Ni44LDE4LjFsOC40LDI0LjRjMTQuMy05LjIsMzQtMTUuMSw1My0xNS4xYzQxLjYsMCw0Ni4yLDMwLjIsNDYuMiw0N3Y0LjIgYy03OC42LTAuNC0xMjIuMywyNi41LTEyMi4zLDc1LjZjMCwyOS40LDIxLDU4LjQsNjIuMiw1OC40YzI5LDAsNTAuOS0xNC4zLDYyLjItMzAuMmgxLjNsMi45LDI1LjZIMTYwNC44eiBNMTU2NS43LDI1Ny43IGMwLDMuOC0wLjgsOC0yLjEsMTEuOGMtNS45LDE3LjItMjIuNywzNC00OS4yLDM0Yy0xOC45LDAtMzQuOS0xMS4zLTM0LjktMzUuM2MwLTM5LjUsNDUuOC00Ni42LDg2LjItNDUuOFYyNTcuN3ogTTE2OTguNSwzMjYuMiBsMS43LTMzLjZoMS4zYzE1LjEsMjYuOSwzOC43LDM4LjIsNjguMSwzOC4yYzQ1LjQsMCw5MS4yLTM2LjEsOTEuMi0xMDguOGMwLjQtNjEuNy0zNS4zLTEwMy43LTg1LjctMTAzLjcgYy0zMi44LDAtNTYuMywxNC43LTY5LjMsMzcuNGgtMC44VjI4aC0zNi42djI0NS43YzAsMTguMS0wLjgsMzguNi0xLjcsNTIuNUgxNjk4LjV6IE0xNzA0LjgsMjA4LjJjMC01LjksMS4zLTEwLjksMi4xLTE1LjEgYzcuNi0yOC4xLDMxLjEtNDUuNCw1Ni4zLTQ1LjRjMzkuNSwwLDYwLjUsMzQuOSw2MC41LDc1LjZjMCw0Ni42LTIzLjEsNzguMS02MS44LDc4LjFjLTI2LjksMC00OC4zLTE3LjYtNTUuNS00My4zIGMtMC44LTQuMi0xLjctOC44LTEuNy0xMy40VjIwOC4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzYxNjE2MSIgZD0iTTE1IDlIOXY2aDZWOXptLTIgNGgtMnYtMmgydjJ6bTgtMlY5aC0yVjdjMC0xLjEtLjktMi0yLTJoLTJWM2gtMnYyaC0yVjNIOXYySDdjLTEuMSAwLTIgLjktMiAydjJIM3YyaDJ2MkgzdjJoMnYyYzAgMS4xLjkgMiAyIDJoMnYyaDJ2LTJoMnYyaDJ2LTJoMmMxLjEgMCAyLS45IDItMnYtMmgydi0yaC0ydi0yaDJ6bS00IDZIN1Y3aDEwdjEweiIvPgo8L3N2Zz4K);
  --jp-icon-keyboard: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMTdjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0tOSAzaDJ2MmgtMlY4em0wIDNoMnYyaC0ydi0yek04IDhoMnYySDhWOHptMCAzaDJ2Mkg4di0yem0tMSAySDV2LTJoMnYyem0wLTNINVY4aDJ2MnptOSA3SDh2LTJoOHYyem0wLTRoLTJ2LTJoMnYyem0wLTNoLTJWOGgydjJ6bTMgM2gtMnYtMmgydjJ6bTAtM2gtMlY4aDJ2MnoiLz4KPC9zdmc+Cg==);
  --jp-icon-launch: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik0yNiwyOEg2YTIuMDAyNywyLjAwMjcsMCwwLDEtMi0yVjZBMi4wMDI3LDIuMDAyNywwLDAsMSw2LDRIMTZWNkg2VjI2SDI2VjE2aDJWMjZBMi4wMDI3LDIuMDAyNywwLDAsMSwyNiwyOFoiLz4KICAgIDxwb2x5Z29uIHBvaW50cz0iMjAgMiAyMCA0IDI2LjU4NiA0IDE4IDEyLjU4NiAxOS40MTQgMTQgMjggNS40MTQgMjggMTIgMzAgMTIgMzAgMiAyMCAyIi8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-launcher: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkgMTlINVY1aDdWM0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3oiLz4KPC9zdmc+Cg==);
  --jp-icon-line-form: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9IndoaXRlIiBkPSJNNS44OCA0LjEyTDEzLjc2IDEybC03Ljg4IDcuODhMOCAyMmwxMC0xMEw4IDJ6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-link: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjF6TTggMTNoOHYtMkg4djJ6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xOSA1djE0SDVWNWgxNG0xLjEtMkgzLjljLS41IDAtLjkuNC0uOS45djE2LjJjMCAuNC40LjkuOS45aDE2LjJjLjQgMCAuOS0uNS45LS45VjMuOWMwLS41LS41LS45LS45LS45ek0xMSA3aDZ2MmgtNlY3em0wIDRoNnYyaC02di0yem0wIDRoNnYyaC02ek03IDdoMnYySDd6bTAgNGgydjJIN3ptMCA0aDJ2Mkg3eiIvPgo8L3N2Zz4K);
  --jp-icon-markdown: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjN0IxRkEyIiBkPSJNNSAxNC45aDEybC02LjEgNnptOS40LTYuOGMwLTEuMy0uMS0yLjktLjEtNC41LS40IDEuNC0uOSAyLjktMS4zIDQuM2wtMS4zIDQuM2gtMkw4LjUgNy45Yy0uNC0xLjMtLjctMi45LTEtNC4zLS4xIDEuNi0uMSAzLjItLjIgNC42TDcgMTIuNEg0LjhsLjctMTFoMy4zTDEwIDVjLjQgMS4yLjcgMi43IDEgMy45LjMtMS4yLjctMi42IDEtMy45bDEuMi0zLjdoMy4zbC42IDExaC0yLjRsLS4zLTQuMnoiLz4KPC9zdmc+Cg==);
  --jp-icon-move-down: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMTIuNDcxIDcuNTI4OTlDMTIuNzYzMiA3LjIzNjg0IDEyLjc2MzIgNi43NjMxNiAxMi40NzEgNi40NzEwMVY2LjQ3MTAxQzEyLjE3OSA2LjE3OTA1IDExLjcwNTcgNi4xNzg4NCAxMS40MTM1IDYuNDcwNTRMNy43NSAxMC4xMjc1VjEuNzVDNy43NSAxLjMzNTc5IDcuNDE0MjEgMSA3IDFWMUM2LjU4NTc5IDEgNi4yNSAxLjMzNTc5IDYuMjUgMS43NVYxMC4xMjc1TDIuNTk3MjYgNi40NjgyMkMyLjMwMzM4IDYuMTczODEgMS44MjY0MSA2LjE3MzU5IDEuNTMyMjYgNi40Njc3NFY2LjQ2Nzc0QzEuMjM4MyA2Ljc2MTcgMS4yMzgzIDcuMjM4MyAxLjUzMjI2IDcuNTMyMjZMNi4yOTI4OSAxMi4yOTI5QzYuNjgzNDIgMTIuNjgzNCA3LjMxNjU4IDEyLjY4MzQgNy43MDcxMSAxMi4yOTI5TDEyLjQ3MSA3LjUyODk5WiIgZmlsbD0iIzYxNjE2MSIvPgo8L3N2Zz4K);
  --jp-icon-move-up: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggY2xhc3M9ImpwLWljb24zIiBkPSJNMS41Mjg5OSA2LjQ3MTAxQzEuMjM2ODQgNi43NjMxNiAxLjIzNjg0IDcuMjM2ODQgMS41Mjg5OSA3LjUyODk5VjcuNTI4OTlDMS44MjA5NSA3LjgyMDk1IDIuMjk0MjYgNy44MjExNiAyLjU4NjQ5IDcuNTI5NDZMNi4yNSAzLjg3MjVWMTIuMjVDNi4yNSAxMi42NjQyIDYuNTg1NzkgMTMgNyAxM1YxM0M3LjQxNDIxIDEzIDcuNzUgMTIuNjY0MiA3Ljc1IDEyLjI1VjMuODcyNUwxMS40MDI3IDcuNTMxNzhDMTEuNjk2NiA3LjgyNjE5IDEyLjE3MzYgNy44MjY0MSAxMi40Njc3IDcuNTMyMjZWNy41MzIyNkMxMi43NjE3IDcuMjM4MyAxMi43NjE3IDYuNzYxNyAxMi40Njc3IDYuNDY3NzRMNy43MDcxMSAxLjcwNzExQzcuMzE2NTggMS4zMTY1OCA2LjY4MzQyIDEuMzE2NTggNi4yOTI4OSAxLjcwNzExTDEuNTI4OTkgNi40NzEwMVoiIGZpbGw9IiM2MTYxNjEiLz4KPC9zdmc+Cg==);
  --jp-icon-new-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDZoLThsLTItMkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAxOGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY4YzAtMS4xMS0uODktMi0yLTJ6bS0xIDhoLTN2M2gtMnYtM2gtM3YtMmgzVjloMnYzaDN2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-not-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI1IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMTkgMTcuMTg0NCAyLjk2OTY4IDE0LjMwMzIgMS44NjA5NCAxMS40NDA5WiIvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24yIiBzdHJva2U9IiMzMzMzMzMiIHN0cm9rZS13aWR0aD0iMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOS4zMTU5MiA5LjMyMDMxKSIgZD0iTTcuMzY4NDIgMEwwIDcuMzY0NzkiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkuMzE1OTIgMTYuNjgzNikgc2NhbGUoMSAtMSkiIGQ9Ik03LjM2ODQyIDBMMCA3LjM2NDc5Ii8+Cjwvc3ZnPgo=);
  --jp-icon-notebook: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtbm90ZWJvb2staWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNFRjZDMDAiPgogICAgPHBhdGggZD0iTTE4LjcgMy4zdjE1LjRIMy4zVjMuM2gxNS40bTEuNS0xLjVIMS44djE4LjNoMTguM2wuMS0xOC4zeiIvPgogICAgPHBhdGggZD0iTTE2LjUgMTYuNWwtNS40LTQuMy01LjYgNC4zdi0xMWgxMXoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-numbering: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyOCAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTQgMTlINlYxOS41SDVWMjAuNUg2VjIxSDRWMjJIN1YxOEg0VjE5Wk01IDEwSDZWNkg0VjdINVYxMFpNNCAxM0g1LjhMNCAxNS4xVjE2SDdWMTVINS4yTDcgMTIuOVYxMkg0VjEzWk05IDdWOUgyM1Y3SDlaTTkgMjFIMjNWMTlIOVYyMVpNOSAxNUgyM1YxM0g5VjE1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-offline-bolt: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDIuMDJjLTUuNTEgMC05Ljk4IDQuNDctOS45OCA5Ljk4czQuNDcgOS45OCA5Ljk4IDkuOTggOS45OC00LjQ3IDkuOTgtOS45OFMxNy41MSAyLjAyIDEyIDIuMDJ6TTExLjQ4IDIwdi02LjI2SDhMMTMgNHY2LjI2aDMuMzVMMTEuNDggMjB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-palette: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE4IDEzVjIwSDRWNkg5LjAyQzkuMDcgNS4yOSA5LjI0IDQuNjIgOS41IDRINEMyLjkgNCAyIDQuOSAyIDZWMjBDMiAyMS4xIDIuOSAyMiA0IDIySDE4QzE5LjEgMjIgMjAgMjEuMSAyMCAyMFYxNUwxOCAxM1pNMTkuMyA4Ljg5QzE5Ljc0IDguMTkgMjAgNy4zOCAyMCA2LjVDMjAgNC4wMSAxNy45OSAyIDE1LjUgMkMxMy4wMSAyIDExIDQuMDEgMTEgNi41QzExIDguOTkgMTMuMDEgMTEgMTUuNDkgMTFDMTYuMzcgMTEgMTcuMTkgMTAuNzQgMTcuODggMTAuM0wyMSAxMy40MkwyMi40MiAxMkwxOS4zIDguODlaTTE1LjUgOUMxNC4xMiA5IDEzIDcuODggMTMgNi41QzEzIDUuMTIgMTQuMTIgNCAxNS41IDRDMTYuODggNCAxOCA1LjEyIDE4IDYuNUMxOCA3Ljg4IDE2Ljg4IDkgMTUuNSA5WiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDZIOS4wMTg5NEM5LjAwNjM5IDYuMTY1MDIgOSA2LjMzMTc2IDkgNi41QzkgOC44MTU3NyAxMC4yMTEgMTAuODQ4NyAxMi4wMzQzIDEySDlWMTRIMTZWMTIuOTgxMUMxNi41NzAzIDEyLjkzNzcgMTcuMTIgMTIuODIwNyAxNy42Mzk2IDEyLjYzOTZMMTggMTNWMjBINFY2Wk04IDhINlYxMEg4VjhaTTYgMTJIOFYxNEg2VjEyWk04IDE2SDZWMThIOFYxNlpNOSAxNkgxNlYxOEg5VjE2WiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-paste: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-pdf: url(data:image/svg+xml;base64,PHN2ZwogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMiAyMiIgd2lkdGg9IjE2Ij4KICAgIDxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI0ZGMkEyQSIKICAgICAgIGQ9Im0gMjIuMzQ0MzY5LC0zLjAxNjM2NDIgaCA1LjYzODYwNCB2IDEuNTc5MjQzMyBoIC0zLjU0OTIyNyB2IDEuNTA4NjkyOTkgaCAzLjMzNzU3NiBWIDEuNjUwODE1NCBoIC0zLjMzNzU3NiB2IDMuNDM1MjYxMyBoIC0yLjA4OTM3NyB6IG0gLTcuMTM2NDQ0LDEuNTc5MjQzMyB2IDQuOTQzOTU0MyBoIDAuNzQ4OTIgcSAxLjI4MDc2MSwwIDEuOTUzNzAzLC0wLjYzNDk1MzUgMC42NzgzNjksLTAuNjM0OTUzNSAwLjY3ODM2OSwtMS44NDUxNjQxIDAsLTEuMjA0NzgzNTUgLTAuNjcyOTQyLC0xLjgzNDMxMDExIC0wLjY3Mjk0MiwtMC42Mjk1MjY1OSAtMS45NTkxMywtMC42Mjk1MjY1OSB6IG0gLTIuMDg5Mzc3LC0xLjU3OTI0MzMgaCAyLjIwMzM0MyBxIDEuODQ1MTY0LDAgMi43NDYwMzksMC4yNjU5MjA3IDAuOTA2MzAxLDAuMjYwNDkzNyAxLjU1MjEwOCwwLjg5MDAyMDMgMC41Njk4MywwLjU0ODEyMjMgMC44NDY2MDUsMS4yNjQ0ODAwNiAwLjI3Njc3NCwwLjcxNjM1NzgxIDAuMjc2Nzc0LDEuNjIyNjU4OTQgMCwwLjkxNzE1NTEgLTAuMjc2Nzc0LDEuNjM4OTM5OSAtMC4yNzY3NzUsMC43MTYzNTc4IC0wLjg0NjYwNSwxLjI2NDQ4IC0wLjY1MTIzNCwwLjYyOTUyNjYgLTEuNTYyOTYyLDAuODk1NDQ3MyAtMC45MTE3MjgsMC4yNjA0OTM3IC0yLjczNTE4NSwwLjI2MDQ5MzcgaCAtMi4yMDMzNDMgeiBtIC04LjE0NTg1NjUsMCBoIDMuNDY3ODIzIHEgMS41NDY2ODE2LDAgMi4zNzE1Nzg1LDAuNjg5MjIzIDAuODMwMzI0LDAuNjgzNzk2MSAwLjgzMDMyNCwxLjk1MzcwMzE0IDAsMS4yNzUzMzM5NyAtMC44MzAzMjQsMS45NjQ1NTcwNiBRIDkuOTg3MTk2MSwyLjI3NDkxNSA4LjQ0MDUxNDUsMi4yNzQ5MTUgSCA3LjA2MjA2ODQgViA1LjA4NjA3NjcgSCA0Ljk3MjY5MTUgWiBtIDIuMDg5Mzc2OSwxLjUxNDExOTkgdiAyLjI2MzAzOTQzIGggMS4xNTU5NDEgcSAwLjYwNzgxODgsMCAwLjkzODg2MjksLTAuMjkzMDU1NDcgMC4zMzEwNDQxLC0wLjI5ODQ4MjQxIDAuMzMxMDQ0MSwtMC44NDExNzc3MiAwLC0wLjU0MjY5NTMxIC0wLjMzMTA0NDEsLTAuODM1NzUwNzQgLTAuMzMxMDQ0MSwtMC4yOTMwNTU1IC0wLjkzODg2MjksLTAuMjkzMDU1NSB6IgovPgo8L3N2Zz4K);
  --jp-icon-python: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iLTEwIC0xMCAxMzEuMTYxMzYxNjk0MzM1OTQgMTMyLjM4ODk5OTkzODk2NDg0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMzA2OTk4IiBkPSJNIDU0LjkxODc4NSw5LjE5Mjc0MjFlLTQgQyA1MC4zMzUxMzIsMC4wMjIyMTcyNyA0NS45NTc4NDYsMC40MTMxMzY5NyA0Mi4xMDYyODUsMS4wOTQ2NjkzIDMwLjc2MDA2OSwzLjA5OTE3MzEgMjguNzAwMDM2LDcuMjk0NzcxNCAyOC43MDAwMzUsMTUuMDMyMTY5IHYgMTAuMjE4NzUgaCAyNi44MTI1IHYgMy40MDYyNSBoIC0yNi44MTI1IC0xMC4wNjI1IGMgLTcuNzkyNDU5LDAgLTE0LjYxNTc1ODgsNC42ODM3MTcgLTE2Ljc0OTk5OTgsMTMuNTkzNzUgLTIuNDYxODE5OTgsMTAuMjEyOTY2IC0yLjU3MTAxNTA4LDE2LjU4NjAyMyAwLDI3LjI1IDEuOTA1OTI4Myw3LjkzNzg1MiA2LjQ1NzU0MzIsMTMuNTkzNzQ4IDE0LjI0OTk5OTgsMTMuNTkzNzUgaCA5LjIxODc1IHYgLTEyLjI1IGMgMCwtOC44NDk5MDIgNy42NTcxNDQsLTE2LjY1NjI0OCAxNi43NSwtMTYuNjU2MjUgaCAyNi43ODEyNSBjIDcuNDU0OTUxLDAgMTMuNDA2MjUzLC02LjEzODE2NCAxMy40MDYyNSwtMTMuNjI1IHYgLTI1LjUzMTI1IGMgMCwtNy4yNjYzMzg2IC02LjEyOTk4LC0xMi43MjQ3NzcxIC0xMy40MDYyNSwtMTMuOTM3NDk5NyBDIDY0LjI4MTU0OCwwLjMyNzk0Mzk3IDU5LjUwMjQzOCwtMC4wMjAzNzkwMyA1NC45MTg3ODUsOS4xOTI3NDIxZS00IFogbSAtMTQuNSw4LjIxODc1MDEyNTc5IGMgMi43Njk1NDcsMCA1LjAzMTI1LDIuMjk4NjQ1NiA1LjAzMTI1LDUuMTI0OTk5NiAtMmUtNiwyLjgxNjMzNiAtMi4yNjE3MDMsNS4wOTM3NSAtNS4wMzEyNSw1LjA5Mzc1IC0yLjc3OTQ3NiwtMWUtNiAtNS4wMzEyNSwtMi4yNzc0MTUgLTUuMDMxMjUsLTUuMDkzNzUgLTEwZS03LC0yLjgyNjM1MyAyLjI1MTc3NCwtNS4xMjQ5OTk2IDUuMDMxMjUsLTUuMTI0OTk5NiB6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2ZmZDQzYiIgZD0ibSA4NS42Mzc1MzUsMjguNjU3MTY5IHYgMTEuOTA2MjUgYyAwLDkuMjMwNzU1IC03LjgyNTg5NSwxNi45OTk5OTkgLTE2Ljc1LDE3IGggLTI2Ljc4MTI1IGMgLTcuMzM1ODMzLDAgLTEzLjQwNjI0OSw2LjI3ODQ4MyAtMTMuNDA2MjUsMTMuNjI1IHYgMjUuNTMxMjQ3IGMgMCw3LjI2NjM0NCA2LjMxODU4OCwxMS41NDAzMjQgMTMuNDA2MjUsMTMuNjI1MDA0IDguNDg3MzMxLDIuNDk1NjEgMTYuNjI2MjM3LDIuOTQ2NjMgMjYuNzgxMjUsMCA2Ljc1MDE1NSwtMS45NTQzOSAxMy40MDYyNTMsLTUuODg3NjEgMTMuNDA2MjUsLTEzLjYyNTAwNCBWIDg2LjUwMDkxOSBoIC0yNi43ODEyNSB2IC0zLjQwNjI1IGggMjYuNzgxMjUgMTMuNDA2MjU0IGMgNy43OTI0NjEsMCAxMC42OTYyNTEsLTUuNDM1NDA4IDEzLjQwNjI0MSwtMTMuNTkzNzUgMi43OTkzMywtOC4zOTg4ODYgMi42ODAyMiwtMTYuNDc1Nzc2IDAsLTI3LjI1IC0xLjkyNTc4LC03Ljc1NzQ0MSAtNS42MDM4NywtMTMuNTkzNzUgLTEzLjQwNjI0MSwtMTMuNTkzNzUgeiBtIC0xNS4wNjI1LDY0LjY1NjI1IGMgMi43Nzk0NzgsM2UtNiA1LjAzMTI1LDIuMjc3NDE3IDUuMDMxMjUsNS4wOTM3NDcgLTJlLTYsMi44MjYzNTQgLTIuMjUxNzc1LDUuMTI1MDA0IC01LjAzMTI1LDUuMTI1MDA0IC0yLjc2OTU1LDAgLTUuMDMxMjUsLTIuMjk4NjUgLTUuMDMxMjUsLTUuMTI1MDA0IDJlLTYsLTIuODE2MzMgMi4yNjE2OTcsLTUuMDkzNzQ3IDUuMDMxMjUsLTUuMDkzNzQ3IHoiLz4KPC9zdmc+Cg==);
  --jp-icon-r-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjE5NkYzIiBkPSJNNC40IDIuNWMxLjItLjEgMi45LS4zIDQuOS0uMyAyLjUgMCA0LjEuNCA1LjIgMS4zIDEgLjcgMS41IDEuOSAxLjUgMy41IDAgMi0xLjQgMy41LTIuOSA0LjEgMS4yLjQgMS43IDEuNiAyLjIgMyAuNiAxLjkgMSAzLjkgMS4zIDQuNmgtMy44Yy0uMy0uNC0uOC0xLjctMS4yLTMuN3MtMS4yLTIuNi0yLjYtMi42aC0uOXY2LjRINC40VjIuNXptMy43IDYuOWgxLjRjMS45IDAgMi45LS45IDIuOS0yLjNzLTEtMi4zLTIuOC0yLjNjLS43IDAtMS4zIDAtMS42LjJ2NC41aC4xdi0uMXoiLz4KPC9zdmc+Cg==);
  --jp-icon-react: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMTUwIDE1MCA1NDEuOSAyOTUuMyI+CiAgPGcgY2xhc3M9ImpwLWljb24tYnJhbmQyIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxREFGQiI+CiAgICA8cGF0aCBkPSJNNjY2LjMgMjk2LjVjMC0zMi41LTQwLjctNjMuMy0xMDMuMS04Mi40IDE0LjQtNjMuNiA4LTExNC4yLTIwLjItMTMwLjQtNi41LTMuOC0xNC4xLTUuNi0yMi40LTUuNnYyMi4zYzQuNiAwIDguMy45IDExLjQgMi42IDEzLjYgNy44IDE5LjUgMzcuNSAxNC45IDc1LjctMS4xIDkuNC0yLjkgMTkuMy01LjEgMjkuNC0xOS42LTQuOC00MS04LjUtNjMuNS0xMC45LTEzLjUtMTguNS0yNy41LTM1LjMtNDEuNi01MCAzMi42LTMwLjMgNjMuMi00Ni45IDg0LTQ2LjlWNzhjLTI3LjUgMC02My41IDE5LjYtOTkuOSA1My42LTM2LjQtMzMuOC03Mi40LTUzLjItOTkuOS01My4ydjIyLjNjMjAuNyAwIDUxLjQgMTYuNSA4NCA0Ni42LTE0IDE0LjctMjggMzEuNC00MS4zIDQ5LjktMjIuNiAyLjQtNDQgNi4xLTYzLjYgMTEtMi4zLTEwLTQtMTkuNy01LjItMjktNC43LTM4LjIgMS4xLTY3LjkgMTQuNi03NS44IDMtMS44IDYuOS0yLjYgMTEuNS0yLjZWNzguNWMtOC40IDAtMTYgMS44LTIyLjYgNS42LTI4LjEgMTYuMi0zNC40IDY2LjctMTkuOSAxMzAuMS02Mi4yIDE5LjItMTAyLjcgNDkuOS0xMDIuNyA4Mi4zIDAgMzIuNSA0MC43IDYzLjMgMTAzLjEgODIuNC0xNC40IDYzLjYtOCAxMTQuMiAyMC4yIDEzMC40IDYuNSAzLjggMTQuMSA1LjYgMjIuNSA1LjYgMjcuNSAwIDYzLjUtMTkuNiA5OS45LTUzLjYgMzYuNCAzMy44IDcyLjQgNTMuMiA5OS45IDUzLjIgOC40IDAgMTYtMS44IDIyLjYtNS42IDI4LjEtMTYuMiAzNC40LTY2LjcgMTkuOS0xMzAuMSA2Mi0xOS4xIDEwMi41LTQ5LjkgMTAyLjUtODIuM3ptLTEzMC4yLTY2LjdjLTMuNyAxMi45LTguMyAyNi4yLTEzLjUgMzkuNS00LjEtOC04LjQtMTYtMTMuMS0yNC00LjYtOC05LjUtMTUuOC0xNC40LTIzLjQgMTQuMiAyLjEgMjcuOSA0LjcgNDEgNy45em0tNDUuOCAxMDYuNWMtNy44IDEzLjUtMTUuOCAyNi4zLTI0LjEgMzguMi0xNC45IDEuMy0zMCAyLTQ1LjIgMi0xNS4xIDAtMzAuMi0uNy00NS0xLjktOC4zLTExLjktMTYuNC0yNC42LTI0LjItMzgtNy42LTEzLjEtMTQuNS0yNi40LTIwLjgtMzkuOCA2LjItMTMuNCAxMy4yLTI2LjggMjAuNy0zOS45IDcuOC0xMy41IDE1LjgtMjYuMyAyNC4xLTM4LjIgMTQuOS0xLjMgMzAtMiA0NS4yLTIgMTUuMSAwIDMwLjIuNyA0NSAxLjkgOC4zIDExLjkgMTYuNCAyNC42IDI0LjIgMzggNy42IDEzLjEgMTQuNSAyNi40IDIwLjggMzkuOC02LjMgMTMuNC0xMy4yIDI2LjgtMjAuNyAzOS45em0zMi4zLTEzYzUuNCAxMy40IDEwIDI2LjggMTMuOCAzOS44LTEzLjEgMy4yLTI2LjkgNS45LTQxLjIgOCA0LjktNy43IDkuOC0xNS42IDE0LjQtMjMuNyA0LjYtOCA4LjktMTYuMSAxMy0yNC4xek00MjEuMiA0MzBjLTkuMy05LjYtMTguNi0yMC4zLTI3LjgtMzIgOSAuNCAxOC4yLjcgMjcuNS43IDkuNCAwIDE4LjctLjIgMjcuOC0uNy05IDExLjctMTguMyAyMi40LTI3LjUgMzJ6bS03NC40LTU4LjljLTE0LjItMi4xLTI3LjktNC43LTQxLTcuOSAzLjctMTIuOSA4LjMtMjYuMiAxMy41LTM5LjUgNC4xIDggOC40IDE2IDEzLjEgMjQgNC43IDggOS41IDE1LjggMTQuNCAyMy40ek00MjAuNyAxNjNjOS4zIDkuNiAxOC42IDIwLjMgMjcuOCAzMi05LS40LTE4LjItLjctMjcuNS0uNy05LjQgMC0xOC43LjItMjcuOC43IDktMTEuNyAxOC4zLTIyLjQgMjcuNS0zMnptLTc0IDU4LjljLTQuOSA3LjctOS44IDE1LjYtMTQuNCAyMy43LTQuNiA4LTguOSAxNi0xMyAyNC01LjQtMTMuNC0xMC0yNi44LTEzLjgtMzkuOCAxMy4xLTMuMSAyNi45LTUuOCA0MS4yLTcuOXptLTkwLjUgMTI1LjJjLTM1LjQtMTUuMS01OC4zLTM0LjktNTguMy01MC42IDAtMTUuNyAyMi45LTM1LjYgNTguMy01MC42IDguNi0zLjcgMTgtNyAyNy43LTEwLjEgNS43IDE5LjYgMTMuMiA0MCAyMi41IDYwLjktOS4yIDIwLjgtMTYuNiA0MS4xLTIyLjIgNjAuNi05LjktMy4xLTE5LjMtNi41LTI4LTEwLjJ6TTMxMCA0OTBjLTEzLjYtNy44LTE5LjUtMzcuNS0xNC45LTc1LjcgMS4xLTkuNCAyLjktMTkuMyA1LjEtMjkuNCAxOS42IDQuOCA0MSA4LjUgNjMuNSAxMC45IDEzLjUgMTguNSAyNy41IDM1LjMgNDEuNiA1MC0zMi42IDMwLjMtNjMuMiA0Ni45LTg0IDQ2LjktNC41LS4xLTguMy0xLTExLjMtMi43em0yMzcuMi03Ni4yYzQuNyAzOC4yLTEuMSA2Ny45LTE0LjYgNzUuOC0zIDEuOC02LjkgMi42LTExLjUgMi42LTIwLjcgMC01MS40LTE2LjUtODQtNDYuNiAxNC0xNC43IDI4LTMxLjQgNDEuMy00OS45IDIyLjYtMi40IDQ0LTYuMSA2My42LTExIDIuMyAxMC4xIDQuMSAxOS44IDUuMiAyOS4xem0zOC41LTY2LjdjLTguNiAzLjctMTggNy0yNy43IDEwLjEtNS43LTE5LjYtMTMuMi00MC0yMi41LTYwLjkgOS4yLTIwLjggMTYuNi00MS4xIDIyLjItNjAuNiA5LjkgMy4xIDE5LjMgNi41IDI4LjEgMTAuMiAzNS40IDE1LjEgNTguMyAzNC45IDU4LjMgNTAuNi0uMSAxNS43LTIzIDM1LjYtNTguNCA1MC42ek0zMjAuOCA3OC40eiIvPgogICAgPGNpcmNsZSBjeD0iNDIwLjkiIGN5PSIyOTYuNSIgcj0iNDUuNyIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-redo: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjE2Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE4LjQgMTAuNkMxNi41NSA4Ljk5IDE0LjE1IDggMTEuNSA4Yy00LjY1IDAtOC41OCAzLjAzLTkuOTYgNy4yMkwzLjkgMTZjMS4wNS0zLjE5IDQuMDUtNS41IDcuNi01LjUgMS45NSAwIDMuNzMuNzIgNS4xMiAxLjg4TDEzIDE2aDlWN2wtMy42IDMuNnoiLz4KICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-refresh: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTkgMTMuNWMtMi40OSAwLTQuNS0yLjAxLTQuNS00LjVTNi41MSA0LjUgOSA0LjVjMS4yNCAwIDIuMzYuNTIgMy4xNyAxLjMzTDEwIDhoNVYzbC0xLjc2IDEuNzZDMTIuMTUgMy42OCAxMC42NiAzIDkgMyA1LjY5IDMgMy4wMSA1LjY5IDMuMDEgOVM1LjY5IDE1IDkgMTVjMi45NyAwIDUuNDMtMi4xNiA1LjktNWgtMS41MmMtLjQ2IDItMi4yNCAzLjUtNC4zOCAzLjV6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);
  --jp-icon-regex: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiBmaWxsPSIjRkZGIj4KICAgIDxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjUuNSIgY3k9IjE0LjUiIHI9IjEuNSIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjQiIGNsYXNzPSJzdDIiIHdpZHRoPSIxIiBoZWlnaHQ9IjgiLz4KICAgIDxyZWN0IHg9IjguNSIgeT0iNy41IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg2NiAtMC41IDAuNSAwLjg2NiAtMi4zMjU1IDcuMzIxOSkiIGNsYXNzPSJzdDIiIHdpZHRoPSI4IiBoZWlnaHQ9IjEiLz4KICAgIDxyZWN0IHg9IjEyIiB5PSI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjUgLTAuODY2IDAuODY2IDAuNSAtMC42Nzc5IDE0LjgyNTIpIiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-run: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTggNXYxNGwxMS03eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-running: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptOTYgMzI4YzAgOC44LTcuMiAxNi0xNiAxNkgxNzZjLTguOCAwLTE2LTcuMi0xNi0xNlYxNzZjMC04LjggNy4yLTE2IDE2LTE2aDE2MGM4LjggMCAxNiA3LjIgMTYgMTZ2MTYweiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-save: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE3IDNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjdsLTQtNHptLTUgMTZjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzem0zLTEwSDVWNWgxMHY0eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-search: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-settings: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVBLjQ4OC40ODggMCAwMDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==);
  --jp-icon-share: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTSAxOCAyIEMgMTYuMzU0OTkgMiAxNSAzLjM1NDk5MDQgMTUgNSBDIDE1IDUuMTkwOTUyOSAxNS4wMjE3OTEgNS4zNzcxMjI0IDE1LjA1NjY0MSA1LjU1ODU5MzggTCA3LjkyMTg3NSA5LjcyMDcwMzEgQyA3LjM5ODUzOTkgOS4yNzc4NTM5IDYuNzMyMDc3MSA5IDYgOSBDIDQuMzU0OTkwNCA5IDMgMTAuMzU0OTkgMyAxMiBDIDMgMTMuNjQ1MDEgNC4zNTQ5OTA0IDE1IDYgMTUgQyA2LjczMjA3NzEgMTUgNy4zOTg1Mzk5IDE0LjcyMjE0NiA3LjkyMTg3NSAxNC4yNzkyOTcgTCAxNS4wNTY2NDEgMTguNDM5NDUzIEMgMTUuMDIxNTU1IDE4LjYyMTUxNCAxNSAxOC44MDgzODYgMTUgMTkgQyAxNSAyMC42NDUwMSAxNi4zNTQ5OSAyMiAxOCAyMiBDIDE5LjY0NTAxIDIyIDIxIDIwLjY0NTAxIDIxIDE5IEMgMjEgMTcuMzU0OTkgMTkuNjQ1MDEgMTYgMTggMTYgQyAxNy4yNjc0OCAxNiAxNi42MDE1OTMgMTYuMjc5MzI4IDE2LjA3ODEyNSAxNi43MjI2NTYgTCA4Ljk0MzM1OTQgMTIuNTU4NTk0IEMgOC45NzgyMDk1IDEyLjM3NzEyMiA5IDEyLjE5MDk1MyA5IDEyIEMgOSAxMS44MDkwNDcgOC45NzgyMDk1IDExLjYyMjg3OCA4Ljk0MzM1OTQgMTEuNDQxNDA2IEwgMTYuMDc4MTI1IDcuMjc5Mjk2OSBDIDE2LjYwMTQ2IDcuNzIyMTQ2MSAxNy4yNjc5MjMgOCAxOCA4IEMgMTkuNjQ1MDEgOCAyMSA2LjY0NTAwOTYgMjEgNSBDIDIxIDMuMzU0OTkwNCAxOS42NDUwMSAyIDE4IDIgeiBNIDE4IDQgQyAxOC41NjQxMjkgNCAxOSA0LjQzNTg3MDYgMTkgNSBDIDE5IDUuNTY0MTI5NCAxOC41NjQxMjkgNiAxOCA2IEMgMTcuNDM1ODcxIDYgMTcgNS41NjQxMjk0IDE3IDUgQyAxNyA0LjQzNTg3MDYgMTcuNDM1ODcxIDQgMTggNCB6IE0gNiAxMSBDIDYuNTY0MTI5NCAxMSA3IDExLjQzNTg3MSA3IDEyIEMgNyAxMi41NjQxMjkgNi41NjQxMjk0IDEzIDYgMTMgQyA1LjQzNTg3MDYgMTMgNSAxMi41NjQxMjkgNSAxMiBDIDUgMTEuNDM1ODcxIDUuNDM1ODcwNiAxMSA2IDExIHogTSAxOCAxOCBDIDE4LjU2NDEyOSAxOCAxOSAxOC40MzU4NzEgMTkgMTkgQyAxOSAxOS41NjQxMjkgMTguNTY0MTI5IDIwIDE4IDIwIEMgMTcuNDM1ODcxIDIwIDE3IDE5LjU2NDEyOSAxNyAxOSBDIDE3IDE4LjQzNTg3MSAxNy40MzU4NzEgMTggMTggMTggeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-spreadsheet: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNENBRjUwIiBkPSJNMi4yIDIuMnYxNy42aDE3LjZWMi4ySDIuMnptMTUuNCA3LjdoLTUuNVY0LjRoNS41djUuNXpNOS45IDQuNHY1LjVINC40VjQuNGg1LjV6bS01LjUgNy43aDUuNXY1LjVINC40di01LjV6bTcuNyA1LjV2LTUuNWg1LjV2NS41aC01LjV6Ii8+Cjwvc3ZnPgo=);
  --jp-icon-stop: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tab: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6Ii8+CiAgPC9nPgo8L3N2Zz4K);
  --jp-icon-table-rows: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMSw4SDNWNGgxOFY4eiBNMjEsMTBIM3Y0aDE4VjEweiBNMjEsMTZIM3Y0aDE4VjE2eiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-tag: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCA0MyAyOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CgkJPHBhdGggZD0iTTI4LjgzMzIgMTIuMzM0TDMyLjk5OTggMTYuNTAwN0wzNy4xNjY1IDEyLjMzNEgyOC44MzMyWiIvPgoJCTxwYXRoIGQ9Ik0xNi4yMDk1IDIxLjYxMDRDMTUuNjg3MyAyMi4xMjk5IDE0Ljg0NDMgMjIuMTI5OSAxNC4zMjQ4IDIxLjYxMDRMNi45ODI5IDE0LjcyNDVDNi41NzI0IDE0LjMzOTQgNi4wODMxMyAxMy42MDk4IDYuMDQ3ODYgMTMuMDQ4MkM1Ljk1MzQ3IDExLjUyODggNi4wMjAwMiA4LjYxOTQ0IDYuMDY2MjEgNy4wNzY5NUM2LjA4MjgxIDYuNTE0NzcgNi41NTU0OCA2LjA0MzQ3IDcuMTE4MDQgNi4wMzA1NUM5LjA4ODYzIDUuOTg0NzMgMTMuMjYzOCA1LjkzNTc5IDEzLjY1MTggNi4zMjQyNUwyMS43MzY5IDEzLjYzOUMyMi4yNTYgMTQuMTU4NSAyMS43ODUxIDE1LjQ3MjQgMjEuMjYyIDE1Ljk5NDZMMTYuMjA5NSAyMS42MTA0Wk05Ljc3NTg1IDguMjY1QzkuMzM1NTEgNy44MjU2NiA4LjYyMzUxIDcuODI1NjYgOC4xODI4IDguMjY1QzcuNzQzNDYgOC43MDU3MSA3Ljc0MzQ2IDkuNDE3MzMgOC4xODI4IDkuODU2NjdDOC42MjM4MiAxMC4yOTY0IDkuMzM1ODIgMTAuMjk2NCA5Ljc3NTg1IDkuODU2NjdDMTAuMjE1NiA5LjQxNzMzIDEwLjIxNTYgOC43MDUzMyA5Ljc3NTg1IDguMjY1WiIvPgoJPC9nPgo8L3N2Zz4K);
  --jp-icon-terminal: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiA+CiAgICA8cmVjdCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1iYWNrZ3JvdW5kLWNvbG9yIGpwLWljb24tc2VsZWN0YWJsZSIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyIDIpIiBmaWxsPSIjMzMzMzMzIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtdGVybWluYWwtaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUtaW52ZXJzZSIgZD0iTTUuMDU2NjQgOC43NjE3MkM1LjA1NjY0IDguNTk3NjYgNS4wMzEyNSA4LjQ1MzEyIDQuOTgwNDcgOC4zMjgxMkM0LjkzMzU5IDguMTk5MjIgNC44NTU0NyA4LjA4MjAzIDQuNzQ2MDkgNy45NzY1NkM0LjY0MDYyIDcuODcxMDkgNC41IDcuNzc1MzkgNC4zMjQyMiA3LjY4OTQ1QzQuMTUyMzQgNy41OTk2MSAzLjk0MzM2IDcuNTExNzIgMy42OTcyNyA3LjQyNTc4QzMuMzAyNzMgNy4yODUxNiAyLjk0MzM2IDcuMTM2NzIgMi42MTkxNCA2Ljk4MDQ3QzIuMjk0OTIgNi44MjQyMiAyLjAxNzU4IDYuNjQyNTggMS43ODcxMSA2LjQzNTU1QzEuNTYwNTUgNi4yMjg1MiAxLjM4NDc3IDUuOTg4MjggMS4yNTk3NyA1LjcxNDg0QzEuMTM0NzcgNS40Mzc1IDEuMDcyMjcgNS4xMDkzOCAxLjA3MjI3IDQuNzMwNDdDMS4wNzIyNyA0LjM5ODQ0IDEuMTI4OTEgNC4wOTU3IDEuMjQyMTkgMy44MjIyN0MxLjM1NTQ3IDMuNTQ0OTIgMS41MTU2MiAzLjMwNDY5IDEuNzIyNjYgMy4xMDE1NkMxLjkyOTY5IDIuODk4NDQgMi4xNzk2OSAyLjczNDM3IDIuNDcyNjYgMi42MDkzOEMyLjc2NTYyIDIuNDg0MzggMy4wOTE4IDIuNDA0MyAzLjQ1MTE3IDIuMzY5MTRWMS4xMDkzOEg0LjM4ODY3VjIuMzgwODZDNC43NDAyMyAyLjQyNzczIDUuMDU2NjQgMi41MjM0NCA1LjMzNzg5IDIuNjY3OTdDNS42MTkxNCAyLjgxMjUgNS44NTc0MiAzLjAwMTk1IDYuMDUyNzMgMy4yMzYzM0M2LjI1MTk1IDMuNDY2OCA2LjQwNDMgMy43NDAyMyA2LjUwOTc3IDQuMDU2NjRDNi42MTkxNCA0LjM2OTE0IDYuNjczODMgNC43MjA3IDYuNjczODMgNS4xMTEzM0g1LjA0NDkyQzUuMDQ0OTIgNC42Mzg2NyA0LjkzNzUgNC4yODEyNSA0LjcyMjY2IDQuMDM5MDZDNC41MDc4MSAzLjc5Mjk3IDQuMjE2OCAzLjY2OTkyIDMuODQ5NjEgMy42Njk5MkMzLjY1MDM5IDMuNjY5OTIgMy40NzY1NiAzLjY5NzI3IDMuMzI4MTIgMy43NTE5NUMzLjE4MzU5IDMuODAyNzMgMy4wNjQ0NSAzLjg3Njk1IDIuOTcwNyAzLjk3NDYxQzIuODc2OTUgNC4wNjgzNiAyLjgwNjY0IDQuMTc5NjkgMi43NTk3NyA0LjMwODU5QzIuNzE2OCA0LjQzNzUgMi42OTUzMSA0LjU3ODEyIDIuNjk1MzEgNC43MzA0N0MyLjY5NTMxIDQuODgyODEgMi43MTY4IDUuMDE5NTMgMi43NTk3NyA1LjE0MDYyQzIuODA2NjQgNS4yNTc4MSAyLjg4MjgxIDUuMzY3MTkgMi45ODgyOCA1LjQ2ODc1QzMuMDk3NjYgNS41NzAzMSAzLjI0MDIzIDUuNjY3OTcgMy40MTYwMiA1Ljc2MTcyQzMuNTkxOCA1Ljg1MTU2IDMuODEwNTUgNS45NDMzNiA0LjA3MjI3IDYuMDM3MTFDNC40NjY4IDYuMTg1NTUgNC44MjQyMiA2LjMzOTg0IDUuMTQ0NTMgNi41QzUuNDY0ODQgNi42NTYyNSA1LjczODI4IDYuODM5ODQgNS45NjQ4NCA3LjA1MDc4QzYuMTk1MzEgNy4yNTc4MSA2LjM3MTA5IDcuNSA2LjQ5MjE5IDcuNzc3MzRDNi42MTcxOSA4LjA1MDc4IDYuNjc5NjkgOC4zNzUgNi42Nzk2OSA4Ljc1QzYuNjc5NjkgOS4wOTM3NSA2LjYyMzA1IDkuNDA0MyA2LjUwOTc3IDkuNjgxNjRDNi4zOTY0OCA5Ljk1NTA4IDYuMjM0MzggMTAuMTkxNCA2LjAyMzQ0IDEwLjM5MDZDNS44MTI1IDEwLjU4OTggNS41NTg1OSAxMC43NSA1LjI2MTcyIDEwLjg3MTFDNC45NjQ4NCAxMC45ODgzIDQuNjMyODEgMTEuMDY0NSA0LjI2NTYyIDExLjA5OTZWMTIuMjQ4SDMuMzMzOThWMTEuMDk5NkMzLjAwMTk1IDExLjA2ODQgMi42Nzk2OSAxMC45OTYxIDIuMzY3MTkgMTAuODgyOEMyLjA1NDY5IDEwLjc2NTYgMS43NzczNCAxMC41OTc3IDEuNTM1MTYgMTAuMzc4OUMxLjI5Njg4IDEwLjE2MDIgMS4xMDU0NyA5Ljg4NDc3IDAuOTYwOTM4IDkuNTUyNzNDMC44MTY0MDYgOS4yMTY4IDAuNzQ0MTQxIDguODE0NDUgMC43NDQxNDEgOC4zNDU3SDIuMzc4OTFDMi4zNzg5MSA4LjYyNjk1IDIuNDE5OTIgOC44NjMyOCAyLjUwMTk1IDkuMDU0NjlDMi41ODM5OCA5LjI0MjE5IDIuNjg5NDUgOS4zOTI1OCAyLjgxODM2IDkuNTA1ODZDMi45NTExNyA5LjYxNTIzIDMuMTAxNTYgOS42OTMzNiAzLjI2OTUzIDkuNzQwMjNDMy40Mzc1IDkuNzg3MTEgMy42MDkzOCA5LjgxMDU1IDMuNzg1MTYgOS44MTA1NUM0LjIwMzEyIDkuODEwNTUgNC41MTk1MyA5LjcxMjg5IDQuNzM0MzggOS41MTc1OEM0Ljk0OTIyIDkuMzIyMjcgNS4wNTY2NCA5LjA3MDMxIDUuMDU2NjQgOC43NjE3MlpNMTMuNDE4IDEyLjI3MTVIOC4wNzQyMlYxMUgxMy40MThWMTIuMjcxNVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuOTUyNjQgNikiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=);
  --jp-icon-text-editor: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtdGV4dC1lZGl0b3ItaWNvbi1jb2xvciBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xNSAxNUgzdjJoMTJ2LTJ6bTAtOEgzdjJoMTJWN3pNMyAxM2gxOHYtMkgzdjJ6bTAgOGgxOHYtMkgzdjJ6TTMgM3YyaDE4VjNIM3oiLz4KPC9zdmc+Cg==);
  --jp-icon-toc: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxwYXRoIGQ9Ik03LDVIMjFWN0g3VjVNNywxM1YxMUgyMVYxM0g3TTQsNC41QTEuNSwxLjUgMCAwLDEgNS41LDZBMS41LDEuNSAwIDAsMSA0LDcuNUExLjUsMS41IDAgMCwxIDIuNSw2QTEuNSwxLjUgMCAwLDEgNCw0LjVNNCwxMC41QTEuNSwxLjUgMCAwLDEgNS41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMy41QTEuNSwxLjUgMCAwLDEgMi41LDEyQTEuNSwxLjUgMCAwLDEgNCwxMC41TTcsMTlWMTdIMjFWMTlIN000LDE2LjVBMS41LDEuNSAwIDAsMSA1LjUsMThBMS41LDEuNSAwIDAsMSA0LDE5LjVBMS41LDEuNSAwIDAsMSAyLjUsMThBMS41LDEuNSAwIDAsMSA0LDE2LjVaIiAvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-tree-view: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik0yMiAxMVYzaC03djNIOVYzSDJ2OGg3VjhoMnYxMGg0djNoN3YtOGgtN3YzaC0yVjhoMnYzeiIvPgogICAgPC9nPgo8L3N2Zz4K);
  --jp-icon-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMiAxNy4xODQ0IDIuOTY5NjggMTQuMzAzMiAxLjg2MDk0IDExLjQ0MDlaIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiMzMzMzMzMiIHN0cm9rZT0iIzMzMzMzMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOCA5Ljg2NzE5KSIgZD0iTTIuODYwMTUgNC44NjUzNUwwLjcyNjU0OSAyLjk5OTU5TDAgMy42MzA0NUwyLjg2MDE1IDYuMTMxNTdMOCAwLjYzMDg3Mkw3LjI3ODU3IDBMMi44NjAxNSA0Ljg2NTM1WiIvPgo8L3N2Zz4K);
  --jp-icon-undo: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-user: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE2IDdhNCA0IDAgMTEtOCAwIDQgNCAwIDAxOCAwek0xMiAxNGE3IDcgMCAwMC03IDdoMTRhNyA3IDAgMDAtNy03eiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-users: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDM2IDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogPGcgY2xhc3M9ImpwLWljb24zIiB0cmFuc2Zvcm09Im1hdHJpeCgxLjczMjcgMCAwIDEuNzMyNyAtMy42MjgyIC4wOTk1NzcpIiBmaWxsPSIjNjE2MTYxIj4KICA8cGF0aCB0cmFuc2Zvcm09Im1hdHJpeCgxLjUsMCwwLDEuNSwwLC02KSIgZD0ibTEyLjE4NiA3LjUwOThjLTEuMDUzNSAwLTEuOTc1NyAwLjU2NjUtMi40Nzg1IDEuNDEwMiAwLjc1MDYxIDAuMzEyNzcgMS4zOTc0IDAuODI2NDggMS44NzMgMS40NzI3aDMuNDg2M2MwLTEuNTkyLTEuMjg4OS0yLjg4MjgtMi44ODA5LTIuODgyOHoiLz4KICA8cGF0aCBkPSJtMjAuNDY1IDIuMzg5NWEyLjE4ODUgMi4xODg1IDAgMCAxLTIuMTg4NCAyLjE4ODUgMi4xODg1IDIuMTg4NSAwIDAgMS0yLjE4ODUtMi4xODg1IDIuMTg4NSAyLjE4ODUgMCAwIDEgMi4xODg1LTIuMTg4NSAyLjE4ODUgMi4xODg1IDAgMCAxIDIuMTg4NCAyLjE4ODV6Ii8+CiAgPHBhdGggdHJhbnNmb3JtPSJtYXRyaXgoMS41LDAsMCwxLjUsMCwtNikiIGQ9Im0zLjU4OTggOC40MjE5Yy0xLjExMjYgMC0yLjAxMzcgMC45MDExMS0yLjAxMzcgMi4wMTM3aDIuODE0NWMwLjI2Nzk3LTAuMzczMDkgMC41OTA3LTAuNzA0MzUgMC45NTg5OC0wLjk3ODUyLTAuMzQ0MzMtMC42MTY4OC0xLjAwMzEtMS4wMzUyLTEuNzU5OC0xLjAzNTJ6Ii8+CiAgPHBhdGggZD0ibTYuOTE1NCA0LjYyM2ExLjUyOTQgMS41Mjk0IDAgMCAxLTEuNTI5NCAxLjUyOTQgMS41Mjk0IDEuNTI5NCAwIDAgMS0xLjUyOTQtMS41Mjk0IDEuNTI5NCAxLjUyOTQgMCAwIDEgMS41Mjk0LTEuNTI5NCAxLjUyOTQgMS41Mjk0IDAgMCAxIDEuNTI5NCAxLjUyOTR6Ii8+CiAgPHBhdGggZD0ibTYuMTM1IDEzLjUzNWMwLTMuMjM5MiAyLjYyNTktNS44NjUgNS44NjUtNS44NjUgMy4yMzkyIDAgNS44NjUgMi42MjU5IDUuODY1IDUuODY1eiIvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iMy43Njg1IiByPSIyLjk2ODUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-vega: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbjEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjEyMTIxIj4KICAgIDxwYXRoIGQ9Ik0xMC42IDUuNGwyLjItMy4ySDIuMnY3LjNsNC02LjZ6Ii8+CiAgICA8cGF0aCBkPSJNMTUuOCAyLjJsLTQuNCA2LjZMNyA2LjNsLTQuOCA4djUuNWgxNy42VjIuMmgtNHptLTcgMTUuNEg1LjV2LTQuNGgzLjN2NC40em00LjQgMEg5LjhWOS44aDMuNHY3Ljh6bTQuNCAwaC0zLjRWNi41aDMuNHYxMS4xeiIvPgogIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-word: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KIDxnIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzQxNDE0MSI+CiAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiA8L2c+CiA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSguNDMgLjA0MDEpIiBmaWxsPSIjZmZmIj4KICA8cGF0aCBkPSJtNC4xNCA4Ljc2cTAuMDY4Mi0xLjg5IDIuNDItMS44OSAxLjE2IDAgMS42OCAwLjQyIDAuNTY3IDAuNDEgMC41NjcgMS4xNnYzLjQ3cTAgMC40NjIgMC41MTQgMC40NjIgMC4xMDMgMCAwLjItMC4wMjMxdjAuNzE0cS0wLjM5OSAwLjEwMy0wLjY1MSAwLjEwMy0wLjQ1MiAwLTAuNjkzLTAuMjItMC4yMzEtMC4yLTAuMjg0LTAuNjYyLTAuOTU2IDAuODcyLTIgMC44NzItMC45MDMgMC0xLjQ3LTAuNDcyLTAuNTI1LTAuNDcyLTAuNTI1LTEuMjYgMC0wLjI2MiAwLjA0NTItMC40NzIgMC4wNTY3LTAuMjIgMC4xMTYtMC4zNzggMC4wNjgyLTAuMTY4IDAuMjMxLTAuMzA0IDAuMTU4LTAuMTQ3IDAuMjYyLTAuMjQyIDAuMTE2LTAuMDkxNCAwLjM2OC0wLjE2OCAwLjI2Mi0wLjA5MTQgMC4zOTktMC4xMjYgMC4xMzYtMC4wNDUyIDAuNDcyLTAuMTAzIDAuMzM2LTAuMDU3OCAwLjUwNC0wLjA3OTggMC4xNTgtMC4wMjMxIDAuNTY3LTAuMDc5OCAwLjU1Ni0wLjA2ODIgMC43NzctMC4yMjEgMC4yMi0wLjE1MiAwLjIyLTAuNDQxdi0wLjI1MnEwLTAuNDMtMC4zNTctMC42NjItMC4zMzYtMC4yMzEtMC45NzYtMC4yMzEtMC42NjIgMC0wLjk5OCAwLjI2Mi0wLjMzNiAwLjI1Mi0wLjM5OSAwLjc5OHptMS44OSAzLjY4cTAuNzg4IDAgMS4yNi0wLjQxIDAuNTA0LTAuNDIgMC41MDQtMC45MDN2LTEuMDVxLTAuMjg0IDAuMTM2LTAuODYxIDAuMjMxLTAuNTY3IDAuMDkxNC0wLjk4NyAwLjE1OC0wLjQyIDAuMDY4Mi0wLjc2NiAwLjMyNi0wLjMzNiAwLjI1Mi0wLjMzNiAwLjcwNHQwLjMwNCAwLjcwNCAwLjg2MSAwLjI1MnoiIHN0cm9rZS13aWR0aD0iMS4wNSIvPgogIDxwYXRoIGQ9Im0xMCA0LjU2aDAuOTQ1djMuMTVxMC42NTEtMC45NzYgMS44OS0wLjk3NiAxLjE2IDAgMS44OSAwLjg0IDAuNjgyIDAuODQgMC42ODIgMi4zMSAwIDEuNDctMC43MDQgMi40Mi0wLjcwNCAwLjg4Mi0xLjg5IDAuODgyLTEuMjYgMC0xLjg5LTEuMDJ2MC43NjZoLTAuODV6bTIuNjIgMy4wNHEtMC43NDYgMC0xLjE2IDAuNjQtMC40NTIgMC42My0wLjQ1MiAxLjY4IDAgMS4wNSAwLjQ1MiAxLjY4dDEuMTYgMC42M3EwLjc3NyAwIDEuMjYtMC42MyAwLjQ5NC0wLjY0IDAuNDk0LTEuNjggMC0xLjA1LTAuNDcyLTEuNjgtMC40NjItMC42NC0xLjI2LTAuNjR6IiBzdHJva2Utd2lkdGg9IjEuMDUiLz4KICA8cGF0aCBkPSJtMi43MyAxNS44IDEzLjYgMC4wMDgxYzAuMDA2OSAwIDAtMi42IDAtMi42IDAtMC4wMDc4LTEuMTUgMC0xLjE1IDAtMC4wMDY5IDAtMC4wMDgzIDEuNS0wLjAwODMgMS41LTJlLTMgLTAuMDAxNC0xMS4zLTAuMDAxNC0xMS4zLTAuMDAxNGwtMC4wMDU5Mi0xLjVjMC0wLjAwNzgtMS4xNyAwLjAwMTMtMS4xNyAwLjAwMTN6IiBzdHJva2Utd2lkdGg9Ii45NzUiLz4KIDwvZz4KPC9zdmc+Cg==);
  --jp-icon-yaml: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1jb250cmFzdDIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjRDgxQjYwIj4KICAgIDxwYXRoIGQ9Ik03LjIgMTguNnYtNS40TDMgNS42aDMuM2wxLjQgMy4xYy4zLjkuNiAxLjYgMSAyLjUuMy0uOC42LTEuNiAxLTIuNWwxLjQtMy4xaDMuNGwtNC40IDcuNnY1LjVsLTIuOS0uMXoiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxNi41IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxMSIgcj0iMi4xIi8+CiAgPC9nPgo8L3N2Zz4K);
}

/* Icon CSS class declarations */

.jp-AddAboveIcon {
  background-image: var(--jp-icon-add-above);
}

.jp-AddBelowIcon {
  background-image: var(--jp-icon-add-below);
}

.jp-AddIcon {
  background-image: var(--jp-icon-add);
}

.jp-BellIcon {
  background-image: var(--jp-icon-bell);
}

.jp-BugDotIcon {
  background-image: var(--jp-icon-bug-dot);
}

.jp-BugIcon {
  background-image: var(--jp-icon-bug);
}

.jp-BuildIcon {
  background-image: var(--jp-icon-build);
}

.jp-CaretDownEmptyIcon {
  background-image: var(--jp-icon-caret-down-empty);
}

.jp-CaretDownEmptyThinIcon {
  background-image: var(--jp-icon-caret-down-empty-thin);
}

.jp-CaretDownIcon {
  background-image: var(--jp-icon-caret-down);
}

.jp-CaretLeftIcon {
  background-image: var(--jp-icon-caret-left);
}

.jp-CaretRightIcon {
  background-image: var(--jp-icon-caret-right);
}

.jp-CaretUpEmptyThinIcon {
  background-image: var(--jp-icon-caret-up-empty-thin);
}

.jp-CaretUpIcon {
  background-image: var(--jp-icon-caret-up);
}

.jp-CaseSensitiveIcon {
  background-image: var(--jp-icon-case-sensitive);
}

.jp-CheckIcon {
  background-image: var(--jp-icon-check);
}

.jp-CircleEmptyIcon {
  background-image: var(--jp-icon-circle-empty);
}

.jp-CircleIcon {
  background-image: var(--jp-icon-circle);
}

.jp-ClearIcon {
  background-image: var(--jp-icon-clear);
}

.jp-CloseIcon {
  background-image: var(--jp-icon-close);
}

.jp-CodeCheckIcon {
  background-image: var(--jp-icon-code-check);
}

.jp-CodeIcon {
  background-image: var(--jp-icon-code);
}

.jp-CollapseAllIcon {
  background-image: var(--jp-icon-collapse-all);
}

.jp-ConsoleIcon {
  background-image: var(--jp-icon-console);
}

.jp-CopyIcon {
  background-image: var(--jp-icon-copy);
}

.jp-CopyrightIcon {
  background-image: var(--jp-icon-copyright);
}

.jp-CutIcon {
  background-image: var(--jp-icon-cut);
}

.jp-DeleteIcon {
  background-image: var(--jp-icon-delete);
}

.jp-DownloadIcon {
  background-image: var(--jp-icon-download);
}

.jp-DuplicateIcon {
  background-image: var(--jp-icon-duplicate);
}

.jp-EditIcon {
  background-image: var(--jp-icon-edit);
}

.jp-EllipsesIcon {
  background-image: var(--jp-icon-ellipses);
}

.jp-ErrorIcon {
  background-image: var(--jp-icon-error);
}

.jp-ExpandAllIcon {
  background-image: var(--jp-icon-expand-all);
}

.jp-ExtensionIcon {
  background-image: var(--jp-icon-extension);
}

.jp-FastForwardIcon {
  background-image: var(--jp-icon-fast-forward);
}

.jp-FileIcon {
  background-image: var(--jp-icon-file);
}

.jp-FileUploadIcon {
  background-image: var(--jp-icon-file-upload);
}

.jp-FilterDotIcon {
  background-image: var(--jp-icon-filter-dot);
}

.jp-FilterIcon {
  background-image: var(--jp-icon-filter);
}

.jp-FilterListIcon {
  background-image: var(--jp-icon-filter-list);
}

.jp-FolderFavoriteIcon {
  background-image: var(--jp-icon-folder-favorite);
}

.jp-FolderIcon {
  background-image: var(--jp-icon-folder);
}

.jp-HomeIcon {
  background-image: var(--jp-icon-home);
}

.jp-Html5Icon {
  background-image: var(--jp-icon-html5);
}

.jp-ImageIcon {
  background-image: var(--jp-icon-image);
}

.jp-InfoIcon {
  background-image: var(--jp-icon-info);
}

.jp-InspectorIcon {
  background-image: var(--jp-icon-inspector);
}

.jp-JsonIcon {
  background-image: var(--jp-icon-json);
}

.jp-JuliaIcon {
  background-image: var(--jp-icon-julia);
}

.jp-JupyterFaviconIcon {
  background-image: var(--jp-icon-jupyter-favicon);
}

.jp-JupyterIcon {
  background-image: var(--jp-icon-jupyter);
}

.jp-JupyterlabWordmarkIcon {
  background-image: var(--jp-icon-jupyterlab-wordmark);
}

.jp-KernelIcon {
  background-image: var(--jp-icon-kernel);
}

.jp-KeyboardIcon {
  background-image: var(--jp-icon-keyboard);
}

.jp-LaunchIcon {
  background-image: var(--jp-icon-launch);
}

.jp-LauncherIcon {
  background-image: var(--jp-icon-launcher);
}

.jp-LineFormIcon {
  background-image: var(--jp-icon-line-form);
}

.jp-LinkIcon {
  background-image: var(--jp-icon-link);
}

.jp-ListIcon {
  background-image: var(--jp-icon-list);
}

.jp-MarkdownIcon {
  background-image: var(--jp-icon-markdown);
}

.jp-MoveDownIcon {
  background-image: var(--jp-icon-move-down);
}

.jp-MoveUpIcon {
  background-image: var(--jp-icon-move-up);
}

.jp-NewFolderIcon {
  background-image: var(--jp-icon-new-folder);
}

.jp-NotTrustedIcon {
  background-image: var(--jp-icon-not-trusted);
}

.jp-NotebookIcon {
  background-image: var(--jp-icon-notebook);
}

.jp-NumberingIcon {
  background-image: var(--jp-icon-numbering);
}

.jp-OfflineBoltIcon {
  background-image: var(--jp-icon-offline-bolt);
}

.jp-PaletteIcon {
  background-image: var(--jp-icon-palette);
}

.jp-PasteIcon {
  background-image: var(--jp-icon-paste);
}

.jp-PdfIcon {
  background-image: var(--jp-icon-pdf);
}

.jp-PythonIcon {
  background-image: var(--jp-icon-python);
}

.jp-RKernelIcon {
  background-image: var(--jp-icon-r-kernel);
}

.jp-ReactIcon {
  background-image: var(--jp-icon-react);
}

.jp-RedoIcon {
  background-image: var(--jp-icon-redo);
}

.jp-RefreshIcon {
  background-image: var(--jp-icon-refresh);
}

.jp-RegexIcon {
  background-image: var(--jp-icon-regex);
}

.jp-RunIcon {
  background-image: var(--jp-icon-run);
}

.jp-RunningIcon {
  background-image: var(--jp-icon-running);
}

.jp-SaveIcon {
  background-image: var(--jp-icon-save);
}

.jp-SearchIcon {
  background-image: var(--jp-icon-search);
}

.jp-SettingsIcon {
  background-image: var(--jp-icon-settings);
}

.jp-ShareIcon {
  background-image: var(--jp-icon-share);
}

.jp-SpreadsheetIcon {
  background-image: var(--jp-icon-spreadsheet);
}

.jp-StopIcon {
  background-image: var(--jp-icon-stop);
}

.jp-TabIcon {
  background-image: var(--jp-icon-tab);
}

.jp-TableRowsIcon {
  background-image: var(--jp-icon-table-rows);
}

.jp-TagIcon {
  background-image: var(--jp-icon-tag);
}

.jp-TerminalIcon {
  background-image: var(--jp-icon-terminal);
}

.jp-TextEditorIcon {
  background-image: var(--jp-icon-text-editor);
}

.jp-TocIcon {
  background-image: var(--jp-icon-toc);
}

.jp-TreeViewIcon {
  background-image: var(--jp-icon-tree-view);
}

.jp-TrustedIcon {
  background-image: var(--jp-icon-trusted);
}

.jp-UndoIcon {
  background-image: var(--jp-icon-undo);
}

.jp-UserIcon {
  background-image: var(--jp-icon-user);
}

.jp-UsersIcon {
  background-image: var(--jp-icon-users);
}

.jp-VegaIcon {
  background-image: var(--jp-icon-vega);
}

.jp-WordIcon {
  background-image: var(--jp-icon-word);
}

.jp-YamlIcon {
  background-image: var(--jp-icon-yaml);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * (DEPRECATED) Support for consuming icons as CSS background images
 */

.jp-Icon,
.jp-MaterialIcon {
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-cover {
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
}

/**
 * (DEPRECATED) Support for specific CSS icon sizes
 */

.jp-Icon-16 {
  background-size: 16px;
  min-width: 16px;
  min-height: 16px;
}

.jp-Icon-18 {
  background-size: 18px;
  min-width: 18px;
  min-height: 18px;
}

.jp-Icon-20 {
  background-size: 20px;
  min-width: 20px;
  min-height: 20px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.lm-TabBar .lm-TabBar-addButton {
  align-items: center;
  display: flex;
  padding: 4px;
  padding-bottom: 5px;
  margin-right: 1px;
  background-color: var(--jp-layout-color2);
}

.lm-TabBar .lm-TabBar-addButton:hover {
  background-color: var(--jp-layout-color1);
}

.lm-DockPanel-tabBar .lm-TabBar-tab {
  width: var(--jp-private-horizontal-tab-width);
}

.lm-DockPanel-tabBar .lm-TabBar-content {
  flex: unset;
}

.lm-DockPanel-tabBar[data-orientation='horizontal'] {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for icons as inline SVG HTMLElements
 */

/* recolor the primary elements of an icon */
.jp-icon0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-accent0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-accent1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-accent2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-accent3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-accent4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-accent0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-accent1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-accent2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-accent3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-accent4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-none[fill] {
  fill: none;
}

.jp-icon-none[stroke] {
  stroke: none;
}

/* brand icon colors. Same for light and dark */
.jp-icon-brand0[fill] {
  fill: var(--jp-brand-color0);
}

.jp-icon-brand1[fill] {
  fill: var(--jp-brand-color1);
}

.jp-icon-brand2[fill] {
  fill: var(--jp-brand-color2);
}

.jp-icon-brand3[fill] {
  fill: var(--jp-brand-color3);
}

.jp-icon-brand4[fill] {
  fill: var(--jp-brand-color4);
}

.jp-icon-brand0[stroke] {
  stroke: var(--jp-brand-color0);
}

.jp-icon-brand1[stroke] {
  stroke: var(--jp-brand-color1);
}

.jp-icon-brand2[stroke] {
  stroke: var(--jp-brand-color2);
}

.jp-icon-brand3[stroke] {
  stroke: var(--jp-brand-color3);
}

.jp-icon-brand4[stroke] {
  stroke: var(--jp-brand-color4);
}

/* warn icon colors. Same for light and dark */
.jp-icon-warn0[fill] {
  fill: var(--jp-warn-color0);
}

.jp-icon-warn1[fill] {
  fill: var(--jp-warn-color1);
}

.jp-icon-warn2[fill] {
  fill: var(--jp-warn-color2);
}

.jp-icon-warn3[fill] {
  fill: var(--jp-warn-color3);
}

.jp-icon-warn0[stroke] {
  stroke: var(--jp-warn-color0);
}

.jp-icon-warn1[stroke] {
  stroke: var(--jp-warn-color1);
}

.jp-icon-warn2[stroke] {
  stroke: var(--jp-warn-color2);
}

.jp-icon-warn3[stroke] {
  stroke: var(--jp-warn-color3);
}

/* icon colors that contrast well with each other and most backgrounds */
.jp-icon-contrast0[fill] {
  fill: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[fill] {
  fill: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[fill] {
  fill: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[fill] {
  fill: var(--jp-icon-contrast-color3);
}

.jp-icon-contrast0[stroke] {
  stroke: var(--jp-icon-contrast-color0);
}

.jp-icon-contrast1[stroke] {
  stroke: var(--jp-icon-contrast-color1);
}

.jp-icon-contrast2[stroke] {
  stroke: var(--jp-icon-contrast-color2);
}

.jp-icon-contrast3[stroke] {
  stroke: var(--jp-icon-contrast-color3);
}

.jp-icon-dot[fill] {
  fill: var(--jp-warn-color0);
}

.jp-jupyter-icon-color[fill] {
  fill: var(--jp-jupyter-icon-color, var(--jp-warn-color0));
}

.jp-notebook-icon-color[fill] {
  fill: var(--jp-notebook-icon-color, var(--jp-warn-color0));
}

.jp-json-icon-color[fill] {
  fill: var(--jp-json-icon-color, var(--jp-warn-color1));
}

.jp-console-icon-color[fill] {
  fill: var(--jp-console-icon-color, white);
}

.jp-console-icon-background-color[fill] {
  fill: var(--jp-console-icon-background-color, var(--jp-brand-color1));
}

.jp-terminal-icon-color[fill] {
  fill: var(--jp-terminal-icon-color, var(--jp-layout-color2));
}

.jp-terminal-icon-background-color[fill] {
  fill: var(
    --jp-terminal-icon-background-color,
    var(--jp-inverse-layout-color2)
  );
}

.jp-text-editor-icon-color[fill] {
  fill: var(--jp-text-editor-icon-color, var(--jp-inverse-layout-color3));
}

.jp-inspector-icon-color[fill] {
  fill: var(--jp-inspector-icon-color, var(--jp-inverse-layout-color3));
}

/* CSS for icons in selected filebrowser listing items */
.jp-DirListing-item.jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

.jp-DirListing-item.jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* stylelint-disable selector-max-class, selector-max-compound-selectors */

/**
* TODO: come up with non css-hack solution for showing the busy icon on top
*  of the close icon
* CSS for complex behavior of close icon of tabs in the main area tabbar
*/
.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon3[fill] {
  fill: none;
}

.lm-DockPanel-tabBar
  .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty
  > .lm-TabBar-tabCloseIcon
  > :not(:hover)
  > .jp-icon-busy[fill] {
  fill: var(--jp-inverse-layout-color3);
}

/* stylelint-enable selector-max-class, selector-max-compound-selectors */

/* CSS for icons in status bar */
#jp-main-statusbar .jp-mod-selected .jp-icon-selectable[fill] {
  fill: #fff;
}

#jp-main-statusbar .jp-mod-selected .jp-icon-selectable-inverse[fill] {
  fill: var(--jp-brand-color1);
}

/* special handling for splash icon CSS. While the theme CSS reloads during
   splash, the splash icon can loose theming. To prevent that, we set a
   default for its color variable */
:root {
  --jp-warn-color0: var(--md-orange-700);
}

/* not sure what to do with this one, used in filebrowser listing */
.jp-DragIcon {
  margin-right: 4px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Support for alt colors for icons as inline SVG HTMLElements
 */

/* alt recolor the primary elements of an icon */
.jp-icon-alt .jp-icon0[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-alt .jp-icon0[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-alt .jp-icon1[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-alt .jp-icon2[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-alt .jp-icon3[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-alt .jp-icon4[stroke] {
  stroke: var(--jp-layout-color4);
}

/* alt recolor the accent elements of an icon */
.jp-icon-alt .jp-icon-accent0[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-alt .jp-icon-accent0[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-alt .jp-icon-accent1[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-alt .jp-icon-accent2[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-alt .jp-icon-accent3[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-alt .jp-icon-accent4[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-icon-hoverShow:not(:hover) .jp-icon-hoverShow-content {
  display: none !important;
}

/**
 * Support for hover colors for icons as inline SVG HTMLElements
 */

/**
 * regular colors
 */

/* recolor the primary elements of an icon */
.jp-icon-hover :hover .jp-icon0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/* recolor the accent elements of an icon */
.jp-icon-hover :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* set the color of an icon to transparent */
.jp-icon-hover :hover .jp-icon-none-hover[fill] {
  fill: none;
}

.jp-icon-hover :hover .jp-icon-none-hover[stroke] {
  stroke: none;
}

/**
 * inverse colors
 */

/* inverse recolor the primary elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[fill] {
  fill: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[fill] {
  fill: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[fill] {
  fill: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[fill] {
  fill: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[fill] {
  fill: var(--jp-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[stroke] {
  stroke: var(--jp-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[stroke] {
  stroke: var(--jp-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[stroke] {
  stroke: var(--jp-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[stroke] {
  stroke: var(--jp-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[stroke] {
  stroke: var(--jp-layout-color4);
}

/* inverse recolor the accent elements of an icon */
.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[fill] {
  fill: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[fill] {
  fill: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[fill] {
  fill: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[fill] {
  fill: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[fill] {
  fill: var(--jp-inverse-layout-color4);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[stroke] {
  stroke: var(--jp-inverse-layout-color0);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[stroke] {
  stroke: var(--jp-inverse-layout-color1);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[stroke] {
  stroke: var(--jp-inverse-layout-color2);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[stroke] {
  stroke: var(--jp-inverse-layout-color3);
}

.jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[stroke] {
  stroke: var(--jp-inverse-layout-color4);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-IFrame {
  width: 100%;
  height: 100%;
}

.jp-IFrame > iframe {
  border: none;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-IFrame {
  position: relative;
}

body.lm-mod-override-cursor .jp-IFrame::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-HoverBox {
  position: fixed;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FormGroup-content fieldset {
  border: none;
  padding: 0;
  min-width: 0;
  width: 100%;
}

/* stylelint-disable selector-max-type */

.jp-FormGroup-content fieldset .jp-inputFieldWrapper input,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper select,
.jp-FormGroup-content fieldset .jp-inputFieldWrapper textarea {
  font-size: var(--jp-content-font-size2);
  border-color: var(--jp-input-border-color);
  border-style: solid;
  border-radius: var(--jp-border-radius);
  border-width: 1px;
  padding: 6px 8px;
  background: none;
  color: var(--jp-ui-font-color0);
  height: inherit;
}

.jp-FormGroup-content fieldset input[type='checkbox'] {
  position: relative;
  top: 2px;
  margin-left: 0;
}

.jp-FormGroup-content button.jp-mod-styled {
  cursor: pointer;
}

.jp-FormGroup-content .checkbox label {
  cursor: pointer;
  font-size: var(--jp-content-font-size1);
}

.jp-FormGroup-content .jp-root > fieldset > legend {
  display: none;
}

.jp-FormGroup-content .jp-root > fieldset > p {
  display: none;
}

/** copy of `input.jp-mod-styled:focus` style */
.jp-FormGroup-content fieldset input:focus,
.jp-FormGroup-content fieldset select:focus {
  -moz-outline-radius: unset;
  outline: var(--jp-border-width) solid var(--md-blue-500);
  outline-offset: -1px;
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-FormGroup-content fieldset input:hover:not(:focus),
.jp-FormGroup-content fieldset select:hover:not(:focus) {
  background-color: var(--jp-border-color2);
}

/* stylelint-enable selector-max-type */

.jp-FormGroup-content .checkbox .field-description {
  /* Disable default description field for checkbox:
   because other widgets do not have description fields,
   we add descriptions to each widget on the field level.
  */
  display: none;
}

.jp-FormGroup-content #root__description {
  display: none;
}

.jp-FormGroup-content .jp-modifiedIndicator {
  width: 5px;
  background-color: var(--jp-brand-color2);
  margin-top: 0;
  margin-left: calc(var(--jp-private-settingeditor-modifier-indent) * -1);
  flex-shrink: 0;
}

.jp-FormGroup-content .jp-modifiedIndicator.jp-errorIndicator {
  background-color: var(--jp-error-color0);
  margin-right: 0.5em;
}

/* RJSF ARRAY style */

.jp-arrayFieldWrapper legend {
  font-size: var(--jp-content-font-size2);
  color: var(--jp-ui-font-color0);
  flex-basis: 100%;
  padding: 4px 0;
  font-weight: var(--jp-content-heading-font-weight);
  border-bottom: 1px solid var(--jp-border-color2);
}

.jp-arrayFieldWrapper .field-description {
  padding: 4px 0;
  white-space: pre-wrap;
}

.jp-arrayFieldWrapper .array-item {
  width: 100%;
  border: 1px solid var(--jp-border-color2);
  border-radius: 4px;
  margin: 4px;
}

.jp-ArrayOperations {
  display: flex;
  margin-left: 8px;
}

.jp-ArrayOperationsButton {
  margin: 2px;
}

.jp-ArrayOperationsButton .jp-icon3[fill] {
  fill: var(--jp-ui-font-color0);
}

button.jp-ArrayOperationsButton.jp-mod-styled:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

/* RJSF form validation error */

.jp-FormGroup-content .validationErrors {
  color: var(--jp-error-color0);
}

/* Hide panel level error as duplicated the field level error */
.jp-FormGroup-content .panel.errors {
  display: none;
}

/* RJSF normal content (settings-editor) */

.jp-FormGroup-contentNormal {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-FormGroup-contentItem {
  margin-left: 7px;
  color: var(--jp-ui-font-color0);
}

.jp-FormGroup-contentNormal .jp-FormGroup-description {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-default {
  flex-basis: 100%;
  padding: 4px 7px;
}

.jp-FormGroup-contentNormal .jp-FormGroup-fieldLabel {
  font-size: var(--jp-content-font-size1);
  font-weight: normal;
  min-width: 120px;
}

.jp-FormGroup-contentNormal fieldset:not(:first-child) {
  margin-left: 7px;
}

.jp-FormGroup-contentNormal .field-array-of-string .array-item {
  /* Display `jp-ArrayOperations` buttons side-by-side with content except
    for small screens where flex-wrap will place them one below the other.
  */
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.jp-FormGroup-contentNormal .jp-objectFieldWrapper .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

/* RJSF compact content (metadata-form) */

.jp-FormGroup-content.jp-FormGroup-contentCompact {
  width: 100%;
}

.jp-FormGroup-contentCompact .form-group {
  display: flex;
  padding: 0.5em 0.2em 0.5em 0;
}

.jp-FormGroup-contentCompact
  .jp-FormGroup-compactTitle
  .jp-FormGroup-description {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color2);
}

.jp-FormGroup-contentCompact .jp-FormGroup-fieldLabel {
  padding-bottom: 0.3em;
}

.jp-FormGroup-contentCompact .jp-inputFieldWrapper .form-control {
  width: 100%;
  box-sizing: border-box;
}

.jp-FormGroup-contentCompact .jp-arrayFieldWrapper .jp-FormGroup-compactTitle {
  padding-bottom: 7px;
}

.jp-FormGroup-contentCompact
  .jp-objectFieldWrapper
  .jp-objectFieldWrapper
  .form-group {
  padding: 2px 8px 2px var(--jp-private-settingeditor-modifier-indent);
  margin-top: 2px;
}

.jp-FormGroup-contentCompact ul.error-detail {
  margin-block-start: 0.5em;
  margin-block-end: 0.5em;
  padding-inline-start: 1em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-SidePanel {
  display: flex;
  flex-direction: column;
  min-width: var(--jp-sidebar-min-width);
  overflow-y: auto;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);
  font-size: var(--jp-ui-font-size1);
}

.jp-SidePanel-header {
  flex: 0 0 auto;
  display: flex;
  border-bottom: var(--jp-border-width) solid var(--jp-border-color2);
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin: 0;
  padding: 2px;
  text-transform: uppercase;
}

.jp-SidePanel-toolbar {
  flex: 0 0 auto;
}

.jp-SidePanel-content {
  flex: 1 1 auto;
}

.jp-SidePanel-toolbar,
.jp-AccordionPanel-toolbar {
  height: var(--jp-private-toolbar-height);
}

.jp-SidePanel-toolbar.jp-Toolbar-micro {
  display: none;
}

.lm-AccordionPanel .jp-AccordionPanel-title {
  box-sizing: border-box;
  line-height: 25px;
  margin: 0;
  display: flex;
  align-items: center;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  font-size: var(--jp-ui-font-size0);
}

.jp-AccordionPanel-title {
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  text-transform: uppercase;
}

.lm-AccordionPanel[data-orientation='horizontal'] > .jp-AccordionPanel-title {
  /* Title is rotated for horizontal accordion panel using CSS */
  display: block;
  transform-origin: top left;
  transform: rotate(-90deg) translate(-100%);
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleLabel {
  user-select: none;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.jp-AccordionPanel-title .lm-AccordionPanel-titleCollapser {
  transform: rotate(-90deg);
  margin: auto 0;
  height: 16px;
}

.jp-AccordionPanel-title.lm-mod-expanded .lm-AccordionPanel-titleCollapser {
  transform: rotate(0deg);
}

.lm-AccordionPanel .jp-AccordionPanel-toolbar {
  background: none;
  box-shadow: none;
  border: none;
  margin-left: auto;
}

.lm-AccordionPanel .lm-SplitPanel-handle:hover {
  background: var(--jp-layout-color3);
}

.jp-text-truncated {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Spinner {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-layout-color0);
  outline: none;
}

.jp-SpinnerContent {
  font-size: 10px;
  margin: 50px auto;
  text-indent: -9999em;
  width: 3em;
  height: 3em;
  border-radius: 50%;
  background: var(--jp-brand-color3);
  background: linear-gradient(
    to right,
    #f37626 10%,
    rgba(255, 255, 255, 0) 42%
  );
  position: relative;
  animation: load3 1s infinite linear, fadeIn 1s;
}

.jp-SpinnerContent::before {
  width: 50%;
  height: 50%;
  background: #f37626;
  border-radius: 100% 0 0;
  position: absolute;
  top: 0;
  left: 0;
  content: '';
}

.jp-SpinnerContent::after {
  background: var(--jp-layout-color0);
  width: 75%;
  height: 75%;
  border-radius: 50%;
  content: '';
  margin: auto;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes load3 {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

button.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: none;
  box-sizing: border-box;
  text-align: center;
  line-height: 32px;
  height: 32px;
  padding: 0 12px;
  letter-spacing: 0.8px;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input.jp-mod-styled {
  background: var(--jp-input-background);
  height: 28px;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color1);
  padding-left: 7px;
  padding-right: 7px;
  font-size: var(--jp-ui-font-size2);
  color: var(--jp-ui-font-color0);
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

input[type='checkbox'].jp-mod-styled {
  appearance: checkbox;
  -webkit-appearance: checkbox;
  -moz-appearance: checkbox;
  height: auto;
}

input.jp-mod-styled:focus {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-select-wrapper {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 1px;
  background-color: var(--jp-layout-color1);
  box-sizing: border-box;
  margin-bottom: 12px;
}

.jp-select-wrapper:not(.multiple) {
  height: 28px;
}

.jp-select-wrapper.jp-mod-focused select.jp-mod-styled {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-input-active-background);
}

select.jp-mod-styled:hover {
  cursor: pointer;
  color: var(--jp-ui-font-color0);
  background-color: var(--jp-input-hover-background);
  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.5);
}

select.jp-mod-styled {
  flex: 1 1 auto;
  width: 100%;
  font-size: var(--jp-ui-font-size2);
  background: var(--jp-input-background);
  color: var(--jp-ui-font-color0);
  padding: 0 25px 0 8px;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

select.jp-mod-styled:not([multiple]) {
  height: 32px;
}

select.jp-mod-styled[multiple] {
  max-height: 200px;
  overflow-y: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-switch {
  display: flex;
  align-items: center;
  padding-left: 4px;
  padding-right: 4px;
  font-size: var(--jp-ui-font-size1);
  background-color: transparent;
  color: var(--jp-ui-font-color1);
  border: none;
  height: 20px;
}

.jp-switch:hover {
  background-color: var(--jp-layout-color2);
}

.jp-switch-label {
  margin-right: 5px;
  font-family: var(--jp-ui-font-family);
}

.jp-switch-track {
  cursor: pointer;
  background-color: var(--jp-switch-color, var(--jp-border-color1));
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 34px;
  height: 16px;
  width: 35px;
  position: relative;
}

.jp-switch-track::before {
  content: '';
  position: absolute;
  height: 10px;
  width: 10px;
  margin: 3px;
  left: 0;
  background-color: var(--jp-ui-inverse-font-color1);
  -webkit-transition: 0.4s;
  transition: 0.4s;
  border-radius: 50%;
}

.jp-switch[aria-checked='true'] .jp-switch-track {
  background-color: var(--jp-switch-true-position-color, var(--jp-warn-color0));
}

.jp-switch[aria-checked='true'] .jp-switch-track::before {
  /* track width (35) - margins (3 + 3) - thumb width (10) */
  left: 19px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toolbar-height: calc(
    28px + var(--jp-border-width)
  ); /* leave 28px for content */
}

.jp-Toolbar {
  color: var(--jp-ui-font-color1);
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: 2px;
  z-index: 8;
  overflow-x: hidden;
}

/* Toolbar items */

.jp-Toolbar > .jp-Toolbar-item.jp-Toolbar-spacer {
  flex-grow: 1;
  flex-shrink: 1;
}

.jp-Toolbar-item.jp-Toolbar-kernelStatus {
  display: inline-block;
  width: 32px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 16px;
}

.jp-Toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  display: flex;
  padding-left: 1px;
  padding-right: 1px;
  font-size: var(--jp-ui-font-size1);
  line-height: var(--jp-private-toolbar-height);
  height: 100%;
}

/* Toolbar buttons */

/* This is the div we use to wrap the react component into a Widget */
div.jp-ToolbarButton {
  color: transparent;
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0;
  margin: 0;
}

button.jp-ToolbarButtonComponent {
  background: var(--jp-layout-color1);
  border: none;
  box-sizing: border-box;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0 6px;
  margin: 0;
  height: 24px;
  border-radius: var(--jp-border-radius);
  display: flex;
  align-items: center;
  text-align: center;
  font-size: 14px;
  min-width: unset;
  min-height: unset;
}

button.jp-ToolbarButtonComponent:disabled {
  opacity: 0.4;
}

button.jp-ToolbarButtonComponent > span {
  padding: 0;
  flex: 0 0 auto;
}

button.jp-ToolbarButtonComponent .jp-ToolbarButtonComponent-label {
  font-size: var(--jp-ui-font-size1);
  line-height: 100%;
  padding-left: 2px;
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar.jp-Toolbar-micro {
  padding: 0;
  min-height: 0;
}

#jp-main-dock-panel[data-mode='single-document']
  .jp-MainAreaWidget
  > .jp-Toolbar {
  border: none;
  box-shadow: none;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-WindowedPanel-outer {
  position: relative;
  overflow-y: auto;
}

.jp-WindowedPanel-inner {
  position: relative;
}

.jp-WindowedPanel-window {
  position: absolute;
  left: 0;
  right: 0;
  overflow: visible;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/* Sibling imports */

body {
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
}

/* Disable native link decoration styles everywhere outside of dialog boxes */
a {
  text-decoration: unset;
  color: unset;
}

a:hover {
  text-decoration: unset;
  color: unset;
}

/* Accessibility for links inside dialog box text */
.jp-Dialog-content a {
  text-decoration: revert;
  color: var(--jp-content-link-color);
}

.jp-Dialog-content a:hover {
  text-decoration: revert;
}

/* Styles for ui-components */
.jp-Button {
  color: var(--jp-ui-font-color2);
  border-radius: var(--jp-border-radius);
  padding: 0 12px;
  font-size: var(--jp-ui-font-size1);

  /* Copy from blueprint 3 */
  display: inline-flex;
  flex-direction: row;
  border: none;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  text-align: left;
  vertical-align: middle;
  min-height: 30px;
  min-width: 30px;
}

.jp-Button:disabled {
  cursor: not-allowed;
}

.jp-Button:empty {
  padding: 0 !important;
}

.jp-Button.jp-mod-small {
  min-height: 24px;
  min-width: 24px;
  font-size: 12px;
  padding: 0 7px;
}

/* Use our own theme for hover styles */
.jp-Button.jp-mod-minimal:hover {
  background-color: var(--jp-layout-color2);
}

.jp-Button.jp-mod-minimal {
  background: none;
}

.jp-InputGroup {
  display: block;
  position: relative;
}

.jp-InputGroup input {
  box-sizing: border-box;
  border: none;
  border-radius: 0;
  background-color: transparent;
  color: var(--jp-ui-font-color0);
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
  padding-bottom: 0;
  padding-top: 0;
  padding-left: 10px;
  padding-right: 28px;
  position: relative;
  width: 100%;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  font-size: 14px;
  font-weight: 400;
  height: 30px;
  line-height: 30px;
  outline: none;
  vertical-align: middle;
}

.jp-InputGroup input:focus {
  box-shadow: inset 0 0 0 var(--jp-border-width)
      var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-InputGroup input:disabled {
  cursor: not-allowed;
  resize: block;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input:disabled ~ span {
  cursor: not-allowed;
  color: var(--jp-ui-font-color2);
}

.jp-InputGroup input::placeholder,
input::placeholder {
  color: var(--jp-ui-font-color2);
}

.jp-InputGroupAction {
  position: absolute;
  bottom: 1px;
  right: 0;
  padding: 6px;
}

.jp-HTMLSelect.jp-DefaultStyle select {
  background-color: initial;
  border: none;
  border-radius: 0;
  box-shadow: none;
  color: var(--jp-ui-font-color0);
  display: block;
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  height: 24px;
  line-height: 14px;
  padding: 0 25px 0 10px;
  text-align: left;
  -moz-appearance: none;
  -webkit-appearance: none;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
  cursor: not-allowed;
  resize: block;
}

.jp-HTMLSelect.jp-DefaultStyle select:disabled ~ span {
  cursor: not-allowed;
}

/* Use our own theme for hover and option styles */
/* stylelint-disable-next-line selector-max-type */
.jp-HTMLSelect.jp-DefaultStyle select:hover,
.jp-HTMLSelect.jp-DefaultStyle select > option {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color0);
}

select {
  box-sizing: border-box;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-StatusBar-Widget {
  display: flex;
  align-items: center;
  background: var(--jp-layout-color2);
  min-height: var(--jp-statusbar-height);
  justify-content: space-between;
  padding: 0 10px;
}

.jp-StatusBar-Left {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-StatusBar-Middle {
  display: flex;
  align-items: center;
}

.jp-StatusBar-Right {
  display: flex;
  align-items: center;
  flex-direction: row-reverse;
}

.jp-StatusBar-Item {
  max-height: var(--jp-statusbar-height);
  margin: 0 2px;
  height: var(--jp-statusbar-height);
  white-space: nowrap;
  text-overflow: ellipsis;
  color: var(--jp-ui-font-color1);
  padding: 0 6px;
}

.jp-mod-highlighted:hover {
  background-color: var(--jp-layout-color3);
}

.jp-mod-clicked {
  background-color: var(--jp-brand-color1);
}

.jp-mod-clicked:hover {
  background-color: var(--jp-brand-color0);
}

.jp-mod-clicked .jp-StatusBar-TextItem {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-StatusBar-HoverItem {
  box-shadow: '0px 4px 4px rgba(0, 0, 0, 0.25)';
}

.jp-StatusBar-TextItem {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  line-height: 24px;
  color: var(--jp-ui-font-color1);
}

.jp-StatusBar-GroupItem {
  display: flex;
  align-items: center;
  flex-direction: row;
}

.jp-Statusbar-ProgressCircle svg {
  display: block;
  margin: 0 auto;
  width: 16px;
  height: 24px;
  align-self: normal;
}

.jp-Statusbar-ProgressCircle path {
  fill: var(--jp-inverse-layout-color3);
}

.jp-Statusbar-ProgressBar-progress-bar {
  height: 10px;
  width: 100px;
  border: solid 0.25px var(--jp-brand-color2);
  border-radius: 3px;
  overflow: hidden;
  align-self: center;
}

.jp-Statusbar-ProgressBar-progress-bar > div {
  background-color: var(--jp-brand-color2);
  background-image: linear-gradient(
    -45deg,
    rgba(255, 255, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.2) 75%,
    transparent 75%,
    transparent
  );
  background-size: 40px 40px;
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 14px;
  color: #fff;
  text-align: center;
  animation: jp-Statusbar-ExecutionTime-progress-bar 2s linear infinite;
}

.jp-Statusbar-ProgressBar-progress-bar p {
  color: var(--jp-ui-font-color1);
  font-family: var(--jp-ui-font-family);
  font-size: var(--jp-ui-font-size1);
  line-height: 10px;
  width: 100px;
}

@keyframes jp-Statusbar-ExecutionTime-progress-bar {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 40px 40px;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-commandpalette-search-height: 28px;
}

/*-----------------------------------------------------------------------------
| Overall styles
|----------------------------------------------------------------------------*/

.lm-CommandPalette {
  padding-bottom: 0;
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Modal variant
|----------------------------------------------------------------------------*/

.jp-ModalCommandPalette {
  position: absolute;
  z-index: 10000;
  top: 38px;
  left: 30%;
  margin: 0;
  padding: 4px;
  width: 40%;
  box-shadow: var(--jp-elevation-z4);
  border-radius: 4px;
  background: var(--jp-layout-color0);
}

.jp-ModalCommandPalette .lm-CommandPalette {
  max-height: 40vh;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-close-icon::after {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-header {
  display: none;
}

.jp-ModalCommandPalette .lm-CommandPalette .lm-CommandPalette-item {
  margin-left: 4px;
  margin-right: 4px;
}

.jp-ModalCommandPalette
  .lm-CommandPalette
  .lm-CommandPalette-item.lm-mod-disabled {
  display: none;
}

/*-----------------------------------------------------------------------------
| Search
|----------------------------------------------------------------------------*/

.lm-CommandPalette-search {
  padding: 4px;
  background-color: var(--jp-layout-color1);
  z-index: 2;
}

.lm-CommandPalette-wrapper {
  overflow: overlay;
  padding: 0 9px;
  background-color: var(--jp-input-active-background);
  height: 30px;
  box-shadow: inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color);
}

.lm-CommandPalette.lm-mod-focused .lm-CommandPalette-wrapper {
  box-shadow: inset 0 0 0 1px var(--jp-input-active-box-shadow-color),
    inset 0 0 0 3px var(--jp-input-active-box-shadow-color);
}

.jp-SearchIconGroup {
  color: white;
  background-color: var(--jp-brand-color1);
  position: absolute;
  top: 4px;
  right: 4px;
  padding: 5px 5px 1px;
}

.jp-SearchIconGroup svg {
  height: 20px;
  width: 20px;
}

.jp-SearchIconGroup .jp-icon3[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-input {
  background: transparent;
  width: calc(100% - 18px);
  float: left;
  border: none;
  outline: none;
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  line-height: var(--jp-private-commandpalette-search-height);
}

.lm-CommandPalette-input::-webkit-input-placeholder,
.lm-CommandPalette-input::-moz-placeholder,
.lm-CommandPalette-input:-ms-input-placeholder {
  color: var(--jp-ui-font-color2);
  font-size: var(--jp-ui-font-size1);
}

/*-----------------------------------------------------------------------------
| Results
|----------------------------------------------------------------------------*/

.lm-CommandPalette-header:first-child {
  margin-top: 0;
}

.lm-CommandPalette-header {
  border-bottom: solid var(--jp-border-width) var(--jp-border-color2);
  color: var(--jp-ui-font-color1);
  cursor: pointer;
  display: flex;
  font-size: var(--jp-ui-font-size0);
  font-weight: 600;
  letter-spacing: 1px;
  margin-top: 8px;
  padding: 8px 0 8px 12px;
  text-transform: uppercase;
}

.lm-CommandPalette-header.lm-mod-active {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-header > mark {
  background-color: transparent;
  font-weight: bold;
  color: var(--jp-ui-font-color1);
}

.lm-CommandPalette-item {
  padding: 4px 12px 4px 4px;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  font-weight: 400;
  display: flex;
}

.lm-CommandPalette-item.lm-mod-disabled {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item.lm-mod-active {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item.lm-mod-active .lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-inverse-font-color0);
}

.lm-CommandPalette-item.lm-mod-active .jp-icon-selectable[fill] {
  fill: var(--jp-layout-color0);
}

.lm-CommandPalette-item.lm-mod-active:hover:not(.lm-mod-disabled) {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.lm-CommandPalette-item:hover:not(.lm-mod-active):not(.lm-mod-disabled) {
  background: var(--jp-layout-color2);
}

.lm-CommandPalette-itemContent {
  overflow: hidden;
}

.lm-CommandPalette-itemLabel > mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.lm-CommandPalette-item.lm-mod-disabled mark {
  color: var(--jp-ui-font-color2);
}

.lm-CommandPalette-item .lm-CommandPalette-itemIcon {
  margin: 0 4px 0 0;
  position: relative;
  width: 16px;
  top: 2px;
  flex: 0 0 auto;
}

.lm-CommandPalette-item.lm-mod-disabled .lm-CommandPalette-itemIcon {
  opacity: 0.6;
}

.lm-CommandPalette-item .lm-CommandPalette-itemShortcut {
  flex: 0 0 auto;
}

.lm-CommandPalette-itemCaption {
  display: none;
}

.lm-CommandPalette-content {
  background-color: var(--jp-layout-color1);
}

.lm-CommandPalette-content:empty::after {
  content: 'No results';
  margin: auto;
  margin-top: 20px;
  width: 100px;
  display: block;
  font-size: var(--jp-ui-font-size2);
  font-family: var(--jp-ui-font-family);
  font-weight: lighter;
}

.lm-CommandPalette-emptyMessage {
  text-align: center;
  margin-top: 24px;
  line-height: 1.32;
  padding: 0 8px;
  color: var(--jp-content-font-color3);
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Dialog {
  position: absolute;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: var(--jp-dialog-background);
}

.jp-Dialog-content {
  display: flex;
  flex-direction: column;
  margin-left: auto;
  margin-right: auto;
  background: var(--jp-layout-color1);
  padding: 24px 24px 12px;
  min-width: 300px;
  min-height: 150px;
  max-width: 1000px;
  max-height: 500px;
  box-sizing: border-box;
  box-shadow: var(--jp-elevation-z20);
  word-wrap: break-word;
  border-radius: var(--jp-border-radius);

  /* This is needed so that all font sizing of children done in ems is
   * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color1);
  resize: both;
}

.jp-Dialog-content.jp-Dialog-content-small {
  max-width: 500px;
}

.jp-Dialog-button {
  overflow: visible;
}

button.jp-Dialog-button:focus {
  outline: 1px solid var(--jp-brand-color1);
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button:focus::-moz-focus-inner {
  border: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus,
button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline-offset: 4px;
  -moz-outline-radius: 0;
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-accept:focus {
  outline: 1px solid var(--jp-accept-color-normal, var(--jp-brand-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-warn:focus {
  outline: 1px solid var(--jp-warn-color-normal, var(--jp-error-color1));
}

button.jp-Dialog-button.jp-mod-styled.jp-mod-reject:focus {
  outline: 1px solid var(--jp-reject-color-normal, var(--md-grey-600));
}

button.jp-Dialog-close-button {
  padding: 0;
  height: 100%;
  min-width: unset;
  min-height: unset;
}

.jp-Dialog-header {
  display: flex;
  justify-content: space-between;
  flex: 0 0 auto;
  padding-bottom: 12px;
  font-size: var(--jp-ui-font-size3);
  font-weight: 400;
  color: var(--jp-ui-font-color1);
}

.jp-Dialog-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  font-size: var(--jp-ui-font-size1);
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  overflow: auto;
}

.jp-Dialog-footer {
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  align-items: center;
  flex: 0 0 auto;
  margin-left: -12px;
  margin-right: -12px;
  padding: 12px;
}

.jp-Dialog-checkbox {
  padding-right: 5px;
}

.jp-Dialog-checkbox > input:focus-visible {
  outline: 1px solid var(--jp-input-active-border-color);
  outline-offset: 1px;
}

.jp-Dialog-spacer {
  flex: 1 1 auto;
}

.jp-Dialog-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.jp-Dialog-body > .jp-select-wrapper {
  width: 100%;
}

.jp-Dialog-body > button {
  padding: 0 16px;
}

.jp-Dialog-body > label {
  line-height: 1.4;
  color: var(--jp-ui-font-color0);
}

.jp-Dialog-button.jp-mod-styled:not(:last-child) {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Input-Boolean-Dialog {
  flex-direction: row-reverse;
  align-items: end;
  width: 100%;
}

.jp-Input-Boolean-Dialog > label {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MainAreaWidget > :focus {
  outline: none;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error {
  padding: 6px;
}

.jp-MainAreaWidget .jp-MainAreaWidget-error > pre {
  width: auto;
  padding: 10px;
  background: var(--jp-error-color3);
  border: var(--jp-border-width) solid var(--jp-error-color1);
  border-radius: var(--jp-border-radius);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  white-space: pre-wrap;
  word-wrap: break-word;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * google-material-color v1.2.6
 * https://github.com/danlevan/google-material-color
 */
:root {
  --md-red-50: #ffebee;
  --md-red-100: #ffcdd2;
  --md-red-200: #ef9a9a;
  --md-red-300: #e57373;
  --md-red-400: #ef5350;
  --md-red-500: #f44336;
  --md-red-600: #e53935;
  --md-red-700: #d32f2f;
  --md-red-800: #c62828;
  --md-red-900: #b71c1c;
  --md-red-A100: #ff8a80;
  --md-red-A200: #ff5252;
  --md-red-A400: #ff1744;
  --md-red-A700: #d50000;
  --md-pink-50: #fce4ec;
  --md-pink-100: #f8bbd0;
  --md-pink-200: #f48fb1;
  --md-pink-300: #f06292;
  --md-pink-400: #ec407a;
  --md-pink-500: #e91e63;
  --md-pink-600: #d81b60;
  --md-pink-700: #c2185b;
  --md-pink-800: #ad1457;
  --md-pink-900: #880e4f;
  --md-pink-A100: #ff80ab;
  --md-pink-A200: #ff4081;
  --md-pink-A400: #f50057;
  --md-pink-A700: #c51162;
  --md-purple-50: #f3e5f5;
  --md-purple-100: #e1bee7;
  --md-purple-200: #ce93d8;
  --md-purple-300: #ba68c8;
  --md-purple-400: #ab47bc;
  --md-purple-500: #9c27b0;
  --md-purple-600: #8e24aa;
  --md-purple-700: #7b1fa2;
  --md-purple-800: #6a1b9a;
  --md-purple-900: #4a148c;
  --md-purple-A100: #ea80fc;
  --md-purple-A200: #e040fb;
  --md-purple-A400: #d500f9;
  --md-purple-A700: #a0f;
  --md-deep-purple-50: #ede7f6;
  --md-deep-purple-100: #d1c4e9;
  --md-deep-purple-200: #b39ddb;
  --md-deep-purple-300: #9575cd;
  --md-deep-purple-400: #7e57c2;
  --md-deep-purple-500: #673ab7;
  --md-deep-purple-600: #5e35b1;
  --md-deep-purple-700: #512da8;
  --md-deep-purple-800: #4527a0;
  --md-deep-purple-900: #311b92;
  --md-deep-purple-A100: #b388ff;
  --md-deep-purple-A200: #7c4dff;
  --md-deep-purple-A400: #651fff;
  --md-deep-purple-A700: #6200ea;
  --md-indigo-50: #e8eaf6;
  --md-indigo-100: #c5cae9;
  --md-indigo-200: #9fa8da;
  --md-indigo-300: #7986cb;
  --md-indigo-400: #5c6bc0;
  --md-indigo-500: #3f51b5;
  --md-indigo-600: #3949ab;
  --md-indigo-700: #303f9f;
  --md-indigo-800: #283593;
  --md-indigo-900: #1a237e;
  --md-indigo-A100: #8c9eff;
  --md-indigo-A200: #536dfe;
  --md-indigo-A400: #3d5afe;
  --md-indigo-A700: #304ffe;
  --md-blue-50: #e3f2fd;
  --md-blue-100: #bbdefb;
  --md-blue-200: #90caf9;
  --md-blue-300: #64b5f6;
  --md-blue-400: #42a5f5;
  --md-blue-500: #2196f3;
  --md-blue-600: #1e88e5;
  --md-blue-700: #1976d2;
  --md-blue-800: #1565c0;
  --md-blue-900: #0d47a1;
  --md-blue-A100: #82b1ff;
  --md-blue-A200: #448aff;
  --md-blue-A400: #2979ff;
  --md-blue-A700: #2962ff;
  --md-light-blue-50: #e1f5fe;
  --md-light-blue-100: #b3e5fc;
  --md-light-blue-200: #81d4fa;
  --md-light-blue-300: #4fc3f7;
  --md-light-blue-400: #29b6f6;
  --md-light-blue-500: #03a9f4;
  --md-light-blue-600: #039be5;
  --md-light-blue-700: #0288d1;
  --md-light-blue-800: #0277bd;
  --md-light-blue-900: #01579b;
  --md-light-blue-A100: #80d8ff;
  --md-light-blue-A200: #40c4ff;
  --md-light-blue-A400: #00b0ff;
  --md-light-blue-A700: #0091ea;
  --md-cyan-50: #e0f7fa;
  --md-cyan-100: #b2ebf2;
  --md-cyan-200: #80deea;
  --md-cyan-300: #4dd0e1;
  --md-cyan-400: #26c6da;
  --md-cyan-500: #00bcd4;
  --md-cyan-600: #00acc1;
  --md-cyan-700: #0097a7;
  --md-cyan-800: #00838f;
  --md-cyan-900: #006064;
  --md-cyan-A100: #84ffff;
  --md-cyan-A200: #18ffff;
  --md-cyan-A400: #00e5ff;
  --md-cyan-A700: #00b8d4;
  --md-teal-50: #e0f2f1;
  --md-teal-100: #b2dfdb;
  --md-teal-200: #80cbc4;
  --md-teal-300: #4db6ac;
  --md-teal-400: #26a69a;
  --md-teal-500: #009688;
  --md-teal-600: #00897b;
  --md-teal-700: #00796b;
  --md-teal-800: #00695c;
  --md-teal-900: #004d40;
  --md-teal-A100: #a7ffeb;
  --md-teal-A200: #64ffda;
  --md-teal-A400: #1de9b6;
  --md-teal-A700: #00bfa5;
  --md-green-50: #e8f5e9;
  --md-green-100: #c8e6c9;
  --md-green-200: #a5d6a7;
  --md-green-300: #81c784;
  --md-green-400: #66bb6a;
  --md-green-500: #4caf50;
  --md-green-600: #43a047;
  --md-green-700: #388e3c;
  --md-green-800: #2e7d32;
  --md-green-900: #1b5e20;
  --md-green-A100: #b9f6ca;
  --md-green-A200: #69f0ae;
  --md-green-A400: #00e676;
  --md-green-A700: #00c853;
  --md-light-green-50: #f1f8e9;
  --md-light-green-100: #dcedc8;
  --md-light-green-200: #c5e1a5;
  --md-light-green-300: #aed581;
  --md-light-green-400: #9ccc65;
  --md-light-green-500: #8bc34a;
  --md-light-green-600: #7cb342;
  --md-light-green-700: #689f38;
  --md-light-green-800: #558b2f;
  --md-light-green-900: #33691e;
  --md-light-green-A100: #ccff90;
  --md-light-green-A200: #b2ff59;
  --md-light-green-A400: #76ff03;
  --md-light-green-A700: #64dd17;
  --md-lime-50: #f9fbe7;
  --md-lime-100: #f0f4c3;
  --md-lime-200: #e6ee9c;
  --md-lime-300: #dce775;
  --md-lime-400: #d4e157;
  --md-lime-500: #cddc39;
  --md-lime-600: #c0ca33;
  --md-lime-700: #afb42b;
  --md-lime-800: #9e9d24;
  --md-lime-900: #827717;
  --md-lime-A100: #f4ff81;
  --md-lime-A200: #eeff41;
  --md-lime-A400: #c6ff00;
  --md-lime-A700: #aeea00;
  --md-yellow-50: #fffde7;
  --md-yellow-100: #fff9c4;
  --md-yellow-200: #fff59d;
  --md-yellow-300: #fff176;
  --md-yellow-400: #ffee58;
  --md-yellow-500: #ffeb3b;
  --md-yellow-600: #fdd835;
  --md-yellow-700: #fbc02d;
  --md-yellow-800: #f9a825;
  --md-yellow-900: #f57f17;
  --md-yellow-A100: #ffff8d;
  --md-yellow-A200: #ff0;
  --md-yellow-A400: #ffea00;
  --md-yellow-A700: #ffd600;
  --md-amber-50: #fff8e1;
  --md-amber-100: #ffecb3;
  --md-amber-200: #ffe082;
  --md-amber-300: #ffd54f;
  --md-amber-400: #ffca28;
  --md-amber-500: #ffc107;
  --md-amber-600: #ffb300;
  --md-amber-700: #ffa000;
  --md-amber-800: #ff8f00;
  --md-amber-900: #ff6f00;
  --md-amber-A100: #ffe57f;
  --md-amber-A200: #ffd740;
  --md-amber-A400: #ffc400;
  --md-amber-A700: #ffab00;
  --md-orange-50: #fff3e0;
  --md-orange-100: #ffe0b2;
  --md-orange-200: #ffcc80;
  --md-orange-300: #ffb74d;
  --md-orange-400: #ffa726;
  --md-orange-500: #ff9800;
  --md-orange-600: #fb8c00;
  --md-orange-700: #f57c00;
  --md-orange-800: #ef6c00;
  --md-orange-900: #e65100;
  --md-orange-A100: #ffd180;
  --md-orange-A200: #ffab40;
  --md-orange-A400: #ff9100;
  --md-orange-A700: #ff6d00;
  --md-deep-orange-50: #fbe9e7;
  --md-deep-orange-100: #ffccbc;
  --md-deep-orange-200: #ffab91;
  --md-deep-orange-300: #ff8a65;
  --md-deep-orange-400: #ff7043;
  --md-deep-orange-500: #ff5722;
  --md-deep-orange-600: #f4511e;
  --md-deep-orange-700: #e64a19;
  --md-deep-orange-800: #d84315;
  --md-deep-orange-900: #bf360c;
  --md-deep-orange-A100: #ff9e80;
  --md-deep-orange-A200: #ff6e40;
  --md-deep-orange-A400: #ff3d00;
  --md-deep-orange-A700: #dd2c00;
  --md-brown-50: #efebe9;
  --md-brown-100: #d7ccc8;
  --md-brown-200: #bcaaa4;
  --md-brown-300: #a1887f;
  --md-brown-400: #8d6e63;
  --md-brown-500: #795548;
  --md-brown-600: #6d4c41;
  --md-brown-700: #5d4037;
  --md-brown-800: #4e342e;
  --md-brown-900: #3e2723;
  --md-grey-50: #fafafa;
  --md-grey-100: #f5f5f5;
  --md-grey-200: #eee;
  --md-grey-300: #e0e0e0;
  --md-grey-400: #bdbdbd;
  --md-grey-500: #9e9e9e;
  --md-grey-600: #757575;
  --md-grey-700: #616161;
  --md-grey-800: #424242;
  --md-grey-900: #212121;
  --md-blue-grey-50: #eceff1;
  --md-blue-grey-100: #cfd8dc;
  --md-blue-grey-200: #b0bec5;
  --md-blue-grey-300: #90a4ae;
  --md-blue-grey-400: #78909c;
  --md-blue-grey-500: #607d8b;
  --md-blue-grey-600: #546e7a;
  --md-blue-grey-700: #455a64;
  --md-blue-grey-800: #37474f;
  --md-blue-grey-900: #263238;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| RenderedText
|----------------------------------------------------------------------------*/

:root {
  /* This is the padding value to fill the gaps between lines containing spans with background color. */
  --jp-private-code-span-padding: calc(
    (var(--jp-code-line-height) - 1) * var(--jp-code-font-size) / 2
  );
}

.jp-RenderedText {
  text-align: left;
  padding-left: var(--jp-code-padding);
  line-height: var(--jp-code-line-height);
  font-family: var(--jp-code-font-family);
}

.jp-RenderedText pre,
.jp-RenderedJavaScript pre,
.jp-RenderedHTMLCommon pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
  border: none;
  margin: 0;
  padding: 0;
}

.jp-RenderedText pre a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedText pre a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* console foregrounds and backgrounds */
.jp-RenderedText pre .ansi-black-fg {
  color: #3e424d;
}

.jp-RenderedText pre .ansi-red-fg {
  color: #e75c58;
}

.jp-RenderedText pre .ansi-green-fg {
  color: #00a250;
}

.jp-RenderedText pre .ansi-yellow-fg {
  color: #ddb62b;
}

.jp-RenderedText pre .ansi-blue-fg {
  color: #208ffb;
}

.jp-RenderedText pre .ansi-magenta-fg {
  color: #d160c4;
}

.jp-RenderedText pre .ansi-cyan-fg {
  color: #60c6c8;
}

.jp-RenderedText pre .ansi-white-fg {
  color: #c5c1b4;
}

.jp-RenderedText pre .ansi-black-bg {
  background-color: #3e424d;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-bg {
  background-color: #e75c58;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-bg {
  background-color: #00a250;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-bg {
  background-color: #ddb62b;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-bg {
  background-color: #208ffb;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-bg {
  background-color: #d160c4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-bg {
  background-color: #60c6c8;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-bg {
  background-color: #c5c1b4;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-black-intense-fg {
  color: #282c36;
}

.jp-RenderedText pre .ansi-red-intense-fg {
  color: #b22b31;
}

.jp-RenderedText pre .ansi-green-intense-fg {
  color: #007427;
}

.jp-RenderedText pre .ansi-yellow-intense-fg {
  color: #b27d12;
}

.jp-RenderedText pre .ansi-blue-intense-fg {
  color: #0065ca;
}

.jp-RenderedText pre .ansi-magenta-intense-fg {
  color: #a03196;
}

.jp-RenderedText pre .ansi-cyan-intense-fg {
  color: #258f8f;
}

.jp-RenderedText pre .ansi-white-intense-fg {
  color: #a1a6b2;
}

.jp-RenderedText pre .ansi-black-intense-bg {
  background-color: #282c36;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-red-intense-bg {
  background-color: #b22b31;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-green-intense-bg {
  background-color: #007427;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-yellow-intense-bg {
  background-color: #b27d12;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-blue-intense-bg {
  background-color: #0065ca;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-magenta-intense-bg {
  background-color: #a03196;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-cyan-intense-bg {
  background-color: #258f8f;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-white-intense-bg {
  background-color: #a1a6b2;
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-default-inverse-fg {
  color: var(--jp-ui-inverse-font-color0);
}

.jp-RenderedText pre .ansi-default-inverse-bg {
  background-color: var(--jp-inverse-layout-color0);
  padding: var(--jp-private-code-span-padding) 0;
}

.jp-RenderedText pre .ansi-bold {
  font-weight: bold;
}

.jp-RenderedText pre .ansi-underline {
  text-decoration: underline;
}

.jp-RenderedText[data-mime-type='application/vnd.jupyter.stderr'] {
  background: var(--jp-rendermime-error-background);
  padding-top: var(--jp-code-padding);
}

/*-----------------------------------------------------------------------------
| RenderedLatex
|----------------------------------------------------------------------------*/

.jp-RenderedLatex {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);
}

/* Left-justify outputs.*/
.jp-OutputArea-output.jp-RenderedLatex {
  padding: var(--jp-code-padding);
  text-align: left;
}

/*-----------------------------------------------------------------------------
| RenderedHTML
|----------------------------------------------------------------------------*/

.jp-RenderedHTMLCommon {
  color: var(--jp-content-font-color1);
  font-family: var(--jp-content-font-family);
  font-size: var(--jp-content-font-size1);
  line-height: var(--jp-content-line-height);

  /* Give a bit more R padding on Markdown text to keep line lengths reasonable */
  padding-right: 20px;
}

.jp-RenderedHTMLCommon em {
  font-style: italic;
}

.jp-RenderedHTMLCommon strong {
  font-weight: bold;
}

.jp-RenderedHTMLCommon u {
  text-decoration: underline;
}

.jp-RenderedHTMLCommon a:link {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:hover {
  text-decoration: underline;
  color: var(--jp-content-link-color);
}

.jp-RenderedHTMLCommon a:visited {
  text-decoration: none;
  color: var(--jp-content-link-color);
}

/* Headings */

.jp-RenderedHTMLCommon h1,
.jp-RenderedHTMLCommon h2,
.jp-RenderedHTMLCommon h3,
.jp-RenderedHTMLCommon h4,
.jp-RenderedHTMLCommon h5,
.jp-RenderedHTMLCommon h6 {
  line-height: var(--jp-content-heading-line-height);
  font-weight: var(--jp-content-heading-font-weight);
  font-style: normal;
  margin: var(--jp-content-heading-margin-top) 0
    var(--jp-content-heading-margin-bottom) 0;
}

.jp-RenderedHTMLCommon h1:first-child,
.jp-RenderedHTMLCommon h2:first-child,
.jp-RenderedHTMLCommon h3:first-child,
.jp-RenderedHTMLCommon h4:first-child,
.jp-RenderedHTMLCommon h5:first-child,
.jp-RenderedHTMLCommon h6:first-child {
  margin-top: calc(0.5 * var(--jp-content-heading-margin-top));
}

.jp-RenderedHTMLCommon h1:last-child,
.jp-RenderedHTMLCommon h2:last-child,
.jp-RenderedHTMLCommon h3:last-child,
.jp-RenderedHTMLCommon h4:last-child,
.jp-RenderedHTMLCommon h5:last-child,
.jp-RenderedHTMLCommon h6:last-child {
  margin-bottom: calc(0.5 * var(--jp-content-heading-margin-bottom));
}

.jp-RenderedHTMLCommon h1 {
  font-size: var(--jp-content-font-size5);
}

.jp-RenderedHTMLCommon h2 {
  font-size: var(--jp-content-font-size4);
}

.jp-RenderedHTMLCommon h3 {
  font-size: var(--jp-content-font-size3);
}

.jp-RenderedHTMLCommon h4 {
  font-size: var(--jp-content-font-size2);
}

.jp-RenderedHTMLCommon h5 {
  font-size: var(--jp-content-font-size1);
}

.jp-RenderedHTMLCommon h6 {
  font-size: var(--jp-content-font-size0);
}

/* Lists */

/* stylelint-disable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon ul:not(.list-inline),
.jp-RenderedHTMLCommon ol:not(.list-inline) {
  padding-left: 2em;
}

.jp-RenderedHTMLCommon ul {
  list-style: disc;
}

.jp-RenderedHTMLCommon ul ul {
  list-style: square;
}

.jp-RenderedHTMLCommon ul ul ul {
  list-style: circle;
}

.jp-RenderedHTMLCommon ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol ol {
  list-style: upper-alpha;
}

.jp-RenderedHTMLCommon ol ol ol {
  list-style: lower-alpha;
}

.jp-RenderedHTMLCommon ol ol ol ol {
  list-style: lower-roman;
}

.jp-RenderedHTMLCommon ol ol ol ol ol {
  list-style: decimal;
}

.jp-RenderedHTMLCommon ol,
.jp-RenderedHTMLCommon ul {
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon ul ul,
.jp-RenderedHTMLCommon ul ol,
.jp-RenderedHTMLCommon ol ul,
.jp-RenderedHTMLCommon ol ol {
  margin-bottom: 0;
}

/* stylelint-enable selector-max-type, selector-max-compound-selectors */

.jp-RenderedHTMLCommon hr {
  color: var(--jp-border-color2);
  background-color: var(--jp-border-color1);
  margin-top: 1em;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon > pre {
  margin: 1.5em 2em;
}

.jp-RenderedHTMLCommon pre,
.jp-RenderedHTMLCommon code {
  border: 0;
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  line-height: var(--jp-code-line-height);
  padding: 0;
  white-space: pre-wrap;
}

.jp-RenderedHTMLCommon :not(pre) > code {
  background-color: var(--jp-layout-color2);
  padding: 1px 5px;
}

/* Tables */

.jp-RenderedHTMLCommon table {
  border-collapse: collapse;
  border-spacing: 0;
  border: none;
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  table-layout: fixed;
  margin-left: auto;
  margin-bottom: 1em;
  margin-right: auto;
}

.jp-RenderedHTMLCommon thead {
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  vertical-align: bottom;
}

.jp-RenderedHTMLCommon td,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon tr {
  vertical-align: middle;
  padding: 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}

.jp-RenderedMarkdown.jp-RenderedHTMLCommon td,
.jp-RenderedMarkdown.jp-RenderedHTMLCommon th {
  max-width: none;
}

:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon td,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon th,
:not(.jp-RenderedMarkdown).jp-RenderedHTMLCommon tr {
  text-align: right;
}

.jp-RenderedHTMLCommon th {
  font-weight: bold;
}

.jp-RenderedHTMLCommon tbody tr:nth-child(odd) {
  background: var(--jp-layout-color0);
}

.jp-RenderedHTMLCommon tbody tr:nth-child(even) {
  background: var(--jp-rendermime-table-row-background);
}

.jp-RenderedHTMLCommon tbody tr:hover {
  background: var(--jp-rendermime-table-row-hover-background);
}

.jp-RenderedHTMLCommon p {
  text-align: left;
  margin: 0;
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon img {
  -moz-force-broken-image-icon: 1;
}

/* Restrict to direct children as other images could be nested in other content. */
.jp-RenderedHTMLCommon > img {
  display: block;
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
}

/* Change color behind transparent images if they need it... */
[data-jp-theme-light='false'] .jp-RenderedImage img.jp-needs-light-background {
  background-color: var(--jp-inverse-layout-color1);
}

[data-jp-theme-light='true'] .jp-RenderedImage img.jp-needs-dark-background {
  background-color: var(--jp-inverse-layout-color1);
}

.jp-RenderedHTMLCommon img,
.jp-RenderedImage img,
.jp-RenderedHTMLCommon svg,
.jp-RenderedSVG svg {
  max-width: 100%;
  height: auto;
}

.jp-RenderedHTMLCommon img.jp-mod-unconfined,
.jp-RenderedImage img.jp-mod-unconfined,
.jp-RenderedHTMLCommon svg.jp-mod-unconfined,
.jp-RenderedSVG svg.jp-mod-unconfined {
  max-width: none;
}

.jp-RenderedHTMLCommon .alert {
  padding: var(--jp-notebook-padding);
  border: var(--jp-border-width) solid transparent;
  border-radius: var(--jp-border-radius);
  margin-bottom: 1em;
}

.jp-RenderedHTMLCommon .alert-info {
  color: var(--jp-info-color0);
  background-color: var(--jp-info-color3);
  border-color: var(--jp-info-color2);
}

.jp-RenderedHTMLCommon .alert-info hr {
  border-color: var(--jp-info-color3);
}

.jp-RenderedHTMLCommon .alert-info > p:last-child,
.jp-RenderedHTMLCommon .alert-info > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-warning {
  color: var(--jp-warn-color0);
  background-color: var(--jp-warn-color3);
  border-color: var(--jp-warn-color2);
}

.jp-RenderedHTMLCommon .alert-warning hr {
  border-color: var(--jp-warn-color3);
}

.jp-RenderedHTMLCommon .alert-warning > p:last-child,
.jp-RenderedHTMLCommon .alert-warning > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-success {
  color: var(--jp-success-color0);
  background-color: var(--jp-success-color3);
  border-color: var(--jp-success-color2);
}

.jp-RenderedHTMLCommon .alert-success hr {
  border-color: var(--jp-success-color3);
}

.jp-RenderedHTMLCommon .alert-success > p:last-child,
.jp-RenderedHTMLCommon .alert-success > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon .alert-danger {
  color: var(--jp-error-color0);
  background-color: var(--jp-error-color3);
  border-color: var(--jp-error-color2);
}

.jp-RenderedHTMLCommon .alert-danger hr {
  border-color: var(--jp-error-color3);
}

.jp-RenderedHTMLCommon .alert-danger > p:last-child,
.jp-RenderedHTMLCommon .alert-danger > ul:last-child {
  margin-bottom: 0;
}

.jp-RenderedHTMLCommon blockquote {
  margin: 1em 2em;
  padding: 0 1em;
  border-left: 5px solid var(--jp-border-color2);
}

a.jp-InternalAnchorLink {
  visibility: hidden;
  margin-left: 8px;
  color: var(--md-blue-800);
}

h1:hover .jp-InternalAnchorLink,
h2:hover .jp-InternalAnchorLink,
h3:hover .jp-InternalAnchorLink,
h4:hover .jp-InternalAnchorLink,
h5:hover .jp-InternalAnchorLink,
h6:hover .jp-InternalAnchorLink {
  visibility: visible;
}

.jp-RenderedHTMLCommon kbd {
  background-color: var(--jp-rendermime-table-row-background);
  border: 1px solid var(--jp-border-color0);
  border-bottom-color: var(--jp-border-color2);
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
  display: inline-block;
  font-size: var(--jp-ui-font-size0);
  line-height: 1em;
  padding: 0.2em 0.5em;
}

/* Most direct children of .jp-RenderedHTMLCommon have a margin-bottom of 1.0.
 * At the bottom of cells this is a bit too much as there is also spacing
 * between cells. Going all the way to 0 gets too tight between markdown and
 * code cells.
 */
.jp-RenderedHTMLCommon > *:last-child {
  margin-bottom: 0.5em;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/

.lm-cursor-backdrop {
  position: fixed;
  width: 200px;
  height: 200px;
  margin-top: -100px;
  margin-left: -100px;
  will-change: transform;
  z-index: 100;
}

.lm-mod-drag-image {
  will-change: transform;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-lineFormSearch {
  padding: 4px 12px;
  background-color: var(--jp-layout-color2);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
  font-size: var(--jp-ui-font-size1);
}

.jp-lineFormCaption {
  font-size: var(--jp-ui-font-size0);
  line-height: var(--jp-ui-font-size1);
  margin-top: 4px;
  color: var(--jp-ui-font-color0);
}

.jp-baseLineForm {
  border: none;
  border-radius: 0;
  position: absolute;
  background-size: 16px;
  background-repeat: no-repeat;
  background-position: center;
  outline: none;
}

.jp-lineFormButtonContainer {
  top: 4px;
  right: 8px;
  height: 24px;
  padding: 0 12px;
  width: 12px;
}

.jp-lineFormButtonIcon {
  top: 0;
  right: 0;
  background-color: var(--jp-brand-color1);
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  padding: 4px 6px;
}

.jp-lineFormButton {
  top: 0;
  right: 0;
  background-color: transparent;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
}

.jp-lineFormWrapper {
  overflow: hidden;
  padding: 0 8px;
  border: 1px solid var(--jp-border-color0);
  background-color: var(--jp-input-active-background);
  height: 22px;
}

.jp-lineFormWrapperFocusWithin {
  border: var(--jp-border-width) solid var(--md-blue-500);
  box-shadow: inset 0 0 4px var(--md-blue-300);
}

.jp-lineFormInput {
  background: transparent;
  width: 200px;
  height: 100%;
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  line-height: 28px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, Jupyter Development Team.
|
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-JSONEditor {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.jp-JSONEditor-host {
  flex: 1 1 auto;
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  border-radius: 0;
  background: var(--jp-layout-color0);
  min-height: 50px;
  padding: 1px;
}

.jp-JSONEditor.jp-mod-error .jp-JSONEditor-host {
  border-color: red;
  outline-color: red;
}

.jp-JSONEditor-header {
  display: flex;
  flex: 1 0 auto;
  padding: 0 0 0 12px;
}

.jp-JSONEditor-header label {
  flex: 0 0 auto;
}

.jp-JSONEditor-commitButton {
  height: 16px;
  width: 16px;
  background-size: 18px;
  background-repeat: no-repeat;
  background-position: center;
}

.jp-JSONEditor-host.jp-mod-focused {
  background-color: var(--jp-input-active-background);
  border: 1px solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

.jp-Editor.jp-mod-dropTarget {
  border: var(--jp-border-width) solid var(--jp-input-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
.jp-DocumentSearch-input {
  border: none;
  outline: none;
  color: var(--jp-ui-font-color0);
  font-size: var(--jp-ui-font-size1);
  background-color: var(--jp-layout-color0);
  font-family: var(--jp-ui-font-family);
  padding: 2px 1px;
  resize: none;
}

.jp-DocumentSearch-overlay {
  position: absolute;
  background-color: var(--jp-toolbar-background);
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  border-left: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  top: 0;
  right: 0;
  z-index: 7;
  min-width: 405px;
  padding: 2px;
  font-size: var(--jp-ui-font-size1);

  --jp-private-document-search-button-height: 20px;
}

.jp-DocumentSearch-overlay button {
  background-color: var(--jp-toolbar-background);
  outline: 0;
}

.jp-DocumentSearch-overlay button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-overlay button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-overlay-row {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

.jp-DocumentSearch-button-content {
  display: inline-block;
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-button-content svg {
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-input-wrapper {
  border: var(--jp-border-width) solid var(--jp-border-color0);
  display: flex;
  background-color: var(--jp-layout-color0);
  margin: 2px;
}

.jp-DocumentSearch-input-wrapper:focus-within {
  border-color: var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper {
  all: initial;
  overflow: hidden;
  display: inline-block;
  border: none;
  box-sizing: border-box;
}

.jp-DocumentSearch-toggle-wrapper {
  width: 14px;
  height: 14px;
}

.jp-DocumentSearch-button-wrapper {
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
}

.jp-DocumentSearch-toggle-wrapper:focus,
.jp-DocumentSearch-button-wrapper:focus {
  outline: var(--jp-border-width) solid
    var(--jp-cell-editor-active-border-color);
  outline-offset: -1px;
}

.jp-DocumentSearch-toggle-wrapper,
.jp-DocumentSearch-button-wrapper,
.jp-DocumentSearch-button-content:focus {
  outline: none;
}

.jp-DocumentSearch-toggle-placeholder {
  width: 5px;
}

.jp-DocumentSearch-input-button::before {
  display: block;
  padding-top: 100%;
}

.jp-DocumentSearch-input-button-off {
  opacity: var(--jp-search-toggle-off-opacity);
}

.jp-DocumentSearch-input-button-off:hover {
  opacity: var(--jp-search-toggle-hover-opacity);
}

.jp-DocumentSearch-input-button-on {
  opacity: var(--jp-search-toggle-on-opacity);
}

.jp-DocumentSearch-index-counter {
  padding-left: 10px;
  padding-right: 10px;
  user-select: none;
  min-width: 35px;
  display: inline-block;
}

.jp-DocumentSearch-up-down-wrapper {
  display: inline-block;
  padding-right: 2px;
  margin-left: auto;
  white-space: nowrap;
}

.jp-DocumentSearch-spacer {
  margin-left: auto;
}

.jp-DocumentSearch-up-down-wrapper button {
  outline: 0;
  border: none;
  width: var(--jp-private-document-search-button-height);
  height: var(--jp-private-document-search-button-height);
  vertical-align: middle;
  margin: 1px 5px 2px;
}

.jp-DocumentSearch-up-down-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-up-down-button:active {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-filter-button {
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-filter-button:hover {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled {
  background-color: var(--jp-layout-color2);
}

.jp-DocumentSearch-filter-button-enabled:hover {
  background-color: var(--jp-layout-color3);
}

.jp-DocumentSearch-search-options {
  padding: 0 8px;
  margin-left: 3px;
  width: 100%;
  display: grid;
  justify-content: start;
  grid-template-columns: 1fr 1fr;
  align-items: center;
  justify-items: stretch;
}

.jp-DocumentSearch-search-filter-disabled {
  color: var(--jp-ui-font-color2);
}

.jp-DocumentSearch-search-filter {
  display: flex;
  align-items: center;
  user-select: none;
}

.jp-DocumentSearch-regex-error {
  color: var(--jp-error-color0);
}

.jp-DocumentSearch-replace-button-wrapper {
  overflow: hidden;
  display: inline-block;
  box-sizing: border-box;
  border: var(--jp-border-width) solid var(--jp-border-color0);
  margin: auto 2px;
  padding: 1px 4px;
  height: calc(var(--jp-private-document-search-button-height) + 2px);
}

.jp-DocumentSearch-replace-button-wrapper:focus {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
}

.jp-DocumentSearch-replace-button {
  display: inline-block;
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
  color: var(--jp-ui-font-color1);

  /* height - 2 * (padding of wrapper) */
  line-height: calc(var(--jp-private-document-search-button-height) - 2px);
  width: 100%;
  height: 100%;
}

.jp-DocumentSearch-replace-button:focus {
  outline: none;
}

.jp-DocumentSearch-replace-wrapper-class {
  margin-left: 14px;
  display: flex;
}

.jp-DocumentSearch-replace-toggle {
  border: none;
  background-color: var(--jp-toolbar-background);
  border-radius: var(--jp-border-radius);
}

.jp-DocumentSearch-replace-toggle:hover {
  background-color: var(--jp-layout-color2);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.cm-editor {
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  border: 0;
  border-radius: 0;
  height: auto;

  /* Changed to auto to autogrow */
}

.cm-editor pre {
  padding: 0 var(--jp-code-padding);
}

.jp-CodeMirrorEditor[data-type='inline'] .cm-dialog {
  background-color: var(--jp-layout-color0);
  color: var(--jp-content-font-color1);
}

.jp-CodeMirrorEditor {
  cursor: text;
}

/* When zoomed out 67% and 33% on a screen of 1440 width x 900 height */
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width1) solid
      var(--jp-editor-cursor-color);
  }
}

/* When zoomed out less than 33% */
@media screen and (min-width: 4320px) {
  .jp-CodeMirrorEditor[data-type='inline'] .cm-cursor {
    border-left: var(--jp-code-cursor-width2) solid
      var(--jp-editor-cursor-color);
  }
}

.cm-editor.jp-mod-readOnly .cm-cursor {
  display: none;
}

.jp-CollaboratorCursor {
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: none;
  border-bottom: 3px solid;
  background-clip: content-box;
  margin-left: -5px;
  margin-right: -5px;
}

.cm-searching,
.cm-searching span {
  /* `.cm-searching span`: we need to override syntax highlighting */
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.cm-searching::selection,
.cm-searching span::selection {
  background-color: var(--jp-search-unselected-match-background-color);
  color: var(--jp-search-unselected-match-color);
}

.jp-current-match > .cm-searching,
.jp-current-match > .cm-searching span,
.cm-searching > .jp-current-match,
.cm-searching > .jp-current-match span {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.jp-current-match > .cm-searching::selection,
.cm-searching > .jp-current-match::selection,
.jp-current-match > .cm-searching span::selection {
  background-color: var(--jp-search-selected-match-background-color);
  color: var(--jp-search-selected-match-color);
}

.cm-trailingspace {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAsElEQVQIHQGlAFr/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7+r3zKmT0/+pk9P/7+r3zAAAAAAAAAAABAAAAAAAAAAA6OPzM+/q9wAAAAAA6OPzMwAAAAAAAAAAAgAAAAAAAAAAGR8NiRQaCgAZIA0AGR8NiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQyoYJ/SY80UAAAAASUVORK5CYII=);
  background-position: center left;
  background-repeat: repeat-x;
}

.jp-CollaboratorCursor-hover {
  position: absolute;
  z-index: 1;
  transform: translateX(-50%);
  color: white;
  border-radius: 3px;
  padding-left: 4px;
  padding-right: 4px;
  padding-top: 1px;
  padding-bottom: 1px;
  text-align: center;
  font-size: var(--jp-ui-font-size1);
  white-space: nowrap;
}

.jp-CodeMirror-ruler {
  border-left: 1px dashed var(--jp-border-color2);
}

/* Styles for shared cursors (remote cursor locations and selected ranges) */
.jp-CodeMirrorEditor .cm-ySelectionCaret {
  position: relative;
  border-left: 1px solid black;
  margin-left: -1px;
  margin-right: -1px;
  box-sizing: border-box;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret > .cm-ySelectionInfo {
  white-space: nowrap;
  position: absolute;
  top: -1.15em;
  padding-bottom: 0.05em;
  left: -1px;
  font-size: 0.95em;
  font-family: var(--jp-ui-font-family);
  font-weight: bold;
  line-height: normal;
  user-select: none;
  color: white;
  padding-left: 2px;
  padding-right: 2px;
  z-index: 101;
  transition: opacity 0.3s ease-in-out;
}

.jp-CodeMirrorEditor .cm-ySelectionInfo {
  transition-delay: 0.7s;
  opacity: 0;
}

.jp-CodeMirrorEditor .cm-ySelectionCaret:hover > .cm-ySelectionInfo {
  opacity: 1;
  transition-delay: 0s;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-MimeDocument {
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-filebrowser-button-height: 28px;
  --jp-private-filebrowser-button-width: 48px;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-FileBrowser .jp-SidePanel-content {
  display: flex;
  flex-direction: column;
}

.jp-FileBrowser-toolbar.jp-Toolbar {
  flex-wrap: wrap;
  row-gap: 12px;
  border-bottom: none;
  height: auto;
  margin: 8px 12px 0;
  box-shadow: none;
  padding: 0;
  justify-content: flex-start;
}

.jp-FileBrowser-Panel {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
}

.jp-BreadCrumbs {
  flex: 0 0 auto;
  margin: 8px 12px;
}

.jp-BreadCrumbs-item {
  margin: 0 2px;
  padding: 0 2px;
  border-radius: var(--jp-border-radius);
  cursor: pointer;
}

.jp-BreadCrumbs-item:hover {
  background-color: var(--jp-layout-color2);
}

.jp-BreadCrumbs-item:first-child {
  margin-left: 0;
}

.jp-BreadCrumbs-item.jp-mod-dropTarget {
  background-color: var(--jp-brand-color2);
  opacity: 0.7;
}

/*-----------------------------------------------------------------------------
| Buttons
|----------------------------------------------------------------------------*/

.jp-FileBrowser-toolbar > .jp-Toolbar-item {
  flex: 0 0 auto;
  padding-left: 0;
  padding-right: 2px;
  align-items: center;
  height: unset;
}

.jp-FileBrowser-toolbar > .jp-Toolbar-item .jp-ToolbarButtonComponent {
  width: 40px;
}

/*-----------------------------------------------------------------------------
| Other styles
|----------------------------------------------------------------------------*/

.jp-FileDialog.jp-mod-conflict input {
  color: var(--jp-error-color1);
}

.jp-FileDialog .jp-new-name-title {
  margin-top: 12px;
}

.jp-LastModified-hidden {
  display: none;
}

.jp-FileSize-hidden {
  display: none;
}

.jp-FileBrowser .lm-AccordionPanel > h3:first-child {
  display: none;
}

/*-----------------------------------------------------------------------------
| DirListing
|----------------------------------------------------------------------------*/

.jp-DirListing {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  outline: 0;
}

.jp-DirListing-header {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  border-top: var(--jp-border-width) solid var(--jp-border-color2);
  border-bottom: var(--jp-border-width) solid var(--jp-border-color1);
  box-shadow: var(--jp-toolbar-box-shadow);
  z-index: 2;
}

.jp-DirListing-headerItem {
  padding: 4px 12px 2px;
  font-weight: 500;
}

.jp-DirListing-headerItem:hover {
  background: var(--jp-layout-color2);
}

.jp-DirListing-headerItem.jp-id-name {
  flex: 1 0 84px;
}

.jp-DirListing-headerItem.jp-id-modified {
  flex: 0 0 112px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-DirListing-headerItem.jp-id-filesize {
  flex: 0 0 75px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
}

.jp-id-narrow {
  display: none;
  flex: 0 0 5px;
  padding: 4px;
  border-left: var(--jp-border-width) solid var(--jp-border-color2);
  text-align: right;
  color: var(--jp-border-color2);
}

.jp-DirListing-narrow .jp-id-narrow {
  display: block;
}

.jp-DirListing-narrow .jp-id-modified,
.jp-DirListing-narrow .jp-DirListing-itemModified {
  display: none;
}

.jp-DirListing-headerItem.jp-mod-selected {
  font-weight: 600;
}

/* increase specificity to override bundled default */
.jp-DirListing-content {
  flex: 1 1 auto;
  margin: 0;
  padding: 0;
  list-style-type: none;
  overflow: auto;
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-content mark {
  color: var(--jp-ui-font-color0);
  background-color: transparent;
  font-weight: bold;
}

.jp-DirListing-content .jp-DirListing-item.jp-mod-selected mark {
  color: var(--jp-ui-inverse-font-color0);
}

/* Style the directory listing content when a user drops a file to upload */
.jp-DirListing.jp-mod-native-drop .jp-DirListing-content {
  outline: 5px dashed rgba(128, 128, 128, 0.5);
  outline-offset: -10px;
  cursor: copy;
}

.jp-DirListing-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 4px 12px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-DirListing-checkboxWrapper {
  /* Increases hit area of checkbox. */
  padding: 4px;
}

.jp-DirListing-header
  .jp-DirListing-checkboxWrapper
  + .jp-DirListing-headerItem {
  padding-left: 4px;
}

.jp-DirListing-content .jp-DirListing-checkboxWrapper {
  position: relative;
  left: -4px;
  margin: -4px 0 -4px -8px;
}

.jp-DirListing-checkboxWrapper.jp-mod-visible {
  visibility: visible;
}

/* For devices that support hovering, hide checkboxes until hovered, selected...
*/
@media (hover: hover) {
  .jp-DirListing-checkboxWrapper {
    visibility: hidden;
  }

  .jp-DirListing-item:hover .jp-DirListing-checkboxWrapper,
  .jp-DirListing-item.jp-mod-selected .jp-DirListing-checkboxWrapper {
    visibility: visible;
  }
}

.jp-DirListing-item[data-is-dot] {
  opacity: 75%;
}

.jp-DirListing-item.jp-mod-selected {
  color: var(--jp-ui-inverse-font-color1);
  background: var(--jp-brand-color1);
}

.jp-DirListing-item.jp-mod-dropTarget {
  background: var(--jp-brand-color3);
}

.jp-DirListing-item:hover:not(.jp-mod-selected) {
  background: var(--jp-layout-color2);
}

.jp-DirListing-itemIcon {
  flex: 0 0 20px;
  margin-right: 4px;
}

.jp-DirListing-itemText {
  flex: 1 0 64px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  user-select: none;
}

.jp-DirListing-itemText:focus {
  outline-width: 2px;
  outline-color: var(--jp-inverse-layout-color1);
  outline-style: solid;
  outline-offset: 1px;
}

.jp-DirListing-item.jp-mod-selected .jp-DirListing-itemText:focus {
  outline-color: var(--jp-layout-color1);
}

.jp-DirListing-itemModified {
  flex: 0 0 125px;
  text-align: right;
}

.jp-DirListing-itemFileSize {
  flex: 0 0 90px;
  text-align: right;
}

.jp-DirListing-editor {
  flex: 1 0 64px;
  outline: none;
  border: none;
  color: var(--jp-ui-font-color1);
  background-color: var(--jp-layout-color1);
}

.jp-DirListing-item.jp-mod-running .jp-DirListing-itemIcon::before {
  color: var(--jp-success-color1);
  content: '\25CF';
  font-size: 8px;
  position: absolute;
  left: -8px;
}

.jp-DirListing-item.jp-mod-running.jp-mod-selected
  .jp-DirListing-itemIcon::before {
  color: var(--jp-ui-inverse-font-color1);
}

.jp-DirListing-item.lm-mod-drag-image,
.jp-DirListing-item.jp-mod-selected.lm-mod-drag-image {
  font-size: var(--jp-ui-font-size1);
  padding-left: 4px;
  margin-left: 4px;
  width: 160px;
  background-color: var(--jp-ui-inverse-font-color2);
  box-shadow: var(--jp-elevation-z2);
  border-radius: 0;
  color: var(--jp-ui-font-color1);
  transform: translateX(-40%) translateY(-58%);
}

.jp-Document {
  min-width: 120px;
  min-height: 120px;
  outline: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Main OutputArea
| OutputArea has a list of Outputs
|----------------------------------------------------------------------------*/

.jp-OutputArea {
  overflow-y: auto;
}

.jp-OutputArea-child {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-OutputPrompt {
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-outprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
  opacity: var(--jp-cell-prompt-opacity);

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-OutputArea-prompt {
  display: table-cell;
  vertical-align: top;
}

.jp-OutputArea-output {
  display: table-cell;
  width: 100%;
  height: auto;
  overflow: auto;
  user-select: text;
  -moz-user-select: text;
  -webkit-user-select: text;
  -ms-user-select: text;
}

.jp-OutputArea .jp-RenderedText {
  padding-left: 1ch;
}

/**
 * Prompt overlay.
 */

.jp-OutputArea-promptOverlay {
  position: absolute;
  top: 0;
  width: var(--jp-cell-prompt-width);
  height: 100%;
  opacity: 0.5;
}

.jp-OutputArea-promptOverlay:hover {
  background: var(--jp-layout-color2);
  box-shadow: inset 0 0 1px var(--jp-inverse-layout-color0);
  cursor: zoom-out;
}

.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay:hover {
  cursor: zoom-in;
}

/**
 * Isolated output.
 */
.jp-OutputArea-output.jp-mod-isolated {
  width: 100%;
  display: block;
}

/*
When drag events occur, `lm-mod-override-cursor` is added to the body.
Because iframes steal all cursor events, the following two rules are necessary
to suppress pointer events while resize drags are occurring. There may be a
better solution to this problem.
*/
body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated {
  position: relative;
}

body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
}

/* pre */

.jp-OutputArea-output pre {
  border: none;
  margin: 0;
  padding: 0;
  overflow-x: auto;
  overflow-y: auto;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* tables */

.jp-OutputArea-output.jp-RenderedHTMLCommon table {
  margin-left: 0;
  margin-right: 0;
}

/* description lists */

.jp-OutputArea-output dl,
.jp-OutputArea-output dt,
.jp-OutputArea-output dd {
  display: block;
}

.jp-OutputArea-output dl {
  width: 100%;
  overflow: hidden;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dt {
  font-weight: bold;
  float: left;
  width: 20%;
  padding: 0;
  margin: 0;
}

.jp-OutputArea-output dd {
  float: left;
  width: 80%;
  padding: 0;
  margin: 0;
}

.jp-TrimmedOutputs pre {
  background: var(--jp-layout-color3);
  font-size: calc(var(--jp-code-font-size) * 1.4);
  text-align: center;
  text-transform: uppercase;
}

/* Hide the gutter in case of
 *  - nested output areas (e.g. in the case of output widgets)
 *  - mirrored output areas
 */
.jp-OutputArea .jp-OutputArea .jp-OutputArea-prompt {
  display: none;
}

/* Hide empty lines in the output area, for instance due to cleared widgets */
.jp-OutputArea-prompt:empty {
  padding: 0;
  border: 0;
}

/*-----------------------------------------------------------------------------
| executeResult is added to any Output-result for the display of the object
| returned by a cell
|----------------------------------------------------------------------------*/

.jp-OutputArea-output.jp-OutputArea-executeResult {
  margin-left: 0;
  width: 100%;
}

/* Text output with the Out[] prompt needs a top padding to match the
 * alignment of the Out[] prompt itself.
 */
.jp-OutputArea-executeResult .jp-RenderedText.jp-OutputArea-output {
  padding-top: var(--jp-code-padding);
  border-top: var(--jp-border-width) solid transparent;
}

/*-----------------------------------------------------------------------------
| The Stdin output
|----------------------------------------------------------------------------*/

.jp-Stdin-prompt {
  color: var(--jp-content-font-color0);
  padding-right: var(--jp-code-padding);
  vertical-align: baseline;
  flex: 0 0 auto;
}

.jp-Stdin-input {
  font-family: var(--jp-code-font-family);
  font-size: inherit;
  color: inherit;
  background-color: inherit;
  width: 42%;
  min-width: 200px;

  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;

  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0 0.25em;
  margin: 0 0.25em;
  flex: 0 0 70%;
}

.jp-Stdin-input::placeholder {
  opacity: 0;
}

.jp-Stdin-input:focus {
  box-shadow: none;
}

.jp-Stdin-input:focus::placeholder {
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Output Area View
|----------------------------------------------------------------------------*/

.jp-LinkedOutputView .jp-OutputArea {
  height: 100%;
  display: block;
}

.jp-LinkedOutputView .jp-OutputArea-output:only-child {
  height: 100%;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

@media print {
  .jp-OutputArea-child {
    break-inside: avoid-page;
  }
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-OutputPrompt {
    display: table-row;
    text-align: left;
  }

  .jp-OutputArea-child .jp-OutputArea-output {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }
}

/* Trimmed outputs warning */
.jp-TrimmedOutputs > a {
  margin: 10px;
  text-decoration: none;
  cursor: pointer;
}

.jp-TrimmedOutputs > a:hover {
  text-decoration: none;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Table of Contents
|----------------------------------------------------------------------------*/

:root {
  --jp-private-toc-active-width: 4px;
}

.jp-TableOfContents {
  display: flex;
  flex-direction: column;
  background: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  font-size: var(--jp-ui-font-size1);
  height: 100%;
}

.jp-TableOfContents-placeholder {
  text-align: center;
}

.jp-TableOfContents-placeholderContent {
  color: var(--jp-content-font-color2);
  padding: 8px;
}

.jp-TableOfContents-placeholderContent > h3 {
  margin-bottom: var(--jp-content-heading-margin-bottom);
}

.jp-TableOfContents .jp-SidePanel-content {
  overflow-y: auto;
}

.jp-TableOfContents-tree {
  margin: 4px;
}

.jp-TableOfContents ol {
  list-style-type: none;
}

/* stylelint-disable-next-line selector-max-type */
.jp-TableOfContents li > ol {
  /* Align left border with triangle icon center */
  padding-left: 11px;
}

.jp-TableOfContents-content {
  /* left margin for the active heading indicator */
  margin: 0 0 0 var(--jp-private-toc-active-width);
  padding: 0;
  background-color: var(--jp-layout-color1);
}

.jp-tocItem {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.jp-tocItem-heading {
  display: flex;
  cursor: pointer;
}

.jp-tocItem-heading:hover {
  background-color: var(--jp-layout-color2);
}

.jp-tocItem-content {
  display: block;
  padding: 4px 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow-x: hidden;
}

.jp-tocItem-collapser {
  height: 20px;
  margin: 2px 2px 0;
  padding: 0;
  background: none;
  border: none;
  cursor: pointer;
}

.jp-tocItem-collapser:hover {
  background-color: var(--jp-layout-color3);
}

/* Active heading indicator */

.jp-tocItem-heading::before {
  content: ' ';
  background: transparent;
  width: var(--jp-private-toc-active-width);
  height: 24px;
  position: absolute;
  left: 0;
  border-radius: var(--jp-border-radius);
}

.jp-tocItem-heading.jp-tocItem-active::before {
  background-color: var(--jp-brand-color1);
}

.jp-tocItem-heading:hover.jp-tocItem-active::before {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

.jp-Collapser {
  flex: 0 0 var(--jp-cell-collapser-width);
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
  border-radius: var(--jp-border-radius);
  opacity: 1;
}

.jp-Collapser-child {
  display: block;
  width: 100%;
  box-sizing: border-box;

  /* height: 100% doesn't work because the height of its parent is computed from content */
  position: absolute;
  top: 0;
  bottom: 0;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Hiding collapsers in print mode.

Note: input and output wrappers have "display: block" propery in print mode.
*/

@media print {
  .jp-Collapser {
    display: none;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Header/Footer
|----------------------------------------------------------------------------*/

/* Hidden by zero height by default */
.jp-CellHeader,
.jp-CellFooter {
  height: 0;
  width: 100%;
  padding: 0;
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Input
|----------------------------------------------------------------------------*/

/* All input areas */
.jp-InputArea {
  display: table;
  table-layout: fixed;
  width: 100%;
  overflow: hidden;
}

.jp-InputArea-editor {
  display: table-cell;
  overflow: hidden;
  vertical-align: top;

  /* This is the non-active, default styling */
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  background: var(--jp-cell-editor-background);
}

.jp-InputPrompt {
  display: table-cell;
  vertical-align: top;
  width: var(--jp-cell-prompt-width);
  color: var(--jp-cell-inprompt-font-color);
  font-family: var(--jp-cell-prompt-font-family);
  padding: var(--jp-code-padding);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  opacity: var(--jp-cell-prompt-opacity);
  line-height: var(--jp-code-line-height);
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;

  /* Right align prompt text, don't wrap to handle large prompt numbers */
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  /* Disable text selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/*-----------------------------------------------------------------------------
| Mobile
|----------------------------------------------------------------------------*/
@media only screen and (max-width: 760px) {
  .jp-InputArea-editor {
    display: table-row;
    margin-left: var(--jp-notebook-padding);
  }

  .jp-InputPrompt {
    display: table-row;
    text-align: left;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Placeholder {
  display: table;
  table-layout: fixed;
  width: 100%;
}

.jp-Placeholder-prompt {
  display: table-cell;
  box-sizing: border-box;
}

.jp-Placeholder-content {
  display: table-cell;
  padding: 4px 6px;
  border: 1px solid transparent;
  border-radius: 0;
  background: none;
  box-sizing: border-box;
  cursor: pointer;
}

.jp-Placeholder-contentContainer {
  display: flex;
}

.jp-Placeholder-content:hover,
.jp-InputPlaceholder > .jp-Placeholder-content:hover {
  border-color: var(--jp-layout-color3);
}

.jp-Placeholder-content .jp-MoreHorizIcon {
  width: 32px;
  height: 16px;
  border: 1px solid transparent;
  border-radius: var(--jp-border-radius);
}

.jp-Placeholder-content .jp-MoreHorizIcon:hover {
  border: 1px solid var(--jp-border-color1);
  box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.25);
  background-color: var(--jp-layout-color0);
}

.jp-PlaceholderText {
  white-space: nowrap;
  overflow-x: hidden;
  color: var(--jp-inverse-layout-color3);
  font-family: var(--jp-code-font-family);
}

.jp-InputPlaceholder > .jp-Placeholder-content {
  border-color: var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Private CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-private-cell-scrolling-output-offset: 5px;
}

/*-----------------------------------------------------------------------------
| Cell
|----------------------------------------------------------------------------*/

.jp-Cell {
  padding: var(--jp-cell-padding);
  margin: 0;
  border: none;
  outline: none;
  background: transparent;
}

/*-----------------------------------------------------------------------------
| Common input/output
|----------------------------------------------------------------------------*/

.jp-Cell-inputWrapper,
.jp-Cell-outputWrapper {
  display: flex;
  flex-direction: row;
  padding: 0;
  margin: 0;

  /* Added to reveal the box-shadow on the input and output collapsers. */
  overflow: visible;
}

/* Only input/output areas inside cells */
.jp-Cell-inputArea,
.jp-Cell-outputArea {
  flex: 1 1 auto;
}

/*-----------------------------------------------------------------------------
| Collapser
|----------------------------------------------------------------------------*/

/* Make the output collapser disappear when there is not output, but do so
 * in a manner that leaves it in the layout and preserves its width.
 */
.jp-Cell.jp-mod-noOutputs .jp-Cell-outputCollapser {
  border: none !important;
  background: transparent !important;
}

.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputCollapser {
  min-height: var(--jp-cell-collapser-min-height);
}

/*-----------------------------------------------------------------------------
| Output
|----------------------------------------------------------------------------*/

/* Put a space between input and output when there IS output */
.jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputWrapper {
  margin-top: 5px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea {
  overflow-y: auto;
  max-height: 24em;
  margin-left: var(--jp-private-cell-scrolling-output-offset);
  resize: vertical;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea[style*='height'] {
  max-height: unset;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea::after {
  content: ' ';
  box-shadow: inset 0 0 6px 2px rgb(0 0 0 / 30%);
  width: 100%;
  height: 100%;
  position: sticky;
  bottom: 0;
  top: 0;
  margin-top: -50%;
  float: left;
  display: block;
  pointer-events: none;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-child {
  padding-top: 6px;
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-prompt {
  width: calc(
    var(--jp-cell-prompt-width) - var(--jp-private-cell-scrolling-output-offset)
  );
}

.jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-promptOverlay {
  left: calc(-1 * var(--jp-private-cell-scrolling-output-offset));
}

/*-----------------------------------------------------------------------------
| CodeCell
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| MarkdownCell
|----------------------------------------------------------------------------*/

.jp-MarkdownOutput {
  display: table-cell;
  width: 100%;
  margin-top: 0;
  margin-bottom: 0;
  padding-left: var(--jp-code-padding);
}

.jp-MarkdownOutput.jp-RenderedHTMLCommon {
  overflow: auto;
}

/* collapseHeadingButton (show always if hiddenCellsButton is _not_ shown) */
.jp-collapseHeadingButton {
  display: flex;
  min-height: var(--jp-cell-collapser-min-height);
  font-size: var(--jp-code-font-size);
  position: absolute;
  background-color: transparent;
  background-size: 25px;
  background-repeat: no-repeat;
  background-position-x: center;
  background-position-y: top;
  background-image: var(--jp-icon-caret-down);
  right: 0;
  top: 0;
  bottom: 0;
}

.jp-collapseHeadingButton.jp-mod-collapsed {
  background-image: var(--jp-icon-caret-right);
}

/*
 set the container font size to match that of content
 so that the nested collapse buttons have the right size
*/
.jp-MarkdownCell .jp-InputPrompt {
  font-size: var(--jp-content-font-size1);
}

/*
  Align collapseHeadingButton with cell top header
  The font sizes are identical to the ones in packages/rendermime/style/base.css
*/
.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='1'] {
  font-size: var(--jp-content-font-size5);
  background-position-y: calc(0.3 * var(--jp-content-font-size5));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='2'] {
  font-size: var(--jp-content-font-size4);
  background-position-y: calc(0.3 * var(--jp-content-font-size4));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='3'] {
  font-size: var(--jp-content-font-size3);
  background-position-y: calc(0.3 * var(--jp-content-font-size3));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='4'] {
  font-size: var(--jp-content-font-size2);
  background-position-y: calc(0.3 * var(--jp-content-font-size2));
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='5'] {
  font-size: var(--jp-content-font-size1);
  background-position-y: top;
}

.jp-mod-rendered .jp-collapseHeadingButton[data-heading-level='6'] {
  font-size: var(--jp-content-font-size0);
  background-position-y: top;
}

/* collapseHeadingButton (show only on (hover,active) if hiddenCellsButton is shown) */
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-collapseHeadingButton {
  display: none;
}

.jp-Notebook.jp-mod-showHiddenCellsButton
  :is(.jp-MarkdownCell:hover, .jp-mod-active)
  .jp-collapseHeadingButton {
  display: flex;
}

/* showHiddenCellsButton (only show if jp-mod-showHiddenCellsButton is set, which
is a consequence of the showHiddenCellsButton option in Notebook Settings)*/
.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton {
  margin-left: calc(var(--jp-cell-prompt-width) + 2 * var(--jp-code-padding));
  margin-top: var(--jp-code-padding);
  border: 1px solid var(--jp-border-color2);
  background-color: var(--jp-border-color3) !important;
  color: var(--jp-content-font-color0) !important;
  display: flex;
}

.jp-Notebook.jp-mod-showHiddenCellsButton .jp-showHiddenCellsButton:hover {
  background-color: var(--jp-border-color2) !important;
}

.jp-showHiddenCellsButton {
  display: none;
}

/*-----------------------------------------------------------------------------
| Printing
|----------------------------------------------------------------------------*/

/*
Using block instead of flex to allow the use of the break-inside CSS property for
cell outputs.
*/

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

:root {
  --jp-notebook-toolbar-padding: 2px 5px 2px 2px;
}

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-NotebookPanel-toolbar {
  padding: var(--jp-notebook-toolbar-padding);

  /* disable paint containment from lumino 2.0 default strict CSS containment */
  contain: style size !important;
}

.jp-Toolbar-item.jp-Notebook-toolbarCellType .jp-select-wrapper.jp-mod-focused {
  border: none;
  box-shadow: none;
}

.jp-Notebook-toolbarCellTypeDropdown select {
  height: 24px;
  font-size: var(--jp-ui-font-size1);
  line-height: 14px;
  border-radius: 0;
  display: block;
}

.jp-Notebook-toolbarCellTypeDropdown span {
  top: 5px !important;
}

.jp-Toolbar-responsive-popup {
  position: absolute;
  height: fit-content;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-end;
  border-bottom: var(--jp-border-width) solid var(--jp-toolbar-border-color);
  box-shadow: var(--jp-toolbar-box-shadow);
  background: var(--jp-toolbar-background);
  min-height: var(--jp-toolbar-micro-height);
  padding: var(--jp-notebook-toolbar-padding);
  z-index: 1;
  right: 0;
  top: 0;
}

.jp-Toolbar > .jp-Toolbar-responsive-opener {
  margin-left: auto;
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Variables
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------

/*-----------------------------------------------------------------------------
| Styles
|----------------------------------------------------------------------------*/

.jp-Notebook-ExecutionIndicator {
  position: relative;
  display: inline-block;
  height: 100%;
  z-index: 9997;
}

.jp-Notebook-ExecutionIndicator-tooltip {
  visibility: hidden;
  height: auto;
  width: max-content;
  width: -moz-max-content;
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color1);
  text-align: justify;
  border-radius: 6px;
  padding: 0 5px;
  position: fixed;
  display: table;
}

.jp-Notebook-ExecutionIndicator-tooltip.up {
  transform: translateX(-50%) translateY(-100%) translateY(-32px);
}

.jp-Notebook-ExecutionIndicator-tooltip.down {
  transform: translateX(calc(-100% + 16px)) translateY(5px);
}

.jp-Notebook-ExecutionIndicator-tooltip.hidden {
  display: none;
}

.jp-Notebook-ExecutionIndicator:hover .jp-Notebook-ExecutionIndicator-tooltip {
  visibility: visible;
}

.jp-Notebook-ExecutionIndicator span {
  font-size: var(--jp-ui-font-size1);
  font-family: var(--jp-ui-font-family);
  color: var(--jp-ui-font-color1);
  line-height: 24px;
  display: block;
}

.jp-Notebook-ExecutionIndicator-progress-bar {
  display: flex;
  justify-content: center;
  height: 100%;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

/*
 * Execution indicator
 */
.jp-tocItem-content::after {
  content: '';

  /* Must be identical to form a circle */
  width: 12px;
  height: 12px;
  background: none;
  border: none;
  position: absolute;
  right: 0;
}

.jp-tocItem-content[data-running='0']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background: none;
}

.jp-tocItem-content[data-running='1']::after {
  border-radius: 50%;
  border: var(--jp-border-width) solid var(--jp-inverse-layout-color3);
  background-color: var(--jp-inverse-layout-color3);
}

.jp-tocItem-content[data-running='0'],
.jp-tocItem-content[data-running='1'] {
  margin-right: 12px;
}

/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.jp-Notebook-footer {
  height: 27px;
  margin-left: calc(
    var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
      var(--jp-cell-padding)
  );
  width: calc(
    100% -
      (
        var(--jp-cell-prompt-width) + var(--jp-cell-collapser-width) +
          var(--jp-cell-padding) + var(--jp-cell-padding)
      )
  );
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  color: var(--jp-ui-font-color3);
  margin-top: 6px;
  background: none;
  cursor: pointer;
}

.jp-Notebook-footer:focus {
  border-color: var(--jp-cell-editor-active-border-color);
}

/* For devices that support hovering, hide footer until hover */
@media (hover: hover) {
  .jp-Notebook-footer {
    opacity: 0;
  }

  .jp-Notebook-footer:focus,
  .jp-Notebook-footer:hover {
    opacity: 1;
  }
}

/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| Imports
|----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
| CSS variables
|----------------------------------------------------------------------------*/

:root {
  --jp-side-by-side-output-size: 1fr;
  --jp-side-by-side-resized-cell: var(--jp-side-by-side-output-size);
  --jp-private-notebook-dragImage-width: 304px;
  --jp-private-notebook-dragImage-height: 36px;
  --jp-private-notebook-selected-color: var(--md-blue-400);
  --jp-private-notebook-active-color: var(--md-green-400);
}

/*-----------------------------------------------------------------------------
| Notebook
|----------------------------------------------------------------------------*/

/* stylelint-disable selector-max-class */

.jp-NotebookPanel {
  display: block;
  height: 100%;
}

.jp-NotebookPanel.jp-Document {
  min-width: 240px;
  min-height: 120px;
}

.jp-Notebook {
  padding: var(--jp-notebook-padding);
  outline: none;
  overflow: auto;
  background: var(--jp-layout-color0);
}

.jp-Notebook.jp-mod-scrollPastEnd::after {
  display: block;
  content: '';
  min-height: var(--jp-notebook-scroll-padding);
}

.jp-MainAreaWidget-ContainStrict .jp-Notebook * {
  contain: strict;
}

.jp-Notebook .jp-Cell {
  overflow: visible;
}

.jp-Notebook .jp-Cell .jp-InputPrompt {
  cursor: move;
}

/*-----------------------------------------------------------------------------
| Notebook state related styling
|
| The notebook and cells each have states, here are the possibilities:
|
| - Notebook
|   - Command
|   - Edit
| - Cell
|   - None
|   - Active (only one can be active)
|   - Selected (the cells actions are applied to)
|   - Multiselected (when multiple selected, the cursor)
|   - No outputs
|----------------------------------------------------------------------------*/

/* Command or edit modes */

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-InputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

.jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-OutputPrompt {
  opacity: var(--jp-cell-prompt-not-active-opacity);
  color: var(--jp-cell-prompt-not-active-font-color);
}

/* cell is active */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser {
  background: var(--jp-brand-color1);
}

/* cell is dirty */
.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt {
  color: var(--jp-warn-color1);
}

.jp-Notebook .jp-Cell.jp-mod-dirty .jp-InputPrompt::before {
  color: var(--jp-warn-color1);
  content: '';
}

.jp-Notebook .jp-Cell.jp-mod-active.jp-mod-dirty .jp-Collapser {
  background: var(--jp-warn-color1);
}

/* collapser is hovered */
.jp-Notebook .jp-Cell .jp-Collapser:hover {
  box-shadow: var(--jp-elevation-z2);
  background: var(--jp-brand-color1);
  opacity: var(--jp-cell-collapser-not-active-hover-opacity);
}

/* cell is active and collapser is hovered */
.jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser:hover {
  background: var(--jp-brand-color0);
  opacity: 1;
}

/* Command mode */

.jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected {
  background: var(--jp-notebook-multiselected-color);
}

.jp-Notebook.jp-mod-commandMode
  .jp-Cell.jp-mod-active.jp-mod-selected:not(.jp-mod-multiSelected) {
  background: transparent;
}

/* Edit mode */

.jp-Notebook.jp-mod-editMode .jp-Cell.jp-mod-active .jp-InputArea-editor {
  border: var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);
  box-shadow: var(--jp-input-box-shadow);
  background-color: var(--jp-cell-editor-active-background);
}

/*-----------------------------------------------------------------------------
| Notebook drag and drop
|----------------------------------------------------------------------------*/

.jp-Notebook-cell.jp-mod-dropSource {
  opacity: 0.5;
}

.jp-Notebook-cell.jp-mod-dropTarget,
.jp-Notebook.jp-mod-commandMode
  .jp-Notebook-cell.jp-mod-active.jp-mod-selected.jp-mod-dropTarget {
  border-top-color: var(--jp-private-notebook-selected-color);
  border-top-style: solid;
  border-top-width: 2px;
}

.jp-dragImage {
  display: block;
  flex-direction: row;
  width: var(--jp-private-notebook-dragImage-width);
  height: var(--jp-private-notebook-dragImage-height);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background);
  overflow: visible;
}

.jp-dragImage-singlePrompt {
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

.jp-dragImage .jp-dragImage-content {
  flex: 1 1 auto;
  z-index: 2;
  font-size: var(--jp-code-font-size);
  font-family: var(--jp-code-font-family);
  line-height: var(--jp-code-line-height);
  padding: var(--jp-code-padding);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  background: var(--jp-cell-editor-background-color);
  color: var(--jp-content-font-color3);
  text-align: left;
  margin: 4px 4px 4px 0;
}

.jp-dragImage .jp-dragImage-prompt {
  flex: 0 0 auto;
  min-width: 36px;
  color: var(--jp-cell-inprompt-font-color);
  padding: var(--jp-code-padding);
  padding-left: 12px;
  font-family: var(--jp-cell-prompt-font-family);
  letter-spacing: var(--jp-cell-prompt-letter-spacing);
  line-height: 1.9;
  font-size: var(--jp-code-font-size);
  border: var(--jp-border-width) solid transparent;
}

.jp-dragImage-multipleBack {
  z-index: -1;
  position: absolute;
  height: 32px;
  width: 300px;
  top: 8px;
  left: 8px;
  background: var(--jp-layout-color2);
  border: var(--jp-border-width) solid var(--jp-input-border-color);
  box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, 0.12);
}

/*-----------------------------------------------------------------------------
| Cell toolbar
|----------------------------------------------------------------------------*/

.jp-NotebookTools {
  display: block;
  min-width: var(--jp-sidebar-min-width);
  color: var(--jp-ui-font-color1);
  background: var(--jp-layout-color1);

  /* This is needed so that all font sizing of children done in ems is
    * relative to this base size */
  font-size: var(--jp-ui-font-size1);
  overflow: auto;
}

.jp-ActiveCellTool {
  padding: 12px 0;
  display: flex;
}

.jp-ActiveCellTool-Content {
  flex: 1 1 auto;
}

.jp-ActiveCellTool .jp-ActiveCellTool-CellContent {
  background: var(--jp-cell-editor-background);
  border: var(--jp-border-width) solid var(--jp-cell-editor-border-color);
  border-radius: 0;
  min-height: 29px;
}

.jp-ActiveCellTool .jp-InputPrompt {
  min-width: calc(var(--jp-cell-prompt-width) * 0.75);
}

.jp-ActiveCellTool-CellContent > pre {
  padding: 5px 4px;
  margin: 0;
  white-space: normal;
}

.jp-MetadataEditorTool {
  flex-direction: column;
  padding: 12px 0;
}

.jp-RankedPanel > :not(:first-child) {
  margin-top: 12px;
}

.jp-KeySelector select.jp-mod-styled {
  font-size: var(--jp-ui-font-size1);
  color: var(--jp-ui-font-color0);
  border: var(--jp-border-width) solid var(--jp-border-color1);
}

.jp-KeySelector label,
.jp-MetadataEditorTool label,
.jp-NumberSetter label {
  line-height: 1.4;
}

.jp-NotebookTools .jp-select-wrapper {
  margin-top: 4px;
  margin-bottom: 0;
}

.jp-NumberSetter input {
  width: 100%;
  margin-top: 4px;
}

.jp-NotebookTools .jp-Collapse {
  margin-top: 16px;
}

/*-----------------------------------------------------------------------------
| Presentation Mode (.jp-mod-presentationMode)
|----------------------------------------------------------------------------*/

.jp-mod-presentationMode .jp-Notebook {
  --jp-content-font-size1: var(--jp-content-presentation-font-size1);
  --jp-code-font-size: var(--jp-code-presentation-font-size);
}

.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-InputPrompt,
.jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-OutputPrompt {
  flex: 0 0 110px;
}

/*-----------------------------------------------------------------------------
| Side-by-side Mode (.jp-mod-sideBySide)
|----------------------------------------------------------------------------*/
.jp-mod-sideBySide.jp-Notebook .jp-Notebook-cell {
  margin-top: 3em;
  margin-bottom: 3em;
  margin-left: 5%;
  margin-right: 5%;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell {
  display: grid;
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-output-size)
    );
  grid-template-rows: auto minmax(0, 1fr) auto;
  grid-template-areas:
    'header header header'
    'input handle output'
    'footer footer footer';
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell.jp-mod-resizedCell {
  grid-template-columns: minmax(0, 1fr) min-content minmax(
      0,
      var(--jp-side-by-side-resized-cell)
    );
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellHeader {
  grid-area: header;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-inputWrapper {
  grid-area: input;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-Cell-outputWrapper {
  /* overwrite the default margin (no vertical separation needed in side by side move */
  margin-top: 0;
  grid-area: output;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellFooter {
  grid-area: footer;
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle {
  grid-area: handle;
  user-select: none;
  display: block;
  height: 100%;
  cursor: ew-resize;
  padding: 0 var(--jp-cell-padding);
}

.jp-mod-sideBySide.jp-Notebook .jp-CodeCell .jp-CellResizeHandle::after {
  content: '';
  display: block;
  background: var(--jp-border-color2);
  height: 100%;
  width: 5px;
}

.jp-mod-sideBySide.jp-Notebook
  .jp-CodeCell.jp-mod-resizedCell
  .jp-CellResizeHandle::after {
  background: var(--jp-border-color0);
}

.jp-CellResizeHandle {
  display: none;
}

/*-----------------------------------------------------------------------------
| Placeholder
|----------------------------------------------------------------------------*/

.jp-Cell-Placeholder {
  padding-left: 55px;
}

.jp-Cell-Placeholder-wrapper {
  background: #fff;
  border: 1px solid;
  border-color: #e5e6e9 #dfe0e4 #d0d1d5;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  margin: 10px 15px;
}

.jp-Cell-Placeholder-wrapper-inner {
  padding: 15px;
  position: relative;
}

.jp-Cell-Placeholder-wrapper-body {
  background-repeat: repeat;
  background-size: 50% auto;
}

.jp-Cell-Placeholder-wrapper-body div {
  background: #f6f7f8;
  background-image: -webkit-linear-gradient(
    left,
    #f6f7f8 0%,
    #edeef1 20%,
    #f6f7f8 40%,
    #f6f7f8 100%
  );
  background-repeat: no-repeat;
  background-size: 800px 104px;
  height: 104px;
  position: absolute;
  right: 15px;
  left: 15px;
  top: 15px;
}

div.jp-Cell-Placeholder-h1 {
  top: 20px;
  height: 20px;
  left: 15px;
  width: 150px;
}

div.jp-Cell-Placeholder-h2 {
  left: 15px;
  top: 50px;
  height: 10px;
  width: 100px;
}

div.jp-Cell-Placeholder-content-1,
div.jp-Cell-Placeholder-content-2,
div.jp-Cell-Placeholder-content-3 {
  left: 15px;
  right: 15px;
  height: 10px;
}

div.jp-Cell-Placeholder-content-1 {
  top: 100px;
}

div.jp-Cell-Placeholder-content-2 {
  top: 120px;
}

div.jp-Cell-Placeholder-content-3 {
  top: 140px;
}

</style>
<style type="text/css">
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/*
The following CSS variables define the main, public API for styling JupyterLab.
These variables should be used by all plugins wherever possible. In other
words, plugins should not define custom colors, sizes, etc unless absolutely
necessary. This enables users to change the visual theme of JupyterLab
by changing these variables.

Many variables appear in an ordered sequence (0,1,2,3). These sequences
are designed to work well together, so for example, `--jp-border-color1` should
be used with `--jp-layout-color1`. The numbers have the following meanings:

* 0: super-primary, reserved for special emphasis
* 1: primary, most important under normal situations
* 2: secondary, next most important under normal situations
* 3: tertiary, next most important under normal situations

Throughout JupyterLab, we are mostly following principles from Google's
Material Design when selecting colors. We are not, however, following
all of MD as it is not optimized for dense, information rich UIs.
*/

:root {
  /* Elevation
   *
   * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here:
   *
   * https://github.com/material-components/material-components-web
   * https://material-components-web.appspot.com/elevation.html
   */

  /* The dark theme shadows need a bit of work, but this will probably also require work on the core layout
   * colors used in the theme as well. */
  --jp-shadow-base-lightness: 32;
  --jp-shadow-umbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.2
  );
  --jp-shadow-penumbra-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.14
  );
  --jp-shadow-ambient-color: rgba(
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    var(--jp-shadow-base-lightness),
    0.12
  );
  --jp-elevation-z0: none;
  --jp-elevation-z1: 0 2px 1px -1px var(--jp-shadow-umbra-color),
    0 1px 1px 0 var(--jp-shadow-penumbra-color),
    0 1px 3px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z2: 0 3px 1px -2px var(--jp-shadow-umbra-color),
    0 2px 2px 0 var(--jp-shadow-penumbra-color),
    0 1px 5px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z4: 0 2px 4px -1px var(--jp-shadow-umbra-color),
    0 4px 5px 0 var(--jp-shadow-penumbra-color),
    0 1px 10px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z6: 0 3px 5px -1px var(--jp-shadow-umbra-color),
    0 6px 10px 0 var(--jp-shadow-penumbra-color),
    0 1px 18px 0 var(--jp-shadow-ambient-color);
  --jp-elevation-z8: 0 5px 5px -3px var(--jp-shadow-umbra-color),
    0 8px 10px 1px var(--jp-shadow-penumbra-color),
    0 3px 14px 2px var(--jp-shadow-ambient-color);
  --jp-elevation-z12: 0 7px 8px -4px var(--jp-shadow-umbra-color),
    0 12px 17px 2px var(--jp-shadow-penumbra-color),
    0 5px 22px 4px var(--jp-shadow-ambient-color);
  --jp-elevation-z16: 0 8px 10px -5px var(--jp-shadow-umbra-color),
    0 16px 24px 2px var(--jp-shadow-penumbra-color),
    0 6px 30px 5px var(--jp-shadow-ambient-color);
  --jp-elevation-z20: 0 10px 13px -6px var(--jp-shadow-umbra-color),
    0 20px 31px 3px var(--jp-shadow-penumbra-color),
    0 8px 38px 7px var(--jp-shadow-ambient-color);
  --jp-elevation-z24: 0 11px 15px -7px var(--jp-shadow-umbra-color),
    0 24px 38px 3px var(--jp-shadow-penumbra-color),
    0 9px 46px 8px var(--jp-shadow-ambient-color);

  /* Borders
   *
   * The following variables, specify the visual styling of borders in JupyterLab.
   */

  --jp-border-width: 1px;
  --jp-border-color0: var(--md-grey-700);
  --jp-border-color1: var(--md-grey-700);
  --jp-border-color2: var(--md-grey-800);
  --jp-border-color3: var(--md-grey-900);
  --jp-inverse-border-color: var(--md-grey-600);
  --jp-border-radius: 2px;

  /* UI Fonts
   *
   * The UI font CSS variables are used for the typography all of the JupyterLab
   * user interface elements that are not directly user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-ui-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-ui-font-scale-factor: 1.2;
  --jp-ui-font-size0: 0.83333em;
  --jp-ui-font-size1: 13px; /* Base font size */
  --jp-ui-font-size2: 1.2em;
  --jp-ui-font-size3: 1.44em;
  --jp-ui-font-family: system-ui, -apple-system, blinkmacsystemfont, 'Segoe UI',
    helvetica, arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
    'Segoe UI Symbol';

  /*
   * Use these font colors against the corresponding main layout colors.
   * In a light theme, these go from dark to light.
   */

  /* Defaults use Material Design specification */
  --jp-ui-font-color0: rgba(255, 255, 255, 1);
  --jp-ui-font-color1: rgba(255, 255, 255, 0.87);
  --jp-ui-font-color2: rgba(255, 255, 255, 0.54);
  --jp-ui-font-color3: rgba(255, 255, 255, 0.38);

  /*
   * Use these against the brand/accent/warn/error colors.
   * These will typically go from light to darker, in both a dark and light theme.
   */

  --jp-ui-inverse-font-color0: rgba(0, 0, 0, 1);
  --jp-ui-inverse-font-color1: rgba(0, 0, 0, 0.8);
  --jp-ui-inverse-font-color2: rgba(0, 0, 0, 0.5);
  --jp-ui-inverse-font-color3: rgba(0, 0, 0, 0.3);

  /* Content Fonts
   *
   * Content font variables are used for typography of user generated content.
   *
   * The font sizing here is done assuming that the body font size of --jp-content-font-size1
   * is applied to a parent element. When children elements, such as headings, are sized
   * in em all things will be computed relative to that body size.
   */

  --jp-content-line-height: 1.6;
  --jp-content-font-scale-factor: 1.2;
  --jp-content-font-size0: 0.83333em;
  --jp-content-font-size1: 14px; /* Base font size */
  --jp-content-font-size2: 1.2em;
  --jp-content-font-size3: 1.44em;
  --jp-content-font-size4: 1.728em;
  --jp-content-font-size5: 2.0736em;

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-content-presentation-font-size1: 17px;
  --jp-content-heading-line-height: 1;
  --jp-content-heading-margin-top: 1.2em;
  --jp-content-heading-margin-bottom: 0.8em;
  --jp-content-heading-font-weight: 500;

  /* Defaults use Material Design specification */
  --jp-content-font-color0: rgba(255, 255, 255, 1);
  --jp-content-font-color1: rgba(255, 255, 255, 1);
  --jp-content-font-color2: rgba(255, 255, 255, 0.7);
  --jp-content-font-color3: rgba(255, 255, 255, 0.5);
  --jp-content-link-color: var(--md-blue-300);
  --jp-content-font-family: system-ui, -apple-system, blinkmacsystemfont,
    'Segoe UI', helvetica, arial, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol';

  /*
   * Code Fonts
   *
   * Code font variables are used for typography of code and other monospaces content.
   */

  --jp-code-font-size: 13px;
  --jp-code-line-height: 1.3077; /* 17px for 13px base */
  --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */
  --jp-code-font-family-default: menlo, consolas, 'DejaVu Sans Mono', monospace;
  --jp-code-font-family: var(--jp-code-font-family-default);

  /* This gives a magnification of about 125% in presentation mode over normal. */
  --jp-code-presentation-font-size: 16px;

  /* may need to tweak cursor width if you change font size */
  --jp-code-cursor-width0: 1.4px;
  --jp-code-cursor-width1: 2px;
  --jp-code-cursor-width2: 4px;

  /* Layout
   *
   * The following are the main layout colors use in JupyterLab. In a light
   * theme these would go from light to dark.
   */

  --jp-layout-color0: #111;
  --jp-layout-color1: var(--md-grey-900);
  --jp-layout-color2: var(--md-grey-800);
  --jp-layout-color3: var(--md-grey-700);
  --jp-layout-color4: var(--md-grey-600);

  /* Inverse Layout
   *
   * The following are the inverse layout colors use in JupyterLab. In a light
   * theme these would go from dark to light.
   */

  --jp-inverse-layout-color0: white;
  --jp-inverse-layout-color1: white;
  --jp-inverse-layout-color2: var(--md-grey-200);
  --jp-inverse-layout-color3: var(--md-grey-400);
  --jp-inverse-layout-color4: var(--md-grey-600);

  /* Brand/accent */

  --jp-brand-color0: var(--md-blue-700);
  --jp-brand-color1: var(--md-blue-500);
  --jp-brand-color2: var(--md-blue-300);
  --jp-brand-color3: var(--md-blue-100);
  --jp-brand-color4: var(--md-blue-50);
  --jp-accent-color0: var(--md-green-700);
  --jp-accent-color1: var(--md-green-500);
  --jp-accent-color2: var(--md-green-300);
  --jp-accent-color3: var(--md-green-100);

  /* State colors (warn, error, success, info) */

  --jp-warn-color0: var(--md-orange-700);
  --jp-warn-color1: var(--md-orange-500);
  --jp-warn-color2: var(--md-orange-300);
  --jp-warn-color3: var(--md-orange-100);
  --jp-error-color0: var(--md-red-700);
  --jp-error-color1: var(--md-red-500);
  --jp-error-color2: var(--md-red-300);
  --jp-error-color3: var(--md-red-100);
  --jp-success-color0: var(--md-green-700);
  --jp-success-color1: var(--md-green-500);
  --jp-success-color2: var(--md-green-300);
  --jp-success-color3: var(--md-green-100);
  --jp-info-color0: var(--md-cyan-700);
  --jp-info-color1: var(--md-cyan-500);
  --jp-info-color2: var(--md-cyan-300);
  --jp-info-color3: var(--md-cyan-100);

  /* Cell specific styles */

  --jp-cell-padding: 5px;
  --jp-cell-collapser-width: 8px;
  --jp-cell-collapser-min-height: 20px;
  --jp-cell-collapser-not-active-hover-opacity: 0.6;
  --jp-cell-editor-background: var(--jp-layout-color1);
  --jp-cell-editor-border-color: var(--md-grey-700);
  --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-cell-editor-active-background: var(--jp-layout-color0);
  --jp-cell-editor-active-border-color: var(--jp-brand-color1);
  --jp-cell-prompt-width: 64px;
  --jp-cell-prompt-font-family: var(--jp-code-font-family-default);
  --jp-cell-prompt-letter-spacing: 0;
  --jp-cell-prompt-opacity: 1;
  --jp-cell-prompt-not-active-opacity: 1;
  --jp-cell-prompt-not-active-font-color: var(--md-grey-300);

  /* A custom blend of MD grey and blue 600
   * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */
  --jp-cell-inprompt-font-color: #307fc1;

  /* A custom blend of MD grey and orange 600
   * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */
  --jp-cell-outprompt-font-color: #bf5b3d;

  /* Notebook specific styles */

  --jp-notebook-padding: 10px;
  --jp-notebook-select-background: var(--jp-layout-color1);
  --jp-notebook-multiselected-color: rgba(33, 150, 243, 0.24);

  /* The scroll padding is calculated to fill enough space at the bottom of the
  notebook to show one single-line cell (with appropriate padding) at the top
  when the notebook is scrolled all the way to the bottom. We also subtract one
  pixel so that no scrollbar appears if we have just one single-line cell in the
  notebook. This padding is to enable a 'scroll past end' feature in a notebook.
  */
  --jp-notebook-scroll-padding: calc(
    100% - var(--jp-code-font-size) * var(--jp-code-line-height) -
      var(--jp-code-padding) - var(--jp-cell-padding) - 1px
  );

  /* Rendermime styles */

  --jp-rendermime-error-background: rgba(244, 67, 54, 0.28);
  --jp-rendermime-table-row-background: var(--md-grey-900);
  --jp-rendermime-table-row-hover-background: rgba(3, 169, 244, 0.2);

  /* Dialog specific styles */

  --jp-dialog-background: rgba(0, 0, 0, 0.6);

  /* Console specific styles */

  --jp-console-padding: 10px;

  /* Toolbar specific styles */

  --jp-toolbar-border-color: var(--jp-border-color2);
  --jp-toolbar-micro-height: 8px;
  --jp-toolbar-background: var(--jp-layout-color1);
  --jp-toolbar-box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.8);
  --jp-toolbar-header-margin: 4px 4px 0 4px;
  --jp-toolbar-active-background: var(--jp-layout-color0);

  /* Statusbar specific styles */

  --jp-statusbar-height: 24px;

  /* Input field styles */

  --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300);
  --jp-input-active-background: var(--jp-layout-color0);
  --jp-input-hover-background: var(--jp-layout-color2);
  --jp-input-background: var(--md-grey-800);
  --jp-input-border-color: var(--jp-inverse-border-color);
  --jp-input-active-border-color: var(--jp-brand-color1);
  --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3);

  /* General editor styles */

  --jp-editor-selected-background: var(--jp-layout-color2);
  --jp-editor-selected-focused-background: rgba(33, 150, 243, 0.24);
  --jp-editor-cursor-color: var(--jp-ui-font-color0);

  /* Code mirror specific styles */

  --jp-mirror-editor-keyword-color: var(--md-green-500);
  --jp-mirror-editor-atom-color: var(--md-blue-300);
  --jp-mirror-editor-number-color: var(--md-green-400);
  --jp-mirror-editor-def-color: var(--md-blue-600);
  --jp-mirror-editor-variable-color: var(--md-grey-300);
  --jp-mirror-editor-variable-2-color: var(--md-blue-500);
  --jp-mirror-editor-variable-3-color: var(--md-green-600);
  --jp-mirror-editor-punctuation-color: var(--md-blue-400);
  --jp-mirror-editor-property-color: var(--md-blue-400);
  --jp-mirror-editor-operator-color: #a2f;
  --jp-mirror-editor-comment-color: #408080;
  --jp-mirror-editor-string-color: #ff7070;
  --jp-mirror-editor-string-2-color: var(--md-purple-300);
  --jp-mirror-editor-meta-color: #a2f;
  --jp-mirror-editor-qualifier-color: #555;
  --jp-mirror-editor-builtin-color: var(--md-green-600);
  --jp-mirror-editor-bracket-color: #997;
  --jp-mirror-editor-tag-color: var(--md-green-700);
  --jp-mirror-editor-attribute-color: var(--md-blue-700);
  --jp-mirror-editor-header-color: var(--md-blue-500);
  --jp-mirror-editor-quote-color: var(--md-green-300);
  --jp-mirror-editor-link-color: var(--md-blue-700);
  --jp-mirror-editor-error-color: #f00;
  --jp-mirror-editor-hr-color: #999;

  /*
    RTC user specific colors.
    These colors are used for the cursor, username in the editor,
    and the icon of the user.
  */

  --jp-collaborator-color1: #ad4a00;
  --jp-collaborator-color2: #7b6a00;
  --jp-collaborator-color3: #007e00;
  --jp-collaborator-color4: #008772;
  --jp-collaborator-color5: #0079b9;
  --jp-collaborator-color6: #8b45c6;
  --jp-collaborator-color7: #be208b;

  /* Vega extension styles */

  --jp-vega-background: var(--md-grey-400);

  /* Sidebar-related styles */

  --jp-sidebar-min-width: 250px;

  /* Search-related styles */

  --jp-search-toggle-off-opacity: 0.6;
  --jp-search-toggle-hover-opacity: 0.8;
  --jp-search-toggle-on-opacity: 1;
  --jp-search-selected-match-background-color: rgb(255, 225, 0);
  --jp-search-selected-match-color: black;
  --jp-search-unselected-match-background-color: var(
    --jp-inverse-layout-color0
  );
  --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0);

  /* scrollbar related styles. Supports every browser except Edge. */

  /* colors based on JetBrain's Darcula theme */

  --jp-scrollbar-background-color: #3f4244;
  --jp-scrollbar-thumb-color: 88, 96, 97; /* need to specify thumb color as an RGB triplet */
  --jp-scrollbar-endpad: 3px; /* the minimum gap between the thumb and the ends of a scrollbar */

  /* hacks for setting the thumb shape. These do nothing in Firefox */

  --jp-scrollbar-thumb-margin: 3.5px; /* the space in between the sides of the thumb and the track */
  --jp-scrollbar-thumb-radius: 9px; /* set to a large-ish value for rounded endcaps on the thumb */

  /* Icon colors that work well with light or dark backgrounds */
  --jp-icon-contrast-color0: var(--md-purple-600);
  --jp-icon-contrast-color1: var(--md-green-600);
  --jp-icon-contrast-color2: var(--md-pink-600);
  --jp-icon-contrast-color3: var(--md-blue-600);

  /* Button colors */
  --jp-accept-color-normal: var(--md-blue-700);
  --jp-accept-color-hover: var(--md-blue-800);
  --jp-accept-color-active: var(--md-blue-900);
  --jp-warn-color-normal: var(--md-red-700);
  --jp-warn-color-hover: var(--md-red-800);
  --jp-warn-color-active: var(--md-red-900);
  --jp-reject-color-normal: var(--md-grey-600);
  --jp-reject-color-hover: var(--md-grey-700);
  --jp-reject-color-active: var(--md-grey-800);

  /* File or activity icons and switch semantic variables */
  --jp-jupyter-icon-color: #f37626;
  --jp-notebook-icon-color: #f37626;
  --jp-json-icon-color: var(--md-orange-500);
  --jp-console-icon-background-color: var(--md-blue-500);
  --jp-console-icon-color: white;
  --jp-terminal-icon-background-color: var(--md-grey-200);
  --jp-terminal-icon-color: var(--md-grey-800);
  --jp-text-editor-icon-color: var(--md-grey-200);
  --jp-inspector-icon-color: var(--md-grey-200);
  --jp-switch-color: var(--md-grey-400);
  --jp-switch-true-position-color: var(--md-orange-700);
}
</style>
<style type="text/css">
/* Force rendering true colors when outputing to pdf */
* {
  -webkit-print-color-adjust: exact;
}

/* Misc */
a.anchor-link {
  display: none;
}

/* Input area styling */
.jp-InputArea {
  overflow: hidden;
}

.jp-InputArea-editor {
  overflow: hidden;
}

.cm-editor.cm-s-jupyter .highlight pre {
/* weird, but --jp-code-padding defined to be 5px but 4px horizontal padding is hardcoded for pre.cm-line */
  padding: var(--jp-code-padding) 4px;
  margin: 0;

  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;

}

.jp-OutputArea-output pre {
  line-height: inherit;
  font-family: inherit;
}

.jp-RenderedText pre {
  color: var(--jp-content-font-color1);
  font-size: var(--jp-code-font-size);
}

/* Hiding the collapser by default */
.jp-Collapser {
  display: none;
}

@page {
    margin: 0.5in; /* Margin for each printed piece of paper */
}

@media print {
  .jp-Cell-inputWrapper,
  .jp-Cell-outputWrapper {
    display: block;
  }
}
</style>
<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML-full,Safe"> </script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
    init_mathjax = function() {
        if (window.MathJax) {
        // MathJax loaded
            MathJax.Hub.Config({
                TeX: {
                    equationNumbers: {
                    autoNumber: "AMS",
                    useLabelIds: true
                    }
                },
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true,
                    processEnvironments: true
                },
                displayAlign: 'center',
                CommonHTML: {
                    linebreaks: {
                    automatic: true
                    }
                }
            });

            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        }
    }
    init_mathjax();
    </script>
<!-- End of mathjax configuration --><script type="module">
  document.addEventListener("DOMContentLoaded", async () => {
    const diagrams = document.querySelectorAll(".jp-Mermaid > pre.mermaid");
    // do not load mermaidjs if not needed
    if (!diagrams.length) {
      return;
    }
    const mermaid = (await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs")).default;
    const parser = new DOMParser();

    mermaid.initialize({
      maxTextSize: 100000,
      maxEdges: 100000,
      startOnLoad: false,
      fontFamily: window
        .getComputedStyle(document.body)
        .getPropertyValue("--jp-ui-font-family"),
      theme: document.querySelector("body[data-jp-theme-light='true']")
        ? "default"
        : "dark",
    });

    let _nextMermaidId = 0;

    function makeMermaidImage(svg) {
      const img = document.createElement("img");
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const svgEl = doc.querySelector("svg");
      const { maxWidth } = svgEl?.style || {};
      const firstTitle = doc.querySelector("title");
      const firstDesc = doc.querySelector("desc");

      img.setAttribute("src", `data:image/svg+xml,${encodeURIComponent(svg)}`);
      if (maxWidth) {
        img.width = parseInt(maxWidth);
      }
      if (firstTitle) {
        img.setAttribute("alt", firstTitle.textContent);
      }
      if (firstDesc) {
        const caption = document.createElement("figcaption");
        caption.className = "sr-only";
        caption.textContent = firstDesc.textContent;
        return [img, caption];
      }
      return [img];
    }

    async function makeMermaidError(text) {
      let errorMessage = "";
      try {
        await mermaid.parse(text);
      } catch (err) {
        errorMessage = `${err}`;
      }

      const result = document.createElement("details");
      result.className = 'jp-RenderedMermaid-Details';
      const summary = document.createElement("summary");
      summary.className = 'jp-RenderedMermaid-Summary';
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.innerText = text;
      pre.appendChild(code);
      summary.appendChild(pre);
      result.appendChild(summary);

      const warning = document.createElement("pre");
      warning.innerText = errorMessage;
      result.appendChild(warning);
      return [result];
    }

    async function renderOneMarmaid(src) {
      const id = `jp-mermaid-${_nextMermaidId++}`;
      const parent = src.parentNode;
      let raw = src.textContent.trim();
      const el = document.createElement("div");
      el.style.visibility = "hidden";
      document.body.appendChild(el);
      let results = null;
      let output = null;
      try {
        let { svg } = await mermaid.render(id, raw, el);
        svg = cleanMermaidSvg(svg);
        results = makeMermaidImage(svg);
        output = document.createElement("figure");
        results.map(output.appendChild, output);
      } catch (err) {
        parent.classList.add("jp-mod-warning");
        results = await makeMermaidError(raw);
        output = results[0];
      } finally {
        el.remove();
      }
      parent.classList.add("jp-RenderedMermaid");
      parent.appendChild(output);
    }


    /**
     * Post-process to ensure mermaid diagrams contain only valid SVG and XHTML.
     */
    function cleanMermaidSvg(svg) {
      return svg.replace(RE_VOID_ELEMENT, replaceVoidElement);
    }


    /**
     * A regular expression for all void elements, which may include attributes and
     * a slash.
     *
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Void_element
     *
     * Of these, only `<br>` is generated by Mermaid in place of `\n`,
     * but _any_ "malformed" tag will break the SVG rendering entirely.
     */
    const RE_VOID_ELEMENT =
      /<\s*(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)\s*([^>]*?)\s*>/gi;

    /**
     * Ensure a void element is closed with a slash, preserving any attributes.
     */
    function replaceVoidElement(match, tag, rest) {
      rest = rest.trim();
      if (!rest.endsWith('/')) {
        rest = `${rest} /`;
      }
      return `<${tag} ${rest}>`;
    }

    void Promise.all([...diagrams].map(renderOneMarmaid));
  });
</script>
<style>
  .jp-Mermaid:not(.jp-RenderedMermaid) {
    display: none;
  }

  .jp-RenderedMermaid {
    overflow: auto;
    display: flex;
  }

  .jp-RenderedMermaid.jp-mod-warning {
    width: auto;
    padding: 0.5em;
    margin-top: 0.5em;
    border: var(--jp-border-width) solid var(--jp-warn-color2);
    border-radius: var(--jp-border-radius);
    color: var(--jp-ui-font-color1);
    font-size: var(--jp-ui-font-size1);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .jp-RenderedMermaid figure {
    margin: 0;
    overflow: auto;
    max-width: 100%;
  }

  .jp-RenderedMermaid img {
    max-width: 100%;
  }

  .jp-RenderedMermaid-Details > pre {
    margin-top: 1em;
  }

  .jp-RenderedMermaid-Summary {
    color: var(--jp-warn-color2);
  }

  .jp-RenderedMermaid:not(.jp-mod-warning) pre {
    display: none;
  }

  .jp-RenderedMermaid-Summary > pre {
    display: inline-block;
    white-space: normal;
  }
</style>
<!-- End of mermaid configuration --></head>
<body class="jp-Notebook" data-jp-theme-light="false" data-jp-theme-name="JupyterLab Dark">
<main>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=1">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h1 id="documents">documents<a class="anchor-link" href="#documents"></a></h1>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=2">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="nb">open</span> <span class="n">file_system_operators</span>
<span class="nb">open</span> <span class="n">sm</span><span class="s1">'_operators</span>
<span class="nb">open</span> <span class="n">rust_operators</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=3">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">////</span> <span class="n">test</span>

<span class="nb">open</span> <span class="n">testing</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=4">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="types">types<a class="anchor-link" href="#types"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=5">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">types</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">rust</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">am</span><span class="s1">'.types ()</span>
    <span class="n">sm</span><span class="s1">'.types ()</span>
    <span class="n">file_system</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
    <span class="k">async</span><span class="o">.</span><span class="n">types</span> <span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=6">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="args">args<a class="anchor-link" href="#args"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=7">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">get_args</span> <span class="p">()</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="n">source_dir</span> <span class="o">=</span> <span class="s2">"source-dir"</span>
        <span class="n">dist_dir</span> <span class="o">=</span> <span class="s2">"dist-dir"</span>
        <span class="n">cache_dir</span> <span class="o">=</span> <span class="s2">"cache-dir"</span>
        <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"hangul-spec"</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=8">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="get_command">get_command<a class="anchor-link" href="#get_command"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=9">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">get_command</span> <span class="p">()</span> <span class="o">=</span>
    <span class="c1">##"command"</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">new_command</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .source_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'s'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .source_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .dist_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'d'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .dist_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .cache_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'c'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .cache_dir)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_arg</span> <span class="p">(</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">new_arg</span> <span class="c1">##(get_args () .hangul_spec)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_short</span> <span class="s1">'s'</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_long</span> <span class="c1">##(get_args () .hangul_spec)</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">arg_required</span> <span class="n">true</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=10">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="crowbook">crowbook<a class="anchor-link" href="#crowbook"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=11">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">crowbook</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"crowbook --single </span><span class="se">\\\"</span><span class="s1">{!dist_path}</span><span class="se">\\\"</span><span class="s1"> --output </span><span class="se">\\\"</span><span class="s1">{!output_path}</span><span class="se">\\\"</span><span class="s1"> --to {!ext} --set rendering.num_depth 6 html.css.add </span><span class="se">\\\\\\</span><span class="s1">"</span><span class="se">\'\'\'</span><span class="s1"> body {{ color: #e8e6e3; background-color: #202324; }} a {{ color: #989693; }} </span><span class="se">\'\'\'\\\\\\</span><span class="s1">""'</span>

    <span class="n">inl</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
            <span class="n">command</span>
            <span class="n">working_directory</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
        <span class="p">}</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

    <span class="k">if</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "ERROR" then</span>
        <span class="n">trace</span> <span class="n">Info</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.crowbook / result contains ERROR"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / result: {!result} / output_path: {!output_path} / {!_locals ()}"'</span>
        <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Error</span>
    <span class="k">else</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Ok</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=12">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="hangul">hangul<a class="anchor-link" href="#hangul"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=13">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">hangul</span> <span class="n">repository_root</span> <span class="n">hangul_spec</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">lines</span> <span class="o">=</span>
        <span class="n">dist_path</span>
        <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.split "</span><span class="se">\n</span><span class="s1">"</span>
        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span>
        <span class="o">|&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">map</span> <span class="n">sm</span><span class="s1">'.trim</span>
    <span class="n">inl</span> <span class="n">text</span> <span class="o">=</span>
        <span class="n">lines</span>
        <span class="o">|&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">filter</span> <span class="p">((</span><span class="o">&lt;&gt;.</span><span class="p">)</span> <span class="s2">""</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">seq</span><span class="o">.</span><span class="n">of_array</span><span class="s1">'</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.concat "</span><span class="se">\n</span><span class="s1">"</span>
        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"{!x}</span><span class="se">\n\n</span><span class="s1">"'</span>

    <span class="n">inl</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
            <span class="n">command</span> <span class="o">=</span>
                <span class="n">inl</span> <span class="n">hangulize_path</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">_exe</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">get_executable_suffix</span> <span class="p">()</span>
                    <span class="n">repository_root</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"../vault/deps/hangulize/cmd/hangulize/hangulize{!_exe}"'</span>
                <span class="err">$</span><span class="s1">'$"{!hangulize_path} {!hangul_spec}"'</span>
            <span class="n">stdin</span> <span class="o">=</span>
                <span class="n">fun</span> <span class="n">stdin</span> <span class="o">=&gt;</span>
                    <span class="n">inl</span> <span class="n">stdin</span> <span class="o">=</span>
                        <span class="n">stdin</span>
                        <span class="o">|&gt;</span> <span class="n">threading</span><span class="o">.</span><span class="n">arc_mutex_lock</span>
                        <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
                    <span class="n">text</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">stdin_write_all</span> <span class="n">stdin</span>
                <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
        <span class="p">}</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

    <span class="n">inl</span> <span class="n">result</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="n">inl</span> <span class="n">result</span> <span class="o">=</span>
            <span class="n">result</span>
            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.split "</span><span class="se">\n</span><span class="s1">"</span>
            <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span>
        <span class="n">inl</span> <span class="n">result_len</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.length</span>

        <span class="p">((</span><span class="s2">""</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="n">i32</span><span class="p">)),</span> <span class="n">lines</span><span class="p">)</span>
        <span class="o">||&gt;</span> <span class="n">am</span><span class="o">.</span><span class="n">fold</span> <span class="n">fun</span> <span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="n">x</span> <span class="o">=&gt;</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="s2">""</span>
            <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!acc}</span><span class="se">\n</span><span class="s1">"'</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="n">inl</span> <span class="n">acc</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">result_len</span>
                    <span class="n">then</span> <span class="n">acc</span>
                    <span class="k">else</span>
                        <span class="n">inl</span> <span class="n">line</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.index i</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">=</span> <span class="n">result_len</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!acc}{!line}"'</span>
                        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!acc}{!line}</span><span class="se">\n</span><span class="s1">"'</span>
                <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">fst</span>

    <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="n">output_path</span>

    <span class="n">trace</span> <span class="n">Info</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.hangul"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
            <span class="n">inl</span> <span class="n">result_len</span> <span class="p">:</span> <span class="n">i32</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.length</span>
            <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / result_len: {!result_len} / output_path: {!output_path} / {!_locals ()}"'</span>

    <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">Ok</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">result</span> <span class="p">(</span><span class="n">i32</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">i32</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=14">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="fix_paths">fix_paths<a class="anchor-link" href="#fix_paths"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=15">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="p">}</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_file_name</span>
    <span class="n">inl</span> <span class="n">cache_path</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span>
    <span class="n">inl</span> <span class="n">dist_path_no_ext</span> <span class="o">=</span>
        <span class="n">dist_path</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice 0 ((dist_path |&gt; sm'</span><span class="o">.</span><span class="n">last_index_of</span> <span class="s2">"."</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">inl</span> <span class="n">cache_path_no_ext</span> <span class="o">=</span>
        <span class="n">cache_path</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice 0 ((cache_path |&gt; sm'</span><span class="o">.</span><span class="n">last_index_of</span> <span class="s2">"."</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">inl</span> <span class="n">is_md</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.ends_with ".md"</span>
    <span class="n">inl</span> <span class="n">output_path</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">is_md</span> <span class="o">|&gt;</span> <span class="ow">not</span>
        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!dist_path}.{!ext}"'</span>
        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!dist_path_no_ext}.{!ext}"'</span>
    <span class="n">inl</span> <span class="n">output_cache_path</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">is_md</span> <span class="o">|&gt;</span> <span class="ow">not</span>
        <span class="n">then</span> <span class="err">$</span><span class="s1">'$"{!cache_path}.{!ext}"'</span>
        <span class="k">else</span> <span class="err">$</span><span class="s1">'$"{!cache_path_no_ext}.{!ext}"'</span>
    <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=16">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="files_fn">files_fn<a class="anchor-link" href="#files_fn"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=17">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">files_fn</span> <span class="p">{</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="p">}</span> <span class="n">fn</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span> <span class="o">=</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="n">ext</span> <span class="p">}</span>
    <span class="n">inl</span> <span class="n">equal</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_path</span>
            <span class="o">&amp;&amp;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_cache_path</span> <span class="n">then</span>
            <span class="n">inl</span> <span class="n">output_hash</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
            <span class="n">inl</span> <span class="n">output_cache_hash</span> <span class="o">=</span> <span class="n">output_cache_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
            <span class="n">output_hash</span> <span class="o">=</span> <span class="n">output_cache_hash</span>
        <span class="k">else</span> <span class="n">false</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal</span>
    <span class="n">then</span>
        <span class="k">match</span> <span class="n">fn</span> <span class="p">{</span> <span class="n">ext</span> <span class="n">dist_dir</span> <span class="n">dist_path</span> <span class="n">output_path</span> <span class="p">}</span> <span class="k">with</span>
        <span class="o">|</span> <span class="n">Ok</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="n">when</span> <span class="n">exit_code</span> <span class="o">&lt;&gt;.</span> <span class="mi">0</span> <span class="o">=&gt;</span>
            <span class="n">trace</span> <span class="n">Info</span>
                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.files_fn / error"'</span>
                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"exit_code: %A{!exit_code} / result: {!result} / {!_locals ()}"'</span>
            <span class="n">new_pair</span> <span class="n">output_path</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Error</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
        <span class="o">|</span> <span class="n">Error</span> <span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">=&gt;</span>
            <span class="n">new_pair</span> <span class="n">output_path</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Error</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
        <span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span>
            <span class="k">if</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span>
            <span class="n">then</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">output_cache_path</span>
            <span class="k">else</span> <span class="n">failwith</span> <span class="err">$</span><span class="s1">'$"documents.files_fn / {!output_path} should exist"'</span>
            <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">|&gt;</span> <span class="n">Some</span>
    <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=18">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="run">run<a class="anchor-link" href="#run"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=19">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">let</span> <span class="n">run</span> <span class="p">{</span> <span class="n">source_dir</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="n">hangul_spec</span> <span class="p">}</span>
    <span class="p">:</span> <span class="k">async</span><span class="o">.</span><span class="n">future_pin</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' (am'</span><span class="o">.</span><span class="n">vec</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' (pair string (am'</span><span class="o">.</span><span class="n">vec</span> <span class="p">(</span><span class="n">optionm</span><span class="s1">'.option'</span> <span class="p">(</span><span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">' string (pair string string))))) sm'</span><span class="o">.</span><span class="n">std_string</span><span class="p">))</span> <span class="n">sm</span><span class="s1">'.std_string) =</span>

    <span class="n">inl</span> <span class="n">repository_root</span> <span class="o">=</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_repository_root</span> <span class="p">()</span>

    <span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>
    <span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>
    <span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>
    
    <span class="n">trace</span> <span class="n">Debug</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"source_dir: {!source_dir} / dist_dir: {!dist_dir} / cache_dir: {!cache_dir} / hangul_spec: %A{!hangul_spec} / {!_locals ()}"'</span>

    <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
        <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
            <span class="n">dist_dir</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">new_walk_dir</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">walk_dir_filter</span> <span class="n">fun</span> <span class="n">entry</span> <span class="o">=&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">future_init_send</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span> <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">entry</span>
                <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_file_type</span>
                <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">await_send</span>
                <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">map_error</span><span class="s1">' sm'</span><span class="o">.</span><span class="n">format</span><span class="s1">'</span>
                <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unbox</span>
                <span class="o">|&gt;</span> <span class="n">function</span>
                    <span class="o">|</span> <span class="n">Ok</span> <span class="n">file_type</span> <span class="n">when</span> <span class="n">file_type</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_type_is_dir</span> <span class="o">=&gt;</span>
                        <span class="n">file_system</span><span class="o">.</span><span class="n">Ignore</span>
                    <span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span>
                        <span class="n">inl</span> <span class="n">path</span> <span class="o">=</span>
                            <span class="n">entry</span>
                            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_path</span>
                            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                            <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.ends_with ".md" |&gt; not) || (path |&gt; sm'</span><span class="o">.</span><span class="n">ends_with</span> <span class="s2">".hangul.md"</span><span class="p">)</span>
                        <span class="n">then</span> <span class="n">file_system</span><span class="o">.</span><span class="n">Ignore</span>
                        <span class="k">else</span> <span class="n">file_system</span><span class="o">.</span><span class="n">Continue</span>
            <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">stream_filter_map</span> <span class="n">fun</span> <span class="n">entry</span> <span class="o">=&gt;</span>
                <span class="k">match</span> <span class="n">entry</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">map_error</span><span class="s1">' sm'</span><span class="o">.</span><span class="n">format</span><span class="s1">' |&gt; resultm.unbox with</span>
                <span class="o">|</span> <span class="n">Ok</span> <span class="n">entry</span> <span class="o">=&gt;</span>
                    <span class="n">entry</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">dir_entry_path</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">Some</span>
                <span class="o">|</span> <span class="n">Error</span> <span class="n">error</span> <span class="o">=&gt;</span>
                    <span class="n">trace</span> <span class="n">Critical</span>
                        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / stream_filter_map"'</span>
                        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"error: {!error} / {!_locals ()}"'</span>
                    <span class="kc">None</span>
                <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>

        <span class="n">trace</span> <span class="n">Debug</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">files_len</span> <span class="o">=</span> <span class="n">files</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_len</span>
                <span class="err">$</span><span class="s1">'$"files_len: {!files_len} / {!_locals ()}"'</span>

        <span class="n">inl</span> <span class="n">result</span> <span class="o">=</span>
            <span class="n">files</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">into_par_iter</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_map</span> <span class="n">fun</span> <span class="n">file</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">file</span> <span class="o">=</span> <span class="n">file</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_full_path</span>

                <span class="n">inl</span> <span class="n">relative_path</span> <span class="o">=</span>
                    <span class="n">file</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.to_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">new_path_buf</span>
                    <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">path_buf_display</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format'</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.replace dist_dir ""</span>
                    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.replace "</span><span class="se">\\</span><span class="s1">" "/"</span>
                    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$".</span><span class="si">{!s}</span><span class="s1">"'</span>

                <span class="n">inl</span> <span class="n">file</span> <span class="o">=</span> <span class="n">file</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">normalize_path</span>

                <span class="n">inl</span> <span class="n">real_path</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">origin_hash_exit_code</span><span class="p">,</span> <span class="n">origin_hash</span> <span class="o">=</span>
                    <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"git ls-tree --format=</span><span class="se">\'</span><span class="si">%%</span><span class="s1">(objectname)</span><span class="se">\'</span><span class="s1"> origin/gh-pages </span><span class="se">\\</span><span class="s1">"{!real_path}</span><span class="se">\\</span><span class="s1">""'</span>
                        <span class="n">working_directory</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                    <span class="p">}</span>
                    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>
                
                <span class="n">inl</span> <span class="n">dist_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">local_git_hash_exit_code</span><span class="p">,</span> <span class="n">local_git_hash</span> <span class="o">=</span>
                    <span class="n">runtime</span><span class="o">.</span><span class="n">execution_options</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">x</span> <span class="k">with</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="err">$</span><span class="s1">'$"git hash-object </span><span class="se">\\</span><span class="s1">"{!dist_path}</span><span class="se">\\</span><span class="s1">""'</span>
                        <span class="n">working_directory</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">Some</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                    <span class="p">}</span>
                    <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">execute_with_options</span>

                <span class="n">inl</span> <span class="n">cache_path</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">relative_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">standardize_path</span>

                <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
                    <span class="n">inl</span> <span class="n">files_fn</span> <span class="o">=</span> <span class="n">files_fn</span> <span class="p">{</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="p">}</span>
                    <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="s2">"hangul.md"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">hangul</span> <span class="n">repository_root</span> <span class="n">hangul_spec</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                    <span class="p">]</span>

                    <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="p">}</span> <span class="o">=</span> <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">dist_path</span> <span class="n">cache_dir</span> <span class="n">ext</span> <span class="o">=</span> <span class="s2">"hangul.md"</span> <span class="p">}</span>

                    <span class="n">inl</span> <span class="n">files</span><span class="s1">' = [</span>
                        <span class="s2">"html"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"pdf"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"epub"</span><span class="p">,</span> <span class="n">dist_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"html"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"pdf"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                        <span class="s2">"epub"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">crowbook</span> <span class="o">|&gt;</span> <span class="n">files_fn</span>
                    <span class="p">]</span>

                    <span class="p">[</span> <span class="n">files</span><span class="p">;</span> <span class="n">files</span><span class="s1">' ]</span>

                <span class="n">inl</span> <span class="n">files</span><span class="s1">' =</span>
                    <span class="k">if</span> <span class="n">origin_hash</span> <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains local_git_hash |&gt; not then</span>
                        <span class="n">inl</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">get</span>
                        <span class="n">inl</span> <span class="n">hash2</span> <span class="o">=</span>
                            <span class="k">if</span> <span class="n">cache_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span>
                            <span class="n">then</span> <span class="n">cache_path</span> <span class="o">|&gt;</span> <span class="n">crypto</span><span class="o">.</span><span class="n">get_file_hash</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">ok</span>
                            <span class="k">else</span> <span class="kc">None</span>

                        <span class="k">if</span> <span class="n">hash2</span> <span class="o">=</span> <span class="kc">None</span> <span class="o">||</span> <span class="n">hash1</span> <span class="o">&lt;&gt;.</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="n">then</span>
                            <span class="n">trace</span> <span class="n">Info</span>
                                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / par_map / origin_hash |&gt; sm</span><span class="se">\'</span><span class="s1">.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value)"'</span>
                                <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"file: {!file} / real_path: {!real_path} / relative_path: {!relative_path} / origin_hash_exit_code: {!origin_hash_exit_code} / origin_hash: {!origin_hash} / local_git_hash_exit_code: {!local_git_hash_exit_code} / local_git_hash: {!local_git_hash} / hash1: {!hash1} / hash2: %A{!hash2} / dist_path: {!dist_path} / cache_path: {!cache_path} / {!_locals ()}"'</span>
                            <span class="n">dist_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">cache_path</span>
                            <span class="n">files</span>
                        <span class="k">else</span> <span class="p">[]</span>
                    <span class="k">else</span> <span class="p">[]</span>
                    
                <span class="n">inl</span> <span class="n">files</span><span class="s1">' =</span>
                    <span class="k">if</span> <span class="n">files</span><span class="s1">' &lt;&gt; []</span>
                    <span class="n">then</span> <span class="n">files</span><span class="s1">'</span>
                    <span class="k">else</span>
                        <span class="n">files</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="o">.</span><span class="n">map</span> <span class="n">fun</span> <span class="n">files</span> <span class="o">=&gt;</span>
                            <span class="n">files</span>
                            <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.filter fun ext, path, fn =&gt;</span>
                                <span class="n">inl</span> <span class="p">{</span> <span class="n">output_path</span> <span class="n">output_cache_path</span> <span class="p">}</span> <span class="o">=</span>
                                    <span class="n">fix_paths</span> <span class="p">{</span> <span class="n">cache_dir</span> <span class="n">dist_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span> <span class="n">ext</span> <span class="p">}</span>
                                <span class="k">if</span> <span class="n">output_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="o">|&gt;</span> <span class="ow">not</span> <span class="n">then</span>
                                    <span class="k">if</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_exists</span> <span class="n">output_cache_path</span> <span class="n">then</span>
                                        <span class="n">trace</span> <span class="n">Info</span>
                                            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run / par_map / files</span><span class="se">\'</span><span class="s1"> = [] / listm.iter"'</span>
                                            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"output_path: %A{!output_path} / output_cache_path: {!output_cache_path} / {!_locals ()}"'</span>
                                        <span class="n">output_cache_path</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">file_copy</span> <span class="n">output_path</span>
                                        <span class="n">false</span>
                                    <span class="k">else</span> <span class="n">true</span>
                                <span class="k">else</span> <span class="n">true</span>

                <span class="n">inl</span> <span class="n">files</span> <span class="o">=</span>
                    <span class="n">files</span><span class="s1">'</span>
                    <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.box</span>
                    <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.to_array'</span>
                    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="p">(</span><span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span>
                    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
                    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_collect fun files =&gt;</span>
                        <span class="n">files</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.box</span>
                        <span class="o">|&gt;</span> <span class="n">listm</span><span class="s1">'.to_array'</span>
                        <span class="o">|&gt;</span> <span class="n">fun</span> <span class="p">(</span><span class="n">a</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="n">i32</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span>
                        <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">into_par_iter</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_map</span> <span class="n">fun</span> <span class="n">ext</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=&gt;</span>
                            <span class="n">fn</span> <span class="n">path</span> <span class="n">ext</span> <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.box</span>
                        <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_collect</span>

                <span class="p">(</span><span class="n">new_pair</span> <span class="n">file</span> <span class="n">files</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="p">:</span> <span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string</span>
            <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">par_collect</span>

        <span class="n">trace</span> <span class="n">Debug</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'"documents.run"'</span>
            <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span>
                <span class="n">inl</span> <span class="n">result_len</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_len</span>
                <span class="err">$</span><span class="s1">'$"result_len: {!result_len} / {!_locals ()}"'</span>

        <span class="n">result</span> <span class="o">|&gt;</span> <span class="n">Ok</span> <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span>
    <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">future_init</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=20">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">////</span> <span class="n">test</span>
<span class="o">////</span> <span class="n">print_code</span><span class="o">=</span><span class="n">false</span>
<span class="o">///</span><span class="err">!</span> <span class="n">rust</span>

<span class="n">types</span> <span class="p">()</span>
<span class="n">inl</span> <span class="n">repository_root</span> <span class="o">=</span> <span class="n">file_system</span><span class="o">.</span><span class="n">get_repository_root</span> <span class="p">()</span>
<span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span> <span class="n">repository_root</span> <span class="o">&lt;/&gt;</span> <span class="s2">"../vault/target/documents"</span>
<span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="s2">"dist"</span>
<span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="s2">"cache"</span>
<span class="n">inl</span> <span class="n">file_name_no_ext</span> <span class="o">=</span> <span class="s2">"test"</span>
<span class="n">inl</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">join</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.md"'</span>

<span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>

<span class="n">source_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>
<span class="n">cache_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>

<span class="n">inl</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">"# a</span><span class="se">\n\n</span><span class="s2">## b</span><span class="se">\n\n</span><span class="s2">---</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">abc</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n\n</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">"</span>
<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">source_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>
<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>

<span class="n">inl</span> <span class="n">html_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.html"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">pdf_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.pdf"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">epub_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name}.epub"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_html_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.html"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_pdf_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.pdf"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>
<span class="n">inl</span> <span class="n">hangul_epub_path</span> <span class="o">=</span> <span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="err">$</span><span class="s1">'$"{!file_name_no_ext}.hangul.md.epub"'</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span>

<span class="n">run</span> <span class="p">{</span>
    <span class="n">source_dir</span>
    <span class="n">dist_dir</span>
    <span class="n">cache_dir</span>
    <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"por-br"</span>
<span class="p">}</span>
<span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
<span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="p">(</span>
    <span class="p">;[</span>
        <span class="n">Ok</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span><span class="p">),</span>
            <span class="p">;[</span>
                <span class="n">hangul_path</span>
                <span class="n">html_path</span>
                <span class="n">pdf_path</span>
                <span class="n">epub_path</span>
                <span class="n">hangul_html_path</span>
                <span class="n">hangul_pdf_path</span>
                <span class="n">hangul_epub_path</span>
            <span class="p">]</span>
            <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec |&gt; am'</span><span class="o">.</span><span class="n">vec_map</span> <span class="p">(</span><span class="n">Ok</span> <span class="o">&gt;&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span> <span class="o">&gt;&gt;</span> <span class="n">Some</span> <span class="o">&gt;&gt;</span> <span class="n">optionm</span><span class="s1">'.box)</span>
            <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string))</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_map resultm.box</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="p">:</span> <span class="n">_</span> <span class="p">(</span><span class="n">_</span> <span class="n">_</span> <span class="n">sm</span><span class="s1">'.std_string)</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="p">)</span>

<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">directory_delete</span> <span class="n">true</span>
<span class="n">dist_dir</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">create_directory</span><span class="s1">' |&gt; ignore</span>

<span class="n">text</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">write_all_text</span> <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span><span class="p">)</span>

<span class="n">run</span> <span class="p">{</span>
    <span class="n">source_dir</span> <span class="o">=</span> <span class="n">source_dir</span>
    <span class="n">dist_dir</span> <span class="o">=</span> <span class="n">dist_dir</span>
    <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>
    <span class="n">hangul_spec</span> <span class="o">=</span> <span class="s2">"por-br"</span>
<span class="p">}</span>
<span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
<span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="p">(</span>
    <span class="p">;[</span>
        <span class="n">Ok</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">dist_dir</span> <span class="o">&lt;/&gt;</span> <span class="n">file_name</span> <span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">absolute_path</span><span class="p">),</span>
            <span class="p">;[</span>
            <span class="p">]</span>
            <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec |&gt; am'</span><span class="o">.</span><span class="n">vec_map</span> <span class="p">((</span><span class="n">optionm</span><span class="o">.</span><span class="n">map</span> <span class="n">resultm</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">optionm</span><span class="s1">'.box)</span>
        <span class="p">)</span>
    <span class="p">]</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.to_vec</span>
    <span class="o">|&gt;</span> <span class="n">am</span><span class="s1">'.vec_map resultm.box</span>
    <span class="o">|&gt;</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">=&gt;</span>
        <span class="n">x</span> <span class="p">:</span> <span class="n">am</span><span class="s1">'.vec (</span>
            <span class="n">resultm</span><span class="o">.</span><span class="n">result</span><span class="s1">'</span>
                <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">am</span><span class="s1">'.vec (optionm'</span><span class="o">.</span><span class="n">option</span><span class="s1">' (resultm.result'</span> <span class="n">string</span> <span class="n">string</span><span class="p">)))</span>
                <span class="n">sm</span><span class="s1">'.std_string</span>
        <span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.format_debug'</span>
    <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
<span class="p">)</span>

<span class="n">hangul_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="s2">"# </span><span class="se">\n\n</span><span class="s2">## </span><span class="se">\n\n</span><span class="s2">---</span><span class="se">\n\n</span><span class="s2"></span><span class="se">\n</span><span class="s2"></span><span class="se">\n\n</span><span class="s2"></span><span class="se">\n\n</span><span class="s2"></span><span class="se">\n</span><span class="s2">"</span>

<span class="n">html_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "&lt;p class = </span><span class="se">\"</span><span class="s1">rule</span><span class="se">\"</span><span class="s1">&gt;***&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;p id = </span><span class="se">\"</span><span class="s1">para-1</span><span class="se">\"</span><span class="s1">&gt;abc abc&lt;/p&gt;"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">pdf_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "%PDF-1.5"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">epub_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "application/epub+zip"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_html_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_text</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.contains "&lt;p class = </span><span class="se">\"</span><span class="s1">rule</span><span class="se">\"</span><span class="s1">&gt;***&lt;/p&gt;</span><span class="se">\n</span><span class="s1">&lt;p id = </span><span class="se">\"</span><span class="s1">para-1</span><span class="se">\"</span><span class="s1">&gt; &lt;/p&gt;"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_pdf_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "%PDF-1.5"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>

<span class="n">hangul_epub_path</span>
<span class="o">|&gt;</span> <span class="n">file_system</span><span class="o">.</span><span class="n">read_all_bytes</span>
<span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.slice_contains "application/epub+zip"</span>
<span class="o">|&gt;</span> <span class="n">_assert_eq</span> <span class="n">true</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>00:00:14 critical #1 Eval.run / cargo fmt error / exitCode: 1 / cargoFmtResult: [Failed to find targets]
[This utility formats all bin and lib files of the current crate using rustfmt.]
[]
[Usage: cargo fmt [OPTIONS] [-- &lt;rustfmt_options&gt;...]]
[]
[Arguments:]
[  [rustfmt_options]...  Options passed to rustfmt]
[]
[Options:]
[  -q, --quiet]
[          No output printed to stdout]
[  -v, --verbose]
[          Use verbose output]
[      --version]
[          Print rustfmt version and exit]
[  -p, --package &lt;package&gt;...]
[          Specify package to format]
[      --manifest-path &lt;manifest-path&gt;]
[          Specify path to Cargo.toml]
[      --message-format &lt;message-format&gt;]
[          Specify message-format: short|json|human]
[      --all]
[          Format all packages, and also their local path-based dependencies]
[      --check]
[          Run rustfmt in check mode]
[  -h, --help]
[          Print help]
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #1 file_system.create_directory / dir: /home/runner/work/vault/polyglot/../vault/target/documents
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #2 file_system.create_directory / dir: /home/runner/work/vault/polyglot/../vault/target/documents/dist
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #3 file_system.create_directory / dir: /home/runner/work/vault/polyglot/../vault/target/documents/cache
03:10:07 <span class="ansi-blue-intense-fg">  debug</span> #4 documents.run / source_dir: /home/runner/work/vault/vault/target/documents / dist_dir: /home/runner/work/vault/vault/target/documents/dist / cache_dir: /home/runner/work/vault/vault/target/documents/cache / hangul_spec: "por-br"
03:10:07 <span class="ansi-blue-intense-fg">  debug</span> #5 documents.run / files_len: 1
03:10:07 <span class="ansi-blue-intense-fg">  debug</span> #6 execute_with_options / file_name: git / arguments: ["ls-tree", "--format='%(objectname)'", "origin/gh-pages", "/home/runner/work/vault/vault/target/documents/test.md"] / options: (None, "git ls-tree --format='%(objectname)' origin/gh-pages "/home/runner/work/vault/vault/target/documents/test.md"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents"))
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #7 &gt; fatal: Not a valid object name origin/gh-pages
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #8 execute_with_options / exit_code: 128 / std_trace.Length: 46
03:10:07 <span class="ansi-blue-intense-fg">  debug</span> #9 execute_with_options / file_name: git / arguments: ["hash-object", "/home/runner/work/vault/vault/target/documents/dist/test.md"] / options: (None, "git hash-object "/home/runner/work/vault/vault/target/documents/dist/test.md"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #10 &gt; ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b
03:10:07 <span class="ansi-black-intense-fg">verbose</span> #11 execute_with_options / exit_code: 0 / std_trace.Length: 40
03:10:07 <span class="ansi-blue-intense-fg">  debug</span> #12 execute_with_options / file_name: pwsh / arguments: ["-c", "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/dist/test.md\" -Algorithm SHA256).Hash"] / options: (None, "pwsh -c "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/dist/test.md\" -Algorithm SHA256).Hash"", Array(MutCell([])), None, None, None)
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #13 &gt; F87EE09EC1DADC95E06E23BEF39AA3185381D285BB9CA41A8A112061A6F504EC
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #14 execute_with_options / exit_code: 0 / std_trace.Length: 64
03:10:08 <span class="ansi-green-intense-fg">   info</span> #15 documents.run / par_map / origin_hash |&gt; sm'.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value) / file: /home/runner/work/vault/vault/target/documents/dist/test.md / real_path: /home/runner/work/vault/vault/target/documents/test.md / relative_path: ./test.md / origin_hash_exit_code: 128 / origin_hash: fatal: Not a valid object name origin/gh-pages / local_git_hash_exit_code: 0 / local_git_hash: ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b / hash1: F87EE09EC1DADC95E06E23BEF39AA3185381D285BB9CA41A8A112061A6F504EC / hash2: US0_1 / dist_path: /home/runner/work/vault/vault/target/documents/dist/test.md / cache_path: /home/runner/work/vault/vault/target/documents/cache/test.md
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #16 execute_with_options / file_name: /home/runner/work/vault/polyglot/../vault/deps/hangulize/cmd/hangulize/hangulize / arguments: ["por-br"] / options: (None, "/home/runner/work/vault/polyglot/../vault/deps/hangulize/cmd/hangulize/hangulize por-br", Array(MutCell([])), None, Some(fable_library_rust::module_3bd9ae6a::FuncType::Func1&lt;alloc::sync::Arc&lt;std::sync::mutex::Mutex&lt;std::process::ChildStdin&gt;&gt;, ()&gt;), None)
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #17 &gt; # 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #18 &gt; ## 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #19 &gt; ---
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #20 &gt; 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #21 &gt; 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #22 &gt; 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #23 &gt; 
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #24 execute_with_options / exit_code: 0 / std_trace.Length: 28
03:10:08 <span class="ansi-green-intense-fg">   info</span> #25 documents.hangul / exit_code: 0 / result_len: 34 / output_path: /home/runner/work/vault/vault/target/documents/dist/test.hangul.md
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #26 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.md.html", "--to", "html", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.md.html" --to html --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #26 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.md.pdf", "--to", "pdf", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.md.pdf" --to pdf --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #27 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.pdf", "--to", "pdf", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.pdf" --to pdf --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #28 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.html", "--to", "html", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.html" --to html --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #30 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #30 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #31 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #32 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #33 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #34 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #35 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.md.epub", "--to", "epub", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.md.epub" --to epub --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-blue-intense-fg">  debug</span> #36 execute_with_options / file_name: crowbook / arguments: ["--single", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md", "--output", "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.epub", "--to", "epub", "--set", "rendering.num_depth", "6", "html.css.add", "''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''"] / options: (None, "crowbook --single "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md" --output "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.epub" --to epub --set rendering.num_depth 6 html.css.add \"''' body { color: #e8e6e3; background-color: #202324; } a { color: #989693; } '''\"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #37 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #38 &gt; CROWBOOK 0.16.1
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #39 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:08 <span class="ansi-black-intense-fg">verbose</span> #40 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #41 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #42 execute_with_options / exit_code: 0 / std_trace.Length: 15
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #43 documents.run / result_len: 1
assert_eq / actual: "[Ok(("/home/runner/work/vault/vault/target/documents/dist/test.md", [Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.html")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.pdf")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.epub")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.html")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.pdf")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.epub"))]))]" / expected: "[Ok(("/home/runner/work/vault/vault/target/documents/dist/test.md", [Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.html")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.pdf")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.md.epub")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.html")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.pdf")), Some(Ok("/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.epub"))]))]"
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #44 file_system.create_directory / dir: /home/runner/work/vault/polyglot/../vault/target/documents/dist
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #45 documents.run / source_dir: /home/runner/work/vault/vault/target/documents / dist_dir: /home/runner/work/vault/vault/target/documents/dist / cache_dir: /home/runner/work/vault/vault/target/documents/cache / hangul_spec: "por-br"
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #46 documents.run / files_len: 1
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #47 execute_with_options / file_name: git / arguments: ["ls-tree", "--format='%(objectname)'", "origin/gh-pages", "/home/runner/work/vault/vault/target/documents/test.md"] / options: (None, "git ls-tree --format='%(objectname)' origin/gh-pages "/home/runner/work/vault/vault/target/documents/test.md"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents"))
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #48 &gt; fatal: Not a valid object name origin/gh-pages
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #49 execute_with_options / exit_code: 128 / std_trace.Length: 46
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #50 execute_with_options / file_name: git / arguments: ["hash-object", "/home/runner/work/vault/vault/target/documents/dist/test.md"] / options: (None, "git hash-object "/home/runner/work/vault/vault/target/documents/dist/test.md"", Array(MutCell([])), None, None, Some("/home/runner/work/vault/vault/target/documents/dist"))
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #51 &gt; ba0ba7eb68b2a508ff0525bcbb91bd5ebc95e71b
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #52 execute_with_options / exit_code: 0 / std_trace.Length: 40
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #53 execute_with_options / file_name: pwsh / arguments: ["-c", "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/dist/test.md\" -Algorithm SHA256).Hash"] / options: (None, "pwsh -c "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/dist/test.md\" -Algorithm SHA256).Hash"", Array(MutCell([])), None, None, None)
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #54 &gt; F87EE09EC1DADC95E06E23BEF39AA3185381D285BB9CA41A8A112061A6F504EC
03:10:09 <span class="ansi-black-intense-fg">verbose</span> #55 execute_with_options / exit_code: 0 / std_trace.Length: 64
03:10:09 <span class="ansi-blue-intense-fg">  debug</span> #56 execute_with_options / file_name: pwsh / arguments: ["-c", "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/cache/test.md\" -Algorithm SHA256).Hash"] / options: (None, "pwsh -c "(Get-FileHash \"/home/runner/work/vault/vault/target/documents/cache/test.md\" -Algorithm SHA256).Hash"", Array(MutCell([])), None, None, None)
03:10:10 <span class="ansi-black-intense-fg">verbose</span> #57 &gt; F87EE09EC1DADC95E06E23BEF39AA3185381D285BB9CA41A8A112061A6F504EC
03:10:10 <span class="ansi-black-intense-fg">verbose</span> #58 execute_with_options / exit_code: 0 / std_trace.Length: 64
03:10:10 <span class="ansi-green-intense-fg">   info</span> #59 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.epub" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.hangul.md.epub
03:10:10 <span class="ansi-green-intense-fg">   info</span> #60 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.pdf" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.hangul.md.pdf
03:10:10 <span class="ansi-green-intense-fg">   info</span> #61 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md.html" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.hangul.md.html
03:10:10 <span class="ansi-green-intense-fg">   info</span> #62 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.md.epub" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.md.epub
03:10:10 <span class="ansi-green-intense-fg">   info</span> #63 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.md.pdf" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.md.pdf
03:10:10 <span class="ansi-green-intense-fg">   info</span> #64 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.md.html" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.md.html
03:10:10 <span class="ansi-green-intense-fg">   info</span> #65 documents.run / par_map / files' = [] / listm.iter / output_path: "/home/runner/work/vault/vault/target/documents/dist/test.hangul.md" / output_cache_path: /home/runner/work/vault/vault/target/documents/cache/test.hangul.md
03:10:10 <span class="ansi-blue-intense-fg">  debug</span> #66 documents.run / result_len: 1
assert_eq / actual: "[Ok(("/home/runner/work/vault/vault/target/documents/dist/test.md", []))]" / expected: "[Ok(("/home/runner/work/vault/vault/target/documents/dist/test.md", []))]"
assert_eq / actual: "# 

## 

---







" / expected: "# 

## 

---







"
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
assert_eq / actual: true / expected: true
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=21">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="tests">tests<a class="anchor-link" href="#tests"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=22">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="n">inl</span> <span class="n">tests</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">rust</span><span class="o">.</span><span class="n">run_tests</span> <span class="p">[</span>
        <span class="s2">"verify_app"</span><span class="p">,</span> <span class="n">fun</span> <span class="n">_</span> <span class="o">=&gt;</span>
            <span class="n">get_command</span> <span class="p">()</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_debug_assert</span>
    <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>()

</pre>
</div>
</div>
</div>
</div>
</div>
<div class="jp-Cell jp-MarkdownCell jp-Notebook-cell" id="cell-id=23">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea"><div class="jp-InputPrompt jp-InputArea-prompt">
</div><div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput" data-mime-type="text/markdown">
<h2 id="main">main<a class="anchor-link" href="#main"></a></h2>
</div>
</div>
</div>
</div><div class="jp-Cell jp-CodeCell jp-Notebook-cell" id="cell-id=24">
<div class="jp-Cell-inputWrapper" tabindex="0">
<div class="jp-Collapser jp-InputCollapser jp-Cell-inputCollapser">
</div>
<div class="jp-InputArea jp-Cell-inputArea">
<div class="jp-InputPrompt jp-InputArea-prompt">In[]:</div>
<div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor" data-type="inline">
<div class="cm-editor cm-s-jupyter">
<div class="highlight hl-ipython3"><pre><span></span><span class="o">///</span><span class="err">!</span> 

<span class="n">inl</span> <span class="n">main</span> <span class="p">(</span><span class="n">args</span> <span class="p">:</span> <span class="n">array_base</span> <span class="n">string</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">inl</span> <span class="n">trace_state</span> <span class="o">=</span> <span class="n">get_trace_state</span> <span class="p">()</span>
    <span class="n">inl</span> <span class="n">trace_level</span> <span class="o">=</span> <span class="n">trace_state</span><span class="o">.</span><span class="n">level</span>
    <span class="n">trace_level</span> <span class="o">&lt;-</span> <span class="n">Info</span>

    <span class="n">trace</span> <span class="n">Info</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"documents.main"'</span>
        <span class="n">fun</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="s1">'$"args: {!args} / {!_locals ()}"'</span>

    <span class="n">inl</span> <span class="n">command</span> <span class="o">=</span> <span class="n">get_command</span> <span class="p">()</span>
    <span class="n">inl</span> <span class="n">arg_matches</span> <span class="o">=</span> <span class="n">command</span> <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">command_get_matches</span>

    <span class="n">inl</span> <span class="n">source_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">source_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">dist_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">dist_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">cache_dir</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">cache_dir</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>

    <span class="n">inl</span> <span class="n">hangul_spec</span> <span class="o">=</span>
        <span class="n">arg_matches</span>
        <span class="o">|&gt;</span> <span class="n">runtime</span><span class="o">.</span><span class="n">matches_get_one</span> <span class="p">(</span><span class="n">get_args</span> <span class="p">()</span> <span class="o">.</span><span class="n">hangul_spec</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="s1">'.unbox</span>
        <span class="o">|&gt;</span> <span class="n">optionm</span><span class="o">.</span><span class="n">value</span>
        <span class="o">|&gt;</span> <span class="n">sm</span><span class="s1">'.from_std_string</span>
    
    <span class="n">run</span> <span class="p">{</span> <span class="n">source_dir</span> <span class="n">dist_dir</span> <span class="n">cache_dir</span> <span class="n">hangul_spec</span> <span class="p">}</span>
    <span class="o">|&gt;</span> <span class="k">async</span><span class="o">.</span><span class="n">block_on</span>
    <span class="o">|&gt;</span> <span class="n">resultm</span><span class="o">.</span><span class="n">unwrap</span><span class="s1">'</span>
    <span class="o">|&gt;</span> <span class="n">ignore</span>

    <span class="mi">0</span><span class="n">i32</span>

<span class="n">inl</span> <span class="n">main</span> <span class="p">()</span> <span class="o">=</span>
    <span class="n">types</span> <span class="p">()</span>
    <span class="err">$</span><span class="s2">"let tests () = !tests ()"</span> <span class="p">:</span> <span class="p">()</span>
    <span class="err">$</span><span class="s2">"let main args = !main args"</span> <span class="p">:</span> <span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="jp-Cell-outputWrapper">
<div class="jp-Collapser jp-OutputCollapser jp-Cell-outputCollapser">
</div>
<div class="jp-OutputArea jp-Cell-outputArea">
<div class="jp-OutputArea-child">
<div class="jp-OutputPrompt jp-OutputArea-prompt"></div>
<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain" tabindex="0">
<pre>.fsx:
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Func0&lt;$0&gt;")&gt;]
#endif
type Func0&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Func1&lt;$0, $1&gt;")&gt;]
#endif
type Func0&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Box&lt;$0&gt;")&gt;]
#endif
type Box&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("dyn $0")&gt;]
#endif
type Dyn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("$0 + Send")&gt;]
#endif
type Send&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn() -&gt; $0")&gt;]
#endif
type Fn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn()")&gt;]
#endif
type FnUnit = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("FnOnce() -&gt; $0")&gt;]
#endif
type FnOnce&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn($0)")&gt;]
#endif
type ActionFn&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Fn($0, $1)")&gt;]
#endif
type ActionFn2&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("impl $0")&gt;]
#endif
type Impl&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("mut $0")&gt;]
#endif
type Mut&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("&amp;$0")&gt;]
#endif
type Ref&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("&amp;'static $0")&gt;]
#endif
type StaticRef&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("MutCell&lt;$0&gt;")&gt;]
#endif
type MutCell&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::any::Any")&gt;]
#endif
type std_any_Any = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::borrow::Cow&lt;$0&gt;")&gt;]
#endif
type std_borrow_Cow&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::cell::RefCell&lt;$0&gt;")&gt;]
#endif
type std_cell_RefCell&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::pin::Pin&lt;$0&gt;")&gt;]
#endif
type std_pin_Pin&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::rc::Rc&lt;$0&gt;")&gt;]
#endif
type std_rc_Rc&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::rc::Weak&lt;$0&gt;")&gt;]
#endif
type std_rc_Weak&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("[$0]")&gt;]
#endif
type Slice&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("[$0; $1]")&gt;]
#endif
type Slice'&lt;'T, 'U&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("Vec&lt;$0&gt;")&gt;]
#endif
type Vec&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("str")&gt;]
#endif
type Str = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("base64::DecodeError")&gt;]
#endif
type base64_DecodeError = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("borsh::io::Error")&gt;]
#endif
type borsh_io_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("js_sys::JsString")&gt;]
#endif
type js_sys_JsString = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_json::Error")&gt;]
#endif
type serde_json_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_json::Value")&gt;]
#endif
type serde_json_Value = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("serde_wasm_bindgen::Error")&gt;]
#endif
type serde_wasm_bindgen_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::ffi::OsStr")&gt;]
#endif
type std_ffi_OsStr = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::ffi::OsString")&gt;]
#endif
type std_ffi_OsString = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fmt::Display&lt;$0&gt;")&gt;]
#endif
type std_fmt_Display&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::str::Utf8Error")&gt;]
#endif
type std_str_Utf8Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::string::FromUtf8Error")&gt;]
#endif
type std_string_FromUtf8Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::string::String")&gt;]
#endif
type std_string_String = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::slice::Windows&lt;$0&gt;")&gt;]
#endif
type std_slice_Windows&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::DateTime&lt;$0&gt;")&gt;]
#endif
type chrono_DateTime&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::Local")&gt;]
#endif
type chrono_Local = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::NaiveDateTime")&gt;]
#endif
type chrono_NaiveDateTime = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("chrono::Utc")&gt;]
#endif
type chrono_Utc = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::time::Duration")&gt;]
#endif
type std_time_Duration = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_std::io::BufReader&lt;$0&gt;")&gt;]
#endif
type async_std_io_BufReader&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::BufReader&lt;$0&gt;")&gt;]
#endif
type std_io_BufReader&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::Error")&gt;]
#endif
type std_io_Error = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::io::Lines&lt;$0&gt;")&gt;]
#endif
type std_io_Lines&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fs::File")&gt;]
#endif
type std_fs_File = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::fs::FileType")&gt;]
#endif
type std_fs_FileType = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::Display")&gt;]
#endif
type std_path_Display = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::Path")&gt;]
#endif
type std_path_Path = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::path::PathBuf")&gt;]
#endif
type std_path_PathBuf = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::DirEntry")&gt;]
#endif
type async_walkdir_DirEntry = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::Filtering")&gt;]
#endif
type async_walkdir_Filtering = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("async_walkdir::WalkDir")&gt;]
#endif
type async_walkdir_WalkDir = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::future::Future&lt;Output = $0&gt;")&gt;]
#endif
type std_future_Future&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("futures::future::TryJoinAll&lt;$0&gt;")&gt;]
#endif
type futures_future_TryJoinAll&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("rayon::vec::IntoIter&lt;$0&gt;")&gt;]
#endif
type rayon_vec_IntoIter&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("rayon::iter::Map&lt;$0, _&gt;")&gt;]
#endif
type rayon_iter_Map&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("futures_lite::stream::StreamExt")&gt;]
#endif
type futures_lite_stream_StreamExt = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("core::iter::Fuse&lt;$0&gt;")&gt;]
#endif
type core_iter_Fuse&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::thread::JoinHandle&lt;$0&gt;")&gt;]
#endif
type std_thread_JoinHandle&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::Arc&lt;$0&gt;")&gt;]
#endif
type std_sync_Arc&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::Mutex&lt;$0&gt;")&gt;]
#endif
type std_sync_Mutex&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::MutexGuard&lt;$0&gt;")&gt;]
#endif
type std_sync_MutexGuard&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::PoisonError&lt;$0&gt;")&gt;]
#endif
type std_sync_PoisonError&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::Arg")&gt;]
#endif
type clap_Arg = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::Command")&gt;]
#endif
type clap_Command = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::ArgMatches")&gt;]
#endif
type clap_ArgMatches = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::ValueRange")&gt;]
#endif
type clap_builder_ValueRange = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::ValueParser")&gt;]
#endif
type clap_builder_ValueParser = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("clap::builder::PossibleValue")&gt;]
#endif
type clap_builder_PossibleValue = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Child")&gt;]
#endif
type std_process_Child = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStderr")&gt;]
#endif
type std_process_ChildStderr = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStdout")&gt;]
#endif
type std_process_ChildStdout = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::ChildStdin")&gt;]
#endif
type std_process_ChildStdin = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Command")&gt;]
#endif
type std_process_Command = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Output")&gt;]
#endif
type std_process_Output = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::process::Stdio")&gt;]
#endif
type std_process_Stdio = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::mpsc::Receiver&lt;$0&gt;")&gt;]
#endif
type std_sync_mpsc_Receiver&lt;'T&gt; = class end
#if FABLE_COMPILER
[&lt;Fable.Core.Erase; Fable.Core.Emit("std::sync::mpsc::Sender&lt;$0&gt;")&gt;]
#endif
type std_sync_mpsc_Sender&lt;'T&gt; = class end
module State = let mutable trace_state = None
type IPathJoin = abstract join: [&lt;System.ParamArray&gt;] paths: string[] -&gt; string
type IFsExistsSync = abstract existsSync: path: string -&gt; bool
type IPathDirname = abstract dirname: path: string -&gt; string
#if FABLE_COMPILER
[&lt;CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)&gt;]
module System =
 module Diagnostics =
  type Process = unit
  type DataReceivedEventArgs = unit
#endif
type Mut0 = {mutable l0 : int64}
and Mut1 = {mutable l0 : bool}
and [&lt;Struct&gt;] US0 =
    | US0_0
    | US0_1
    | US0_2
    | US0_3
    | US0_4
and Mut2 = {mutable l0 : US0}
and Mut3 = {mutable l0 : (string -&gt; unit)}
and [&lt;Struct&gt;] US1 =
    | US1_0 of f0_0 : int64
    | US1_1
and [&lt;Struct&gt;] US2 =
    | US2_0 of f0_0 : int64
    | US2_1
and [&lt;Struct&gt;] US3 =
    | US3_0 of f0_0 : std_string_String
    | US3_1
and [&lt;Struct&gt;] US4 =
    | US4_0 of f0_0 : string
    | US4_1
and Mut4 = {mutable l0 : int32; mutable l1 : int32; mutable l2 : (string [])}
and Mut5 = {mutable l0 : int32}
and [&lt;Struct&gt;] US5 =
    | US5_0
    | US5_1
    | US5_2
and [&lt;Struct&gt;] US6 =
    | US6_0 of f0_0 : std_fs_FileType
    | US6_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US7 =
    | US7_0 of f0_0 : async_walkdir_DirEntry
    | US7_1 of f1_0 : std_string_String
and UH0 =
    | UH0_0
    | UH0_1 of char * UH0
and [&lt;Struct&gt;] US9 =
    | US9_0
    | US9_1
and [&lt;Struct&gt;] US8 =
    | US8_0
    | US8_1 of f1_0 : US9
    | US8_2
and UH1 =
    | UH1_0
    | UH1_1 of string * UH1
and [&lt;Struct&gt;] US10 =
    | US10_0
    | US10_1 of f1_0 : char
    | US10_2 of f2_0 : uint8
and [&lt;Struct&gt;] US11 =
    | US11_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;
    | US11_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US12 =
    | US12_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt;&gt;
    | US12_1
and [&lt;Struct&gt;] US13 =
    | US13_0 of f0_0 : std_string_String
    | US13_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US14 =
    | US14_0 of f0_0 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit)
    | US14_1
and [&lt;Struct&gt;] US15 =
    | US15_0 of f0_0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;
    | US15_1
and [&lt;Struct&gt;] US16 =
    | US16_0 of f0_0 : std_process_Output
    | US16_1 of f1_0 : std_string_String
and [&lt;Struct&gt;] US17 =
    | US17_0 of f0_0 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;)
    | US17_1
and [&lt;Struct&gt;] US18 =
    | US18_0 of f0_0 : System.Threading.CancellationToken
    | US18_1
and [&lt;Struct&gt;] US19 =
    | US19_0 of f0_0 : Result&lt;string, (string * string)&gt;
    | US19_1
and UH3 =
    | UH3_0
    | UH3_1 of string * string * (string -&gt; (string -&gt; US19)) * UH3
and UH2 =
    | UH2_0
    | UH2_1 of UH3 * UH2
and [&lt;Struct&gt;] US20 =
    | US20_0 of f0_0 : string
    | US20_1 of f1_0 : string
and [&lt;Struct&gt;] US21 =
    | US21_0 of f0_0 : int32 * f0_1 : string
    | US21_1 of f1_0 : int32 * f1_1 : string
and Mut6 = {mutable l0 : int32; mutable l1 : int32}
and Mut7 = {mutable l0 : int32; mutable l1 : string; mutable l2 : int32; mutable l3 : int32}
and Mut8 = {mutable l0 : int32; mutable l1 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;}
let rec method0 () : clap_Command =
    let v0 : string = "command"
    let v1 : string = "r#\"" + v0 + "\"#"
    let v2 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v1
    let v3 : string = "clap::Command::new($0)"
    let v4 : clap_Command = Fable.Core.RustInterop.emitRustExpr v2 v3
    let v5 : string = "source-dir"
    let v6 : string = "r#\"" + v5 + "\"#"
    let v7 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v6
    let v8 : string = "clap::Arg::new($0)"
    let v9 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0.short($1)"
    let v11 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v9, 's') v10
    let v12 : string = "r#\"" + v5 + "\"#"
    let v13 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v12
    let v14 : string = "$0.long($1)"
    let v15 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v11, v13) v14
    let v16 : string = "$0.required($1)"
    let v17 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v15, true) v16
    let v18 : string = "clap::Command::arg($0, $1)"
    let v19 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v4, v17) v18
    let v20 : string = "dist-dir"
    let v21 : string = "r#\"" + v20 + "\"#"
    let v22 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v21
    let v23 : string = "clap::Arg::new($0)"
    let v24 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v22 v23
    let v25 : string = "$0.short($1)"
    let v26 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v24, 'd') v25
    let v27 : string = "r#\"" + v20 + "\"#"
    let v28 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v27
    let v29 : string = "$0.long($1)"
    let v30 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v26, v28) v29
    let v31 : string = "$0.required($1)"
    let v32 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v30, true) v31
    let v33 : string = "clap::Command::arg($0, $1)"
    let v34 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v19, v32) v33
    let v35 : string = "cache-dir"
    let v36 : string = "r#\"" + v35 + "\"#"
    let v37 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v36
    let v38 : string = "clap::Arg::new($0)"
    let v39 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v37 v38
    let v40 : string = "$0.short($1)"
    let v41 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v39, 'c') v40
    let v42 : string = "r#\"" + v35 + "\"#"
    let v43 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v42
    let v44 : string = "$0.long($1)"
    let v45 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v41, v43) v44
    let v46 : string = "$0.required($1)"
    let v47 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v45, true) v46
    let v48 : string = "clap::Command::arg($0, $1)"
    let v49 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v34, v47) v48
    let v50 : string = "hangul-spec"
    let v51 : string = "r#\"" + v50 + "\"#"
    let v52 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v51
    let v53 : string = "clap::Arg::new($0)"
    let v54 : clap_Arg = Fable.Core.RustInterop.emitRustExpr v52 v53
    let v55 : string = "$0.short($1)"
    let v56 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v54, 's') v55
    let v57 : string = "r#\"" + v50 + "\"#"
    let v58 : StaticRef&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v57
    let v59 : string = "$0.long($1)"
    let v60 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v56, v58) v59
    let v61 : string = "$0.required($1)"
    let v62 : clap_Arg = Fable.Core.RustInterop.emitRustExpr struct (v60, true) v61
    let v63 : string = "clap::Command::arg($0, $1)"
    let v64 : clap_Command = Fable.Core.RustInterop.emitRustExpr struct (v49, v62) v63
    v64
and closure0 () () : unit =
    let v0 : string = "true; () //"
    let v1 : bool = Fable.Core.RustInterop.emitRustExpr () v0
    let v2 : string = "} /* /*"
    Fable.Core.RustInterop.emitRustExpr () v2
    let v3 : string = "verify_app"
    let v4 : string = $"*/ #[test] fn " + v3 + "() { //"
    let v5 : bool = Fable.Core.RustInterop.emitRustExpr () v4
    let v6 : clap_Command = method0()
    let v7 : string = "clap::Command::debug_assert($0)"
    Fable.Core.RustInterop.emitRustExpr v6 v7
    let v8 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v8
    ()
and closure3 () (v0 : string) : unit =
    ()
and method1 (v0 : int64 option) : int64 option =
    v0
and method2 (v0 : int64 option) : int64 option =
    v0
and closure2 () () : struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3) =
    let v0 : Mut1 = {l0 = true} : Mut1
    let v1 : Mut0 = {l0 = 0L} : Mut0
    let v2 : US0 = US0_0
    let v3 : Mut2 = {l0 = v2} : Mut2
    let v4 : (string -&gt; unit) = closure3()
    let v5 : Mut3 = {l0 = v4} : Mut3
    let v6 : int64 option option = None
    let mutable _v6 = v6
    #if INTERACTIVE || !FABLE_COMPILER
    let v7 : string option = None
    let v8 : bool = true in let mutable _v7 = v7
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v9 : string = "env!(\"CARGO_PKG_NAME\").into()"
    let v10 : string = Fable.Core.RustInterop.emitRustExpr () v9
    v10
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v11 : string = null |&gt; unbox&lt;string&gt;
    v11
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v12 : string = null |&gt; unbox&lt;string&gt;
    v12
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v13 : string = null |&gt; unbox&lt;string&gt;
    v13
#endif
    
#if FABLE_COMPILER_PYTHON
    let v14 : string = null |&gt; unbox&lt;string&gt;
    v14
#endif
    
#else
    let v15 : string = System.Reflection.Assembly.GetEntryAssembly().GetName().Name
    v15
#endif
    |&gt; fun x -&gt; _v7 &lt;- Some x
    let v16 : string = _v7.Value
    let v18 : bool = v16 = "Microsoft.DotNet.Interactive.App"
    let v19 : bool = v18 &lt;&gt; true
    let v25 : US1 =
        if v19 then
            let v20 : System.DateTime = System.DateTime.Now
            let v21 : (System.DateTime -&gt; int64) = _.Ticks
            let v22 : int64 = v21 v20
            US1_0(v22)
        else
            US1_1
    let v30 : int64 option =
        match v25 with
        | US1_1 -&gt; (* None *)
            let v28 : int64 option = None
            v28
        | US1_0(v26) -&gt; (* Some *)
            let v27 : int64 option = Some v26 
            v27
    let v31 : int64 option = method1(v30)
    v31 
    #else
    let v32 : int64 option = None
    let v33 : int64 option = method2(v32)
    v33 
    #endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v34 : int64 option = _v6.Value
    struct (v1, v0, v3, v34, v5)
and closure4 () () : string =
    let v0 : string = $"documents.main"
    v0
and closure6 () () : string =
    let v0 : string = ""
    v0
and closure5 (v0 : (string [])) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"args: {v0} / {v1 ()}"
    v2
and closure8 () (v0 : int64) : US2 =
    US2_0(v0)
and method4 () : (int64 -&gt; US2) =
    closure8()
and method5 () : string =
    let v0 : string = ""
    v0
and closure7 (v0 : US0, v1 : (unit -&gt; string), v2 : (unit -&gt; string)) () : string =
    let v3 : (unit -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    if State.trace_state.IsNone then State.trace_state &lt;- v3 () |&gt; Some
    let struct (v4 : Mut0, v5 : Mut1, v6 : Mut2, v7 : int64 option, v8 : Mut3) = State.trace_state.Value
    let v9 : string option = None
    let v10 : bool = true in let mutable _v9 = v9
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v11 : (int64 -&gt; US2) = method4()
    let v12 : US2 = US2_1
    let v13 : US2 = v7 |&gt; Option.map v11 |&gt; Option.defaultValue v12 
    let v31 : System.DateTime =
        match v13 with
        | US2_1 -&gt; (* None *)
            let v29 : System.DateTime = System.DateTime.Now
            v29
        | US2_0(v14) -&gt; (* Some *)
            let v15 : System.DateTime = System.DateTime.Now
            let v16 : (System.DateTime -&gt; int64) = _.Ticks
            let v17 : int64 = v16 v15
            let v18 : int64 = v17 - v14
            let v19 : System.TimeSpan = System.TimeSpan v18 
            let v20 : (System.TimeSpan -&gt; int32) = _.Hours
            let v21 : int32 = v20 v19
            let v22 : (System.TimeSpan -&gt; int32) = _.Minutes
            let v23 : int32 = v22 v19
            let v24 : (System.TimeSpan -&gt; int32) = _.Seconds
            let v25 : int32 = v24 v19
            let v26 : (System.TimeSpan -&gt; int32) = _.Milliseconds
            let v27 : int32 = v26 v19
            let v28 : System.DateTime = System.DateTime (1, 1, 1, v21, v23, v25, v27)
            v28
    let v32 : string = "hh:mm:ss"
    let v33 : string = v31.ToString v32 
    v33
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v34 : string = method5()
    v34
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v35 : string = method5()
    v35
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v36 : string = method5()
    v36
#endif
    
#if FABLE_COMPILER_PYTHON
    let v37 : string = method5()
    v37
#endif
    
#else
    let v38 : (int64 -&gt; US2) = method4()
    let v39 : US2 = US2_1
    let v40 : US2 = v7 |&gt; Option.map v38 |&gt; Option.defaultValue v39 
    let v58 : System.DateTime =
        match v40 with
        | US2_1 -&gt; (* None *)
            let v56 : System.DateTime = System.DateTime.Now
            v56
        | US2_0(v41) -&gt; (* Some *)
            let v42 : System.DateTime = System.DateTime.Now
            let v43 : (System.DateTime -&gt; int64) = _.Ticks
            let v44 : int64 = v43 v42
            let v45 : int64 = v44 - v41
            let v46 : System.TimeSpan = System.TimeSpan v45 
            let v47 : (System.TimeSpan -&gt; int32) = _.Hours
            let v48 : int32 = v47 v46
            let v49 : (System.TimeSpan -&gt; int32) = _.Minutes
            let v50 : int32 = v49 v46
            let v51 : (System.TimeSpan -&gt; int32) = _.Seconds
            let v52 : int32 = v51 v46
            let v53 : (System.TimeSpan -&gt; int32) = _.Milliseconds
            let v54 : int32 = v53 v46
            let v55 : System.DateTime = System.DateTime (1, 1, 1, v48, v50, v52, v54)
            v55
    let v59 : string = "HH:mm:ss"
    let v60 : string = v58.ToString v59 
    v60
#endif
    |&gt; fun x -&gt; _v9 &lt;- Some x
    let v61 : string = _v9.Value
    let v62 : int64 = v4.l0
    let v72 : string =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v67 : string = "Critical"
            v67
        | US0_1 -&gt; (* Debug *)
            let v64 : string = "Debug"
            v64
        | US0_2 -&gt; (* Info *)
            let v65 : string = "Info"
            v65
        | US0_0 -&gt; (* Verbose *)
            let v63 : string = "Verbose"
            v63
        | US0_3 -&gt; (* Warning *)
            let v66 : string = "Warning"
            v66
    let v73 : string = v72.ToLower ()
    let v74 : string = v73.PadLeft (7, ' ')
    let v75 : string option = None
    let v76 : bool = true in let mutable _v75 = v75
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v91 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v85 : string = "inline_colorization::color_bright_red"
            let v86 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v85
            v86
        | US0_1 -&gt; (* Debug *)
            let v79 : string = "inline_colorization::color_bright_blue"
            let v80 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v79
            v80
        | US0_2 -&gt; (* Info *)
            let v81 : string = "inline_colorization::color_bright_green"
            let v82 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v81
            v82
        | US0_0 -&gt; (* Verbose *)
            let v77 : string = "inline_colorization::color_bright_black"
            let v78 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v77
            v78
        | US0_3 -&gt; (* Warning *)
            let v83 : string = "inline_colorization::color_bright_yellow"
            let v84 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v83
            v84
    let v92 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v93 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v74 v92
    let v94 : string = "inline_colorization::color_reset"
    let v95 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v94
    let v96 : string = "\"{v91}{v93}{v95}\""
    let v97 : string = @$"format!(" + v96 + ")"
    let v98 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v97
    let v99 : string = "fable_library_rust::String_::fromString($0)"
    let v100 : string = Fable.Core.RustInterop.emitRustExpr v98 v99
    v100
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v115 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v109 : string = "inline_colorization::color_bright_red"
            let v110 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v109
            v110
        | US0_1 -&gt; (* Debug *)
            let v103 : string = "inline_colorization::color_bright_blue"
            let v104 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v103
            v104
        | US0_2 -&gt; (* Info *)
            let v105 : string = "inline_colorization::color_bright_green"
            let v106 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v105
            v106
        | US0_0 -&gt; (* Verbose *)
            let v101 : string = "inline_colorization::color_bright_black"
            let v102 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v101
            v102
        | US0_3 -&gt; (* Warning *)
            let v107 : string = "inline_colorization::color_bright_yellow"
            let v108 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v107
            v108
    let v116 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v117 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v74 v116
    let v118 : string = "inline_colorization::color_reset"
    let v119 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v118
    let v120 : string = "\"{v115}{v117}{v119}\""
    let v121 : string = @$"format!(" + v120 + ")"
    let v122 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v121
    let v123 : string = "fable_library_rust::String_::fromString($0)"
    let v124 : string = Fable.Core.RustInterop.emitRustExpr v122 v123
    v124
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v139 : Ref&lt;Str&gt; =
        match v0 with
        | US0_4 -&gt; (* Critical *)
            let v133 : string = "inline_colorization::color_bright_red"
            let v134 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v133
            v134
        | US0_1 -&gt; (* Debug *)
            let v127 : string = "inline_colorization::color_bright_blue"
            let v128 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v127
            v128
        | US0_2 -&gt; (* Info *)
            let v129 : string = "inline_colorization::color_bright_green"
            let v130 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v129
            v130
        | US0_0 -&gt; (* Verbose *)
            let v125 : string = "inline_colorization::color_bright_black"
            let v126 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v125
            v126
        | US0_3 -&gt; (* Warning *)
            let v131 : string = "inline_colorization::color_bright_yellow"
            let v132 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v131
            v132
    let v140 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v141 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v74 v140
    let v142 : string = "inline_colorization::color_reset"
    let v143 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr () v142
    let v144 : string = "\"{v139}{v141}{v143}\""
    let v145 : string = @$"format!(" + v144 + ")"
    let v146 : std_string_String = Fable.Core.RustInterop.emitRustExpr () v145
    let v147 : string = "fable_library_rust::String_::fromString($0)"
    let v148 : string = Fable.Core.RustInterop.emitRustExpr v146 v147
    v148
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    v74
#endif
    
#if FABLE_COMPILER_PYTHON
    v74
#endif
    
#else
    v74
#endif
    |&gt; fun x -&gt; _v75 &lt;- Some x
    let v149 : string = _v75.Value
    let v150 : string = v1 ()
    let v151 : string = $"{v61} {v149} #{v62} %s{v150} / %s{v2 ()}"
    let v152 : (char []) = [||]
    let v153 : string = v151.TrimStart v152
    let v154 : (char []) = [|' '; '/'|]
    let v155 : string = v153.TrimEnd v154
    v155
and method6 (v0 : US0, v1 : (unit -&gt; string)) : unit =
    let v2 : (unit -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    if State.trace_state.IsNone then State.trace_state &lt;- v2 () |&gt; Some
    let struct (v3 : Mut0, v4 : Mut1, v5 : Mut2, v6 : int64 option, v7 : Mut3) = State.trace_state.Value
    if State.trace_state.IsNone then State.trace_state &lt;- v2 () |&gt; Some
    let struct (v8 : Mut0, v9 : Mut1, v10 : Mut2, v11 : int64 option, v12 : Mut3) = State.trace_state.Value
    let v13 : US0 = v10.l0
    let v14 : bool = v9.l0
    let v15 : bool = v14 = false
    let v19 : bool =
        if v15 then
            false
        else
            let v16 : int32 = [ US0_0, 0; US0_1, 1; US0_2, 2; US0_3, 3; US0_4, 4 ] |&gt; Map |&gt; Map.find v0
            let v17 : int32 = [ US0_0, 0; US0_1, 1; US0_2, 2; US0_3, 3; US0_4, 4 ] |&gt; Map |&gt; Map.find v13
            let v18 : bool = v16 &gt;= v17
            v18
    if v19 then
        let v20 : int64 = v3.l0
        let v21 : int64 = v20 + 1L
        v3.l0 &lt;- v21
        let v22 : string = $"%s{v1 ()}"
        let v23 : unit option = None
        let v24 : bool = true in let mutable _v23 = v23
        
#if FABLE_COMPILER || WASM || CONTRACT
        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
        let v25 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v22 v25
        ()
#endif
        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
        let v26 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v22 v26
        ()
#endif
        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
        let v27 : string = @"println!(""{}"", $0)"
        Fable.Core.RustInterop.emitRustExpr v22 v27
        ()
#endif
        
#if FABLE_COMPILER_TYPESCRIPT
        System.Console.WriteLine v22 
        ()
#endif
        
#if FABLE_COMPILER_PYTHON
        System.Console.WriteLine v22 
        ()
#endif
        
#else
        System.Console.WriteLine v22 
        ()
#endif
        |&gt; fun x -&gt; _v23 &lt;- Some x
        _v23.Value
        let v28 : (string -&gt; unit) = v7.l0
        v28 v22
and method3 (v0 : US0, v1 : (unit -&gt; string), v2 : (unit -&gt; string)) : unit =
    let v3 : (unit -&gt; string) = closure7(v0, v1, v2)
    method6(v0, v3)
and method7 () : string =
    let v0 : string = "source-dir"
    v0
and closure9 () (v0 : std_string_String) : US3 =
    US3_0(v0)
and method8 () : (std_string_String -&gt; US3) =
    closure9()
and method9 () : string =
    let v0 : string = "dist-dir"
    v0
and method10 () : string =
    let v0 : string = "cache-dir"
    v0
and method11 () : string =
    let v0 : string = "hangul-spec"
    v0
and method14 (v0 : string) : string =
    v0
and method15 (v0 : string) : string =
    v0
and method16 (v0 : string) : string =
    v0
and method13 (v0 : string, v1 : string) : string =
    let v2 : string option = None
    let v3 : bool = true in let mutable _v2 = v2
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v4 : string = method14(v0)
    let v5 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v6 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v4 v5
    let v7 : string = "String::from($0)"
    let v8 : std_string_String = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "std::path::PathBuf::from($0)"
    let v10 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = method14(v1)
    let v12 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v13 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "String::from($0)"
    let v15 : std_string_String = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "$0.join($1)"
    let v17 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr struct (v10, v15) v16
    let v18 : string = "$0.display()"
    let v19 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : std_string_String option = None
    let v21 : bool = true in let mutable _v20 = v20
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v22 : string = @$"format!(""{{}}"", $0)"
    let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v22
    v23
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v24 : string = @$"format!(""{{}}"", $0)"
    let v25 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v24
    v25
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v26 : string = @$"format!(""{{}}"", $0)"
    let v27 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v26
    v27
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v28 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v28
#endif
    
#if FABLE_COMPILER_PYTHON
    let v29 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v29
#endif
    
#else
    let v30 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v30
#endif
    |&gt; fun x -&gt; _v20 &lt;- Some x
    let v31 : std_string_String = _v20.Value
    let v32 : string = "fable_library_rust::String_::fromString($0)"
    let v33 : string = Fable.Core.RustInterop.emitRustExpr v31 v32
    v33
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v34 : string = null |&gt; unbox&lt;string&gt;
    v34
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v35 : string = null |&gt; unbox&lt;string&gt;
    v35
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v36 : string = "path"
    let v37 : IPathJoin = Fable.Core.JsInterop.importAll v36
    let v38 : string = method15(v0)
    let v39 : string = method16(v1)
    let v40 : string = "v37.join(v38, v39)"
    let v41 : string = Fable.Core.JsInterop.emitJsExpr () v40
    v41
#endif
    
#if FABLE_COMPILER_PYTHON
    let v42 : string = null |&gt; unbox&lt;string&gt;
    v42
#endif
    
#else
    let v43 : string = System.IO.Path.Combine (v0, v1)
    v43
#endif
    |&gt; fun x -&gt; _v2 &lt;- Some x
    let v44 : string = _v2.Value
    v44
and closure10 () (v0 : string) : string option =
    let v1 : US4 option = None
    let v2 : bool = true in let mutable _v1 = v1
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : string = method14(v0)
    let v4 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v5 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v3 v4
    let v6 : string = "String::from($0)"
    let v7 : std_string_String = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "std::path::PathBuf::from($0)"
    let v9 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "$0.parent().map(std::path::PathBuf::from)"
    let v11 : std_path_PathBuf option = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "$0?"
    let v13 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "$0.display()"
    let v15 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : std_string_String option = None
    let v17 : bool = true in let mutable _v16 = v16
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v18 : string = @$"format!(""{{}}"", $0)"
    let v19 : std_string_String = Fable.Core.RustInterop.emitRustExpr v15 v18
    v19
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v20 : string = @$"format!(""{{}}"", $0)"
    let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v15 v20
    v21
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v22 : string = @$"format!(""{{}}"", $0)"
    let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v15 v22
    v23
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v24 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v24
#endif
    
#if FABLE_COMPILER_PYTHON
    let v25 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v25
#endif
    
#else
    let v26 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v26
#endif
    |&gt; fun x -&gt; _v16 &lt;- Some x
    let v27 : std_string_String = _v16.Value
    let v28 : string = "fable_library_rust::String_::fromString($0)"
    let v29 : string = Fable.Core.RustInterop.emitRustExpr v27 v28
    let v30 : US4 = US4_0(v29)
    v30
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v31 : US4 = null |&gt; unbox&lt;US4&gt;
    v31
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v32 : US4 = null |&gt; unbox&lt;US4&gt;
    v32
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v33 : string = "path"
    let v34 : IPathDirname = Fable.Core.JsInterop.importAll v33
    let v35 : string = "v34.dirname($0)"
    let v36 : string = Fable.Core.JsInterop.emitJsExpr v0 v35
    let v37 : US4 = US4_0(v36)
    v37
#endif
    
#if FABLE_COMPILER_PYTHON
    let v38 : US4 = null |&gt; unbox&lt;US4&gt;
    v38
#endif
    
#else
    let v39 : (string -&gt; System.IO.DirectoryInfo) = System.IO.Directory.GetParent
    let v40 : System.IO.DirectoryInfo = v39 v0
    let v41 : System.IO.DirectoryInfo = null |&gt; unbox&lt;System.IO.DirectoryInfo&gt;
    let v42 : bool = v40 = v41
    let v54 : US4 =
        if v42 then
            US4_1
        else
            let v44 : string option = None
            let v45 : bool = true in let mutable _v44 = v44
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v46 : string = null |&gt; unbox&lt;string&gt;
            v46
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v47 : string = null |&gt; unbox&lt;string&gt;
            v47
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v48 : string = null |&gt; unbox&lt;string&gt;
            v48
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v49 : string = null |&gt; unbox&lt;string&gt;
            v49
#endif
            
#if FABLE_COMPILER_PYTHON
            let v50 : string = null |&gt; unbox&lt;string&gt;
            v50
#endif
            
#else
            let v51 : string = v40.FullName
            v51
#endif
            |&gt; fun x -&gt; _v44 &lt;- Some x
            let v52 : string = _v44.Value
            US4_0(v52)
    v54
#endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v55 : US4 = _v1.Value
    match v55 with
    | US4_1 -&gt; (* None *)
        let v58 : string option = None
        v58
    | US4_0(v56) -&gt; (* Some *)
        let v57 : string option = Some v56 
        v57
and method18 () : (string -&gt; string option) =
    closure10()
and closure11 () (v0 : string) : US4 =
    US4_0(v0)
and method19 () : (string -&gt; US4) =
    closure11()
and method20 (v0 : string, v1 : string, v2 : string) : string =
    let v3 : string = method13(v2, v0)
    let v4 : bool option = None
    let v5 : bool = true in let mutable _v4 = v4
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v6 : string = method14(v3)
    let v7 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v8 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "String::from($0)"
    let v10 : std_string_String = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = "std::path::PathBuf::from($0)"
    let v12 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "$0.exists()"
    let v14 : bool = Fable.Core.RustInterop.emitRustExpr v12 v13
    let v17 : bool =
        if v14 then
            let v15 : string = "$0.is_dir()"
            let v16 : bool = Fable.Core.RustInterop.emitRustExpr v12 v15
            v16
        else
            false
    v17
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v18 : bool = null |&gt; unbox&lt;bool&gt;
    v18
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v19 : bool = null |&gt; unbox&lt;bool&gt;
    v19
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v20 : string = "fs"
    let v21 : IFsExistsSync = Fable.Core.JsInterop.importAll v20
    let v22 : string = "$0.existsSync($1)"
    let v23 : bool = Fable.Core.JsInterop.emitJsExpr struct (v21, v3) v22
    v23
#endif
    
#if FABLE_COMPILER_PYTHON
    let v24 : bool = null |&gt; unbox&lt;bool&gt;
    v24
#endif
    
#else
    let v25 : (string -&gt; bool) = System.IO.Directory.Exists
    let v26 : bool = v25 v3
    v26
#endif
    |&gt; fun x -&gt; _v4 &lt;- Some x
    let v27 : bool = _v4.Value
    if v27 then
        v2
    else
        let v28 : (string -&gt; string option) = method18()
        let v29 : string option = v28 v2
        let v30 : (string -&gt; US4) = method19()
        let v31 : US4 = US4_1
        let v32 : US4 = v29 |&gt; Option.map v30 |&gt; Option.defaultValue v31 
        match v32 with
        | US4_1 -&gt; (* None *)
            let v35 : string = $"""No parent for {if false then "file" else "dir"} '{v0}' at '{v1}' (until '{v2}')"""
            failwith&lt;string&gt; v35
        | US4_0(v33) -&gt; (* Some *)
            method20(v0, v1, v33)
and method17 (v0 : string, v1 : string) : string =
    let v2 : string = method13(v1, v0)
    let v3 : bool option = None
    let v4 : bool = true in let mutable _v3 = v3
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v5 : string = method14(v2)
    let v6 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v7 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "String::from($0)"
    let v9 : std_string_String = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "std::path::PathBuf::from($0)"
    let v11 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "$0.exists()"
    let v13 : bool = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v16 : bool =
        if v13 then
            let v14 : string = "$0.is_dir()"
            let v15 : bool = Fable.Core.RustInterop.emitRustExpr v11 v14
            v15
        else
            false
    v16
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v17 : bool = null |&gt; unbox&lt;bool&gt;
    v17
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v18 : bool = null |&gt; unbox&lt;bool&gt;
    v18
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v19 : string = "fs"
    let v20 : IFsExistsSync = Fable.Core.JsInterop.importAll v19
    let v21 : string = "$0.existsSync($1)"
    let v22 : bool = Fable.Core.JsInterop.emitJsExpr struct (v20, v2) v21
    v22
#endif
    
#if FABLE_COMPILER_PYTHON
    let v23 : bool = null |&gt; unbox&lt;bool&gt;
    v23
#endif
    
#else
    let v24 : (string -&gt; bool) = System.IO.Directory.Exists
    let v25 : bool = v24 v2
    v25
#endif
    |&gt; fun x -&gt; _v3 &lt;- Some x
    let v26 : bool = _v3.Value
    if v26 then
        v1
    else
        let v27 : (string -&gt; string option) = method18()
        let v28 : string option = v27 v1
        let v29 : (string -&gt; US4) = method19()
        let v30 : US4 = US4_1
        let v31 : US4 = v28 |&gt; Option.map v29 |&gt; Option.defaultValue v30 
        match v31 with
        | US4_1 -&gt; (* None *)
            let v34 : string = $"""No parent for {if false then "file" else "dir"} '{v0}' at '{v1}' (until '{v1}')"""
            failwith&lt;string&gt; v34
        | US4_0(v32) -&gt; (* Some *)
            method20(v0, v1, v32)
and method21 (v0 : string) : string =
    v0
and method22 () : string =
    let v0 : string = "^\\\\\\\\\\?\\\\"
    v0
and method23 (v0 : string) : string =
    v0
and method24 () : string =
    let v0 : string = ""
    v0
and method25 (v0 : int32, v1 : Mut4) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method26 (v0 : int32, v1 : Mut5) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method27 (v0 : string) : string =
    v0
and method28 (v0 : string) : string =
    v0
and closure12 () () : string =
    let v0 : string = "documents.run"
    v0
and closure13 (v0 : string, v1 : string, v2 : string, v3 : string) () : string =
    let v4 : (unit -&gt; string) = closure6()
    let v5 : string = $"source_dir: {v1} / dist_dir: {v2} / cache_dir: {v3} / hangul_spec: %A{v0} / {v4 ()}"
    v5
and method32 (v0 : async_walkdir_DirEntry) : async_walkdir_DirEntry =
    v0
and closure15 () (v0 : std_io_Error) : std_string_String =
    let v1 : std_string_String option = None
    let v2 : bool = true in let mutable _v1 = v1
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : string = @$"format!(""{{}}"", $0)"
    let v4 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v3
    v4
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v5 : string = @$"format!(""{{}}"", $0)"
    let v6 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v5
    v6
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v7 : string = @$"format!(""{{}}"", $0)"
    let v8 : std_string_String = Fable.Core.RustInterop.emitRustExpr v0 v7
    v8
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v9 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v9
#endif
    
#if FABLE_COMPILER_PYTHON
    let v10 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v10
#endif
    
#else
    let v11 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v11
#endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v12 : std_string_String = _v1.Value
    v12
and method33 () : (std_io_Error -&gt; std_string_String) =
    closure15()
and closure16 () (v0 : std_fs_FileType) : US6 =
    US6_0(v0)
and closure17 () (v0 : std_string_String) : US6 =
    US6_1(v0)
and method34 (v0 : std_fs_FileType) : std_fs_FileType =
    v0
and method35 (v0 : US5) : US5 =
    v0
and method31 (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US5&gt;&gt;&gt;&gt;&gt; =
    let v1 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v1
    let v2 : async_walkdir_DirEntry = method32(v0)
    let v3 : string = "Box::pin(async_walkdir::DirEntry::file_type(&amp;v2))"
    let v4 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;Result&lt;std_fs_FileType, std_io_Error&gt;&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v3
    let v5 : string = "v4.await"
    let v6 : Result&lt;std_fs_FileType, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v5
    let v7 : (std_io_Error -&gt; std_string_String) = method33()
    let v8 : string = "$0.map_err(|x| $1(x))"
    let v9 : Result&lt;std_fs_FileType, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v6, v7) v8
    let v10 : (std_fs_FileType -&gt; US6) = closure16()
    let v11 : (std_string_String -&gt; US6) = closure17()
    let v12 : US6 = match v9 with Ok x -&gt; v10 x | Error x -&gt; v11 x
    let v73 : US5 =
        match v12 with
        | US6_0(v13) -&gt; (* Ok *)
            let v14 : std_fs_FileType = method34(v13)
            let v15 : string = "std::fs::FileType::is_dir(&amp;v14)"
            let v16 : bool = Fable.Core.RustInterop.emitRustExpr () v15
            if v16 then
                US5_0
            else
                let v18 : string = "async_walkdir::DirEntry::path(&amp;$0)"
                let v19 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v0 v18
                let v20 : string = "$0.display()"
                let v21 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v19 v20
                let v22 : std_string_String option = None
                let v23 : bool = true in let mutable _v22 = v22
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v24 : string = @$"format!(""{{}}"", $0)"
                let v25 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v24
                v25
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v26 : string = @$"format!(""{{}}"", $0)"
                let v27 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v26
                v27
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v28 : string = @$"format!(""{{}}"", $0)"
                let v29 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v28
                v29
#endif
                
#if FABLE_COMPILER_TYPESCRIPT
                let v30 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v30
#endif
                
#if FABLE_COMPILER_PYTHON
                let v31 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v31
#endif
                
#else
                let v32 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
                v32
#endif
                |&gt; fun x -&gt; _v22 &lt;- Some x
                let v33 : std_string_String = _v22.Value
                let v34 : string = "fable_library_rust::String_::fromString($0)"
                let v35 : string = Fable.Core.RustInterop.emitRustExpr v33 v34
                let v36 : string = ".md"
                let v37 : bool = v35.EndsWith v36
                let v38 : bool = v37 = false
                let v41 : bool =
                    if v38 then
                        true
                    else
                        let v39 : string = ".hangul.md"
                        let v40 : bool = v35.EndsWith v39
                        v40
                if v41 then
                    US5_0
                else
                    US5_2
        | _ -&gt;
            let v46 : string = "async_walkdir::DirEntry::path(&amp;$0)"
            let v47 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v0 v46
            let v48 : string = "$0.display()"
            let v49 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v47 v48
            let v50 : std_string_String option = None
            let v51 : bool = true in let mutable _v50 = v50
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v52 : string = @$"format!(""{{}}"", $0)"
            let v53 : std_string_String = Fable.Core.RustInterop.emitRustExpr v49 v52
            v53
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v54 : string = @$"format!(""{{}}"", $0)"
            let v55 : std_string_String = Fable.Core.RustInterop.emitRustExpr v49 v54
            v55
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v56 : string = @$"format!(""{{}}"", $0)"
            let v57 : std_string_String = Fable.Core.RustInterop.emitRustExpr v49 v56
            v57
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v58 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v58
#endif
            
#if FABLE_COMPILER_PYTHON
            let v59 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v59
#endif
            
#else
            let v60 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v60
#endif
            |&gt; fun x -&gt; _v50 &lt;- Some x
            let v61 : std_string_String = _v50.Value
            let v62 : string = "fable_library_rust::String_::fromString($0)"
            let v63 : string = Fable.Core.RustInterop.emitRustExpr v61 v62
            let v64 : string = ".md"
            let v65 : bool = v63.EndsWith v64
            let v66 : bool = v65 = false
            let v69 : bool =
                if v66 then
                    true
                else
                    let v67 : string = ".hangul.md"
                    let v68 : bool = v63.EndsWith v67
                    v68
            if v69 then
                US5_0
            else
                US5_2
    let v74 : US5 = method35(v73)
    let v75 : string = "v74 }})"
    Fable.Core.RustInterop.emitRustExpr () v75
    let v76 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v76
    let v77 : string = "__result"
    let v78 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US5&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v77
    v78
and method36 (v0 : async_walkdir_Filtering) : async_walkdir_Filtering =
    v0
and method30 (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; =
    let v1 : string = "let __result = Box::pin(async { //"
    Fable.Core.RustInterop.emitRustExpr () v1
    let v2 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;US5&gt;&gt;&gt;&gt;&gt; = method31(v0)
    let v3 : string = "v2.await"
    let v4 : US5 = Fable.Core.RustInterop.emitRustExpr () v3
    let v13 : async_walkdir_Filtering =
        match v4 with
        | US5_2 -&gt; (* Continue *)
            let v9 : string = "async_walkdir::Filtering::Continue"
            let v10 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v9
            v10
        | US5_0 -&gt; (* Ignore *)
            let v5 : string = "async_walkdir::Filtering::Ignore"
            let v6 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v5
            v6
        | US5_1 -&gt; (* IgnoreDir *)
            let v7 : string = "async_walkdir::Filtering::IgnoreDir"
            let v8 : async_walkdir_Filtering = Fable.Core.RustInterop.emitRustExpr () v7
            v8
    let v14 : async_walkdir_Filtering = method36(v13)
    let v15 : string = "v14 }})"
    Fable.Core.RustInterop.emitRustExpr () v15
    let v16 : string = "{ //"
    Fable.Core.RustInterop.emitRustExpr () v16
    let v17 : string = "__result"
    let v18 : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v17
    v18
and closure14 () (v0 : async_walkdir_DirEntry) : std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt; =
    method30(v0)
and closure19 () (v0 : async_walkdir_DirEntry) : US7 =
    US7_0(v0)
and closure20 () (v0 : std_string_String) : US7 =
    US7_1(v0)
and closure21 () () : string =
    let v0 : string = "documents.run / stream_filter_map"
    v0
and closure22 (v0 : std_string_String) () : string =
    let v1 : (unit -&gt; string) = closure6()
    let v2 : string = $"error: {v0} / {v1 ()}"
    v2
and closure18 () (v0 : Result&lt;async_walkdir_DirEntry, std_io_Error&gt;) : string option =
    let v1 : (std_io_Error -&gt; std_string_String) = method33()
    let v2 : string = "$0.map_err(|x| $1(x))"
    let v3 : Result&lt;async_walkdir_DirEntry, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v0, v1) v2
    let v4 : (async_walkdir_DirEntry -&gt; US7) = closure19()
    let v5 : (std_string_String -&gt; US7) = closure20()
    let v6 : US7 = match v3 with Ok x -&gt; v4 x | Error x -&gt; v5 x
    let v33 : US4 =
        match v6 with
        | US7_1(v27) -&gt; (* Error *)
            let v28 : US0 = US0_4
            let v29 : (unit -&gt; string) = closure21()
            let v30 : (unit -&gt; string) = closure22(v27)
            method3(v28, v29, v30)
            US4_1
        | US7_0(v7) -&gt; (* Ok *)
            let v8 : string = "async_walkdir::DirEntry::path(&amp;$0)"
            let v9 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v7 v8
            let v10 : string = "$0.display()"
            let v11 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v9 v10
            let v12 : std_string_String option = None
            let v13 : bool = true in let mutable _v12 = v12
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v14 : string = @$"format!(""{{}}"", $0)"
            let v15 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v14
            v15
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v16 : string = @$"format!(""{{}}"", $0)"
            let v17 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v16
            v17
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v18 : string = @$"format!(""{{}}"", $0)"
            let v19 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v18
            v19
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v20 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v20
#endif
            
#if FABLE_COMPILER_PYTHON
            let v21 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v21
#endif
            
#else
            let v22 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v22
#endif
            |&gt; fun x -&gt; _v12 &lt;- Some x
            let v23 : std_string_String = _v12.Value
            let v24 : string = "fable_library_rust::String_::fromString($0)"
            let v25 : string = Fable.Core.RustInterop.emitRustExpr v23 v24
            US4_0(v25)
    match v33 with
    | US4_1 -&gt; (* None *)
        let v36 : string option = None
        v36
    | US4_0(v34) -&gt; (* Some *)
        let v35 : string option = Some v34 
        v35
and method37 () : (Result&lt;async_walkdir_DirEntry, std_io_Error&gt; -&gt; string option) =
    closure18()
and closure23 () () : string =
    let v0 : string = "documents.run"
    v0
and closure24 (v0 : Vec&lt;string&gt;) () : string =
    let v1 : string = "$0.len()"
    let v2 : unativeint = Fable.Core.RustInterop.emitRustExpr v0 v1
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"files_len: {v2} / {v3 ()}"
    v4
and method38 (v0 : string) : string =
    let v1 : string option = None
    let v2 : bool = true in let mutable _v1 = v1
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : string = method21(v0)
    let v4 : string = method14(v3)
    let v5 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v6 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v4 v5
    let v7 : string = "String::from($0)"
    let v8 : std_string_String = Fable.Core.RustInterop.emitRustExpr v6 v7
    let v9 : string = "std::path::PathBuf::from($0)"
    let v10 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = "$0.exists()"
    let v12 : bool = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : bool = v12 = false
    let v163 : string =
        if v13 then
            let v14 : string option = None
            let v15 : bool = true in let mutable _v14 = v14
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v16 : string = "std::env::current_dir()"
            let v17 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v16
            let v18 : string = "$0.unwrap()"
            let v19 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v17 v18
            let v20 : string = "$0.display()"
            let v21 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v19 v20
            let v22 : std_string_String option = None
            let v23 : bool = true in let mutable _v22 = v22
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v24 : string = @$"format!(""{{}}"", $0)"
            let v25 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v24
            v25
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v26 : string = @$"format!(""{{}}"", $0)"
            let v27 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v26
            v27
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v28 : string = @$"format!(""{{}}"", $0)"
            let v29 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v28
            v29
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v30 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v30
#endif
            
#if FABLE_COMPILER_PYTHON
            let v31 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v31
#endif
            
#else
            let v32 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v32
#endif
            |&gt; fun x -&gt; _v22 &lt;- Some x
            let v33 : std_string_String = _v22.Value
            let v34 : string = "fable_library_rust::String_::fromString($0)"
            let v35 : string = Fable.Core.RustInterop.emitRustExpr v33 v34
            v35
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v36 : string = null |&gt; unbox&lt;string&gt;
            v36
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v37 : string = null |&gt; unbox&lt;string&gt;
            v37
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v38 : string = null |&gt; unbox&lt;string&gt;
            v38
#endif
            
#if FABLE_COMPILER_PYTHON
            let v39 : string = null |&gt; unbox&lt;string&gt;
            v39
#endif
            
#else
            let v40 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v41 : string = v40 ()
            v41
#endif
            |&gt; fun x -&gt; _v14 &lt;- Some x
            let v42 : string = _v14.Value
            let v43 : string = method13(v42, v3)
            let v44 : string option = None
            let v45 : bool = true in let mutable _v44 = v44
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v46 : string = method22()
            let v47 : string = method23(v43)
            let v48 : string = method24()
            let v49 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v50 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v46, v47, v48) v49
            let v51 : string = "String::from($0)"
            let v52 : std_string_String = Fable.Core.RustInterop.emitRustExpr v50 v51
            let v53 : string = "fable_library_rust::String_::fromString($0)"
            let v54 : string = Fable.Core.RustInterop.emitRustExpr v52 v53
            v54
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v55 : string = null |&gt; unbox&lt;string&gt;
            v55
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v56 : string = null |&gt; unbox&lt;string&gt;
            v56
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v57 : string = null |&gt; unbox&lt;string&gt;
            v57
#endif
            
#if FABLE_COMPILER_PYTHON
            let v58 : string = null |&gt; unbox&lt;string&gt;
            v58
#endif
            
#else
            let v59 : string = "^\\\\\\\\\\?\\\\"
            let v60 : string = ""
            let v61 : string = System.Text.RegularExpressions.Regex.Replace (v43, v59, v60)
            v61
#endif
            |&gt; fun x -&gt; _v44 &lt;- Some x
            let v62 : string = _v44.Value
            let v63 : string = $"{v62.[0] |&gt; string |&gt; _.ToLower()}{v62.[1..]}"
            let v64 : string = "\\"
            let v65 : string = "/"
            let v66 : string = v63.Replace (v64, v65)
            let v67 : (string []) = v66.Split v65
            let v68 : (string []) = [||]
            let v69 : int32 = v67.Length
            let v70 : Mut4 = {l0 = 0; l1 = 0; l2 = v68} : Mut4
            while method25(v69, v70) do
                let v72 : int32 = v70.l0
                let v73 : int32 =  -v72
                let v74 : int32 = v73 + v69
                let v75 : int32 = v74 - 1
                let struct (v76 : int32, v77 : (string [])) = v70.l1, v70.l2
                let v78 : string = v67.[int v75]
                let v79 : bool = ".." = v78
                let struct (v121 : int32, v122 : (string [])) =
                    if v79 then
                        let v80 : int32 = v76 + 1
                        struct (v80, v77)
                    else
                        let v81 : bool = "." = v78
                        if v81 then
                            struct (v76, v77)
                        else
                            let v82 : bool = 0 = v76
                            if v82 then
                                let v83 : string = ":"
                                let v84 : bool = v78.EndsWith v83
                                if v84 then
                                    let v85 : string = $"{v42.[0]}:"
                                    let v86 : (string []) = [|v85|]
                                    let v87 : int32 = v86.Length
                                    let v88 : int32 = v77.Length
                                    let v89 : int32 = v87 + v88
                                    let v90 : (string []) = Array.zeroCreate&lt;string&gt; (v89)
                                    let v91 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v89, v91) do
                                        let v93 : int32 = v91.l0
                                        let v94 : bool = v93 &lt; v87
                                        let v98 : string =
                                            if v94 then
                                                let v95 : string = v86.[int v93]
                                                v95
                                            else
                                                let v96 : int32 = v93 - v87
                                                let v97 : string = v77.[int v96]
                                                v97
                                        v90.[int v93] &lt;- v98
                                        let v99 : int32 = v93 + 1
                                        v91.l0 &lt;- v99
                                        ()
                                    struct (0, v90)
                                else
                                    let v100 : (string []) = [|v78|]
                                    let v101 : int32 = v100.Length
                                    let v102 : int32 = v77.Length
                                    let v103 : int32 = v101 + v102
                                    let v104 : (string []) = Array.zeroCreate&lt;string&gt; (v103)
                                    let v105 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v103, v105) do
                                        let v107 : int32 = v105.l0
                                        let v108 : bool = v107 &lt; v101
                                        let v112 : string =
                                            if v108 then
                                                let v109 : string = v100.[int v107]
                                                v109
                                            else
                                                let v110 : int32 = v107 - v101
                                                let v111 : string = v77.[int v110]
                                                v111
                                        v104.[int v107] &lt;- v112
                                        let v113 : int32 = v107 + 1
                                        v105.l0 &lt;- v113
                                        ()
                                    struct (0, v104)
                            else
                                let v116 : int32 = v76 - 1
                                struct (v116, v77)
                let v123 : int32 = v72 + 1
                v70.l0 &lt;- v123
                v70.l1 &lt;- v121
                v70.l2 &lt;- v122
                ()
            let struct (v124 : int32, v125 : (string [])) = v70.l1, v70.l2
            let v126 : string seq = seq { for i = 0 to v125.Length - 1 do yield v125.[i] }
            let v127 : char option = None
            let v128 : bool = true in let mutable _v127 = v127
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v129 : string = "std::path::MAIN_SEPARATOR"
            let v130 : char = Fable.Core.RustInterop.emitRustExpr () v129
            v130
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v131 : char = null |&gt; unbox&lt;char&gt;
            v131
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v132 : char = null |&gt; unbox&lt;char&gt;
            v132
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v133 : char = null |&gt; unbox&lt;char&gt;
            v133
#endif
            
#if FABLE_COMPILER_PYTHON
            let v134 : char = null |&gt; unbox&lt;char&gt;
            v134
#endif
            
#else
            let v135 : char = System.IO.Path.DirectorySeparatorChar
            v135
#endif
            |&gt; fun x -&gt; _v127 &lt;- Some x
            let v136 : char = _v127.Value
            let v137 : (char -&gt; string) = _.ToString()
            let v138 : string = v137 v136
            let v139 : string = method27(v138)
            let v140 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v141 : (string seq -&gt; string) = v140 v139
            v141 v126
        else
            let v143 : string = "std::fs::canonicalize(&amp;*$0)"
            let v144 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v3 v143
            let v145 : string = "$0.unwrap()"
            let v146 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v144 v145
            let v147 : string = "$0.display()"
            let v148 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v146 v147
            let v149 : std_string_String option = None
            let v150 : bool = true in let mutable _v149 = v149
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v151 : string = @$"format!(""{{}}"", $0)"
            let v152 : std_string_String = Fable.Core.RustInterop.emitRustExpr v148 v151
            v152
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v153 : string = @$"format!(""{{}}"", $0)"
            let v154 : std_string_String = Fable.Core.RustInterop.emitRustExpr v148 v153
            v154
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v155 : string = @$"format!(""{{}}"", $0)"
            let v156 : std_string_String = Fable.Core.RustInterop.emitRustExpr v148 v155
            v156
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v157 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v157
#endif
            
#if FABLE_COMPILER_PYTHON
            let v158 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v158
#endif
            
#else
            let v159 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v159
#endif
            |&gt; fun x -&gt; _v149 &lt;- Some x
            let v160 : std_string_String = _v149.Value
            let v161 : string = "fable_library_rust::String_::fromString($0)"
            let v162 : string = Fable.Core.RustInterop.emitRustExpr v160 v161
            v162
    v163
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v164 : string = null |&gt; unbox&lt;string&gt;
    v164
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v165 : string = null |&gt; unbox&lt;string&gt;
    v165
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v166 : string = null |&gt; unbox&lt;string&gt;
    v166
#endif
    
#if FABLE_COMPILER_PYTHON
    let v167 : string = null |&gt; unbox&lt;string&gt;
    v167
#endif
    
#else
    let v168 : string = method28(v0)
    let v169 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v170 : string = v169 v168
    v170
#endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v171 : string = _v1.Value
    let v172 : string option = None
    let v173 : bool = true in let mutable _v172 = v172
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v174 : string = method22()
    let v175 : string = method23(v171)
    let v176 : string = method24()
    let v177 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
    let v178 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v174, v175, v176) v177
    let v179 : string = "String::from($0)"
    let v180 : std_string_String = Fable.Core.RustInterop.emitRustExpr v178 v179
    let v181 : string = "fable_library_rust::String_::fromString($0)"
    let v182 : string = Fable.Core.RustInterop.emitRustExpr v180 v181
    v182
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v183 : string = null |&gt; unbox&lt;string&gt;
    v183
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v184 : string = null |&gt; unbox&lt;string&gt;
    v184
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v185 : string = null |&gt; unbox&lt;string&gt;
    v185
#endif
    
#if FABLE_COMPILER_PYTHON
    let v186 : string = null |&gt; unbox&lt;string&gt;
    v186
#endif
    
#else
    let v187 : string = "^\\\\\\\\\\?\\\\"
    let v188 : string = ""
    let v189 : string = System.Text.RegularExpressions.Regex.Replace (v171, v187, v188)
    v189
#endif
    |&gt; fun x -&gt; _v172 &lt;- Some x
    let v190 : string = _v172.Value
    let v191 : string = $"{v190.[0] |&gt; string |&gt; _.ToLower()}{v190.[1..]}"
    let v192 : string = "\\"
    let v193 : string = "/"
    let v194 : string = v191.Replace (v192, v193)
    v194
and method39 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) : string =
    v1
and method40 () : struct (string * string) =
    let v0 : string = ""
    struct (v0, v0)
and closure27 (v0 : char) (v1 : UH0) : UH0 =
    UH0_1(v0, v1)
and closure26 () (v0 : char) : (UH0 -&gt; UH0) =
    closure27(v0)
and method41 () : (char -&gt; (UH0 -&gt; UH0)) =
    closure26()
and method42 (v0 : string, v1 : string, v2 : UH0, v3 : US8) : struct (string * string) =
    match v2 with
    | UH0_1(v4, v5) -&gt; (* Cons *)
        let v6 : bool = '"' = v4
        if v6 then
            let v8 : bool = v1 = ""
            if v8 then
                let v9 : US9 = US9_0
                let v10 : US8 = US8_1(v9)
                method42(v0, v1, v5, v10)
            else
                match v3 with
                | US8_2 -&gt; (* Arguments *)
                    let v38 : string = $"{v0}{v4}"
                    let v39 : US8 = US8_2
                    method42(v38, v1, v5, v39)
                | US8_1(v13) -&gt; (* Path *)
                    match v13 with
                    | US9_0 -&gt; (* Quoted *)
                        let v14 : US9 = US9_1
                        let v15 : US8 = US8_1(v14)
                        method42(v0, v1, v5, v15)
                    | _ -&gt;
                        let v18 : bool = ' ' = v4
                        if v18 then
                            let v19 : US8 = US8_2
                            method42(v0, v1, v5, v19)
                        else
                            let v22 : string = $"{v1}{v4}"
                            method42(v0, v22, v5, v3)
                | US8_0 -&gt; (* Start *)
                    let v29 : bool = ' ' = v4
                    if v29 then
                        let v30 : US8 = US8_2
                        method42(v0, v1, v5, v30)
                    else
                        let v33 : string = $"{v1}{v4}"
                        method42(v0, v33, v5, v3)
        else
            let v50 : bool = ''' = v4
            if v50 then
                let v52 : bool = v1 = ""
                if v52 then
                    let v53 : US9 = US9_0
                    let v54 : US8 = US8_1(v53)
                    method42(v0, v1, v5, v54)
                else
                    match v3 with
                    | US8_2 -&gt; (* Arguments *)
                        let v82 : string = $"{v0}{v4}"
                        let v83 : US8 = US8_2
                        method42(v82, v1, v5, v83)
                    | US8_1(v57) -&gt; (* Path *)
                        match v57 with
                        | US9_0 -&gt; (* Quoted *)
                            let v58 : US9 = US9_1
                            let v59 : US8 = US8_1(v58)
                            method42(v0, v1, v5, v59)
                        | _ -&gt;
                            let v62 : bool = ' ' = v4
                            if v62 then
                                let v63 : US8 = US8_2
                                method42(v0, v1, v5, v63)
                            else
                                let v66 : string = $"{v1}{v4}"
                                method42(v0, v66, v5, v3)
                    | US8_0 -&gt; (* Start *)
                        let v73 : bool = ' ' = v4
                        if v73 then
                            let v74 : US8 = US8_2
                            method42(v0, v1, v5, v74)
                        else
                            let v77 : string = $"{v1}{v4}"
                            method42(v0, v77, v5, v3)
            else
                match v3 with
                | US8_2 -&gt; (* Arguments *)
                    let v126 : string = $"{v0}{v4}"
                    let v127 : US8 = US8_2
                    method42(v126, v1, v5, v127)
                | US8_1(v94) -&gt; (* Path *)
                    match v94 with
                    | US9_0 -&gt; (* Quoted *)
                        let v95 : bool = ' ' = v4
                        if v95 then
                            let v96 : string = $"{v1} "
                            let v97 : US9 = US9_0
                            let v98 : US8 = US8_1(v97)
                            method42(v0, v96, v5, v98)
                        else
                            let v101 : string = $"{v1}{v4}"
                            method42(v0, v101, v5, v3)
                    | _ -&gt;
                        let v106 : bool = ' ' = v4
                        if v106 then
                            let v107 : US8 = US8_2
                            method42(v0, v1, v5, v107)
                        else
                            let v110 : string = $"{v1}{v4}"
                            method42(v0, v110, v5, v3)
                | US8_0 -&gt; (* Start *)
                    let v117 : bool = ' ' = v4
                    if v117 then
                        let v118 : US8 = US8_2
                        method42(v0, v1, v5, v118)
                    else
                        let v121 : string = $"{v1}{v4}"
                        method42(v0, v121, v5, v3)
    | _ -&gt;
        match v3 with
        | US8_2 -&gt; (* Arguments *)
            let v152 : string = "\\"
            let v153 : string = "/"
            let v154 : string = v1.Replace (v152, v153)
            struct (v154, v0)
        | US8_1(v140) -&gt; (* Path *)
            match v140 with
            | US9_0 -&gt; (* Quoted *)
                let v141 : string = "\\"
                let v142 : string = "/"
                let v143 : string = v1.Replace (v141, v142)
                struct (v143, v0)
            | _ -&gt;
                let v144 : string = "\\"
                let v145 : string = "/"
                let v146 : string = v1.Replace (v144, v145)
                struct (v146, v0)
        | US8_0 -&gt; (* Start *)
            let v149 : string = "\\"
            let v150 : string = "/"
            let v151 : string = v1.Replace (v149, v150)
            struct (v151, v0)
and method46 (v0 : UH1, v1 : UH1) : UH1 =
    match v0 with
    | UH1_1(v2, v3) -&gt; (* Cons *)
        let v4 : UH1 = method46(v3, v1)
        UH1_1(v2, v4)
    | UH1_0 -&gt; (* Nil *)
        v1
and method45 (v0 : string, v1 : UH1, v2 : UH0, v3 : US10) : struct (UH1 * string) =
    match v3 with
    | US10_2(v44) -&gt; (* Escaped *)
        match v2 with
        | UH0_1(v45, v46) -&gt; (* Cons *)
            let v47 : bool = '\\' = v45
            if v47 then
                let v48 : char = '\\'
                let v49 : US10 = US10_1(v48)
                method44(v0, v1, v46, v3, v49)
            else
                let v52 : bool = '"' = v45
                if v52 then
                    let v54 : bool =
                        match v3 with
                        | US10_0 -&gt; (* Start *)
                            true
                        | _ -&gt;
                            false
                    if v54 then
                        method45(v0, v1, v46, v3)
                    else
                        let v57 : string = $"{v0}\""
                        let v58 : US10 = US10_2(v44)
                        method44(v57, v1, v46, v3, v58)
                else
                    let v63 : bool = ' ' = v45
                    if v63 then
                        let v64 : string = $"{v0} "
                        method45(v64, v1, v46, v3)
                    else
                        let v67 : bool = 1uy = v44
                        if v67 then
                            let v68 : bool = v3 &lt;&gt; v3
                            if v68 then
                                let v69 : string = $"{v0}\{v45}"
                                method45(v69, v1, v46, v3)
                            else
                                let v72 : string = $"{v0}{v45}"
                                method45(v72, v1, v46, v3)
                        else
                            let v77 : string = $"{v0}{v45}"
                            method45(v77, v1, v46, v3)
        | _ -&gt;
            let v88 : bool = 1uy = v44
            if v88 then
                let v90 : bool = v0 = ""
                let v94 : UH1 =
                    if v90 then
                        v1
                    else
                        let v91 : UH1 = UH1_0
                        let v92 : UH1 = UH1_1(v0, v91)
                        method46(v1, v92)
                struct (v94, v0)
            else
                let v96 : bool = v0 = ""
                let v100 : UH1 =
                    if v96 then
                        v1
                    else
                        let v97 : UH1 = UH1_0
                        let v98 : UH1 = UH1_1(v0, v97)
                        method46(v1, v98)
                struct (v100, v0)
    | US10_1(v105) -&gt; (* Quoted *)
        let v106 : bool = '"' = v105
        if v106 then
            match v2 with
            | UH0_1(v107, v108) -&gt; (* Cons *)
                let v109 : bool = '"' = v107
                if v109 then
                    let v110 : US10 = US10_1('\\')
                    let v111 : bool = v3 = v110
                    if v111 then
                        let v112 : US10 = US10_0
                        method44(v0, v1, v108, v3, v112)
                    else
                        let v115 : bool = '\\' = v105
                        if v115 then
                            let v116 : US10 = US10_2(0uy)
                            let v117 : bool = v3 &lt;&gt; v116
                            if v117 then
                                let v118 : string = $"{v0}\""
                                let v119 : char = '"'
                                let v120 : US10 = US10_1(v119)
                                method44(v118, v1, v108, v3, v120)
                            else
                                let v123 : US10 = US10_1('\\')
                                let v124 : bool = v3 = v123
                                if v124 then
                                    let v125 : string = $"{v0}\""
                                    let v126 : char = '"'
                                    let v127 : US10 = US10_1(v126)
                                    method44(v125, v1, v108, v3, v127)
                                else
                                    let v130 : US10 = US10_0
                                    method44(v0, v1, v108, v3, v130)
                        else
                            let v137 : bool = '\\' = v107
                            if v137 then
                                let v138 : uint8 = 1uy
                                let v139 : US10 = US10_2(v138)
                                method44(v0, v1, v108, v3, v139)
                            else
                                let v142 : US10 = US10_2(0uy)
                                let v143 : bool = v3 = v142
                                if v143 then
                                    let v144 : string = $"{v0}\""
                                    let v145 : char = '"'
                                    let v146 : US10 = US10_1(v145)
                                    method44(v144, v1, v108, v3, v146)
                                else
                                    let v149 : UH1 = UH1_0
                                    let v150 : UH1 = UH1_1(v0, v149)
                                    let v151 : UH1 = method46(v1, v150)
                                    let v152 : string = ""
                                    let v153 : US10 = US10_0
                                    method44(v152, v151, v108, v3, v153)
                else
                    let v164 : bool = '\\' = v105
                    if v164 then
                        let v165 : bool = '\\' = v107
                        if v165 then
                            let v166 : uint8 = 1uy
                            let v167 : US10 = US10_2(v166)
                            method44(v0, v1, v108, v3, v167)
                        else
                            let v170 : bool = ' ' = v107
                            if v170 then
                                let v171 : string = $"{v0} "
                                method45(v171, v1, v108, v3)
                            else
                                let v174 : string = $"{v0}{v107}"
                                method45(v174, v1, v108, v3)
                    else
                        let v181 : bool = '\\' = v107
                        if v181 then
                            let v182 : uint8 = 1uy
                            let v183 : US10 = US10_2(v182)
                            method44(v0, v1, v108, v3, v183)
                        else
                            let v186 : bool = ' ' = v107
                            if v186 then
                                let v187 : string = $"{v0} "
                                method45(v187, v1, v108, v3)
                            else
                                let v190 : string = $"{v0}{v107}"
                                method45(v190, v1, v108, v3)
            | _ -&gt;
                let v201 : bool = '\\' = v105
                if v201 then
                    let v203 : bool = v0 = ""
                    let v207 : UH1 =
                        if v203 then
                            v1
                        else
                            let v204 : UH1 = UH1_0
                            let v205 : UH1 = UH1_1(v0, v204)
                            method46(v1, v205)
                    struct (v207, v0)
                else
                    let v209 : bool = v0 = ""
                    let v213 : UH1 =
                        if v209 then
                            v1
                        else
                            let v210 : UH1 = UH1_0
                            let v211 : UH1 = UH1_1(v0, v210)
                            method46(v1, v211)
                    struct (v213, v0)
        else
            let v218 : bool = '\\' = v105
            if v218 then
                match v2 with
                | UH0_1(v219, v220) -&gt; (* Cons *)
                    let v221 : bool = '"' = v219
                    if v221 then
                        let v222 : US10 = US10_2(0uy)
                        let v223 : bool = v3 &lt;&gt; v222
                        if v223 then
                            let v224 : string = $"{v0}\""
                            let v225 : char = '"'
                            let v226 : US10 = US10_1(v225)
                            method44(v224, v1, v220, v3, v226)
                        else
                            let v229 : US10 = US10_1('\\')
                            let v230 : bool = v3 = v229
                            if v230 then
                                let v231 : string = $"{v0}\""
                                let v232 : char = '"'
                                let v233 : US10 = US10_1(v232)
                                method44(v231, v1, v220, v3, v233)
                            else
                                let v236 : US10 = US10_0
                                method44(v0, v1, v220, v3, v236)
                    else
                        let v243 : bool = '\\' = v219
                        if v243 then
                            let v244 : uint8 = 1uy
                            let v245 : US10 = US10_2(v244)
                            method44(v0, v1, v220, v3, v245)
                        else
                            let v248 : bool = ' ' = v219
                            if v248 then
                                let v249 : string = $"{v0} "
                                method45(v249, v1, v220, v3)
                            else
                                let v252 : string = $"{v0}{v219}"
                                method45(v252, v1, v220, v3)
                | _ -&gt;
                    let v262 : bool = v0 = ""
                    let v266 : UH1 =
                        if v262 then
                            v1
                        else
                            let v263 : UH1 = UH1_0
                            let v264 : UH1 = UH1_1(v0, v263)
                            method46(v1, v264)
                    struct (v266, v0)
            else
                match v2 with
                | UH0_1(v269, v270) -&gt; (* Cons *)
                    let v271 : bool = '\\' = v269
                    if v271 then
                        let v272 : uint8 = 1uy
                        let v273 : US10 = US10_2(v272)
                        method44(v0, v1, v270, v3, v273)
                    else
                        let v276 : bool = '"' = v269
                        if v276 then
                            let v277 : US10 = US10_2(0uy)
                            let v278 : bool = v3 = v277
                            if v278 then
                                let v279 : string = $"{v0}\""
                                let v280 : char = '"'
                                let v281 : US10 = US10_1(v280)
                                method44(v279, v1, v270, v3, v281)
                            else
                                let v284 : UH1 = UH1_0
                                let v285 : UH1 = UH1_1(v0, v284)
                                let v286 : UH1 = method46(v1, v285)
                                let v287 : string = ""
                                let v288 : US10 = US10_0
                                method44(v287, v286, v270, v3, v288)
                        else
                            let v293 : bool = ' ' = v269
                            if v293 then
                                let v294 : string = $"{v0} "
                                method45(v294, v1, v270, v3)
                            else
                                let v297 : string = $"{v0}{v269}"
                                method45(v297, v1, v270, v3)
                | _ -&gt;
                    let v307 : bool = v0 = ""
                    let v311 : UH1 =
                        if v307 then
                            v1
                        else
                            let v308 : UH1 = UH1_0
                            let v309 : UH1 = UH1_1(v0, v308)
                            method46(v1, v309)
                    struct (v311, v0)
    | US10_0 -&gt; (* Start *)
        match v2 with
        | UH0_1(v4, v5) -&gt; (* Cons *)
            let v6 : bool = '"' = v4
            if v6 then
                let v7 : string = ""
                let v8 : char = '"'
                let v9 : US10 = US10_1(v8)
                method44(v7, v1, v5, v3, v9)
            else
                let v12 : bool = '\\' = v4
                if v12 then
                    let v13 : uint8 = 0uy
                    let v14 : US10 = US10_2(v13)
                    method44(v0, v1, v5, v3, v14)
                else
                    let v17 : bool = ' ' = v4
                    if v17 then
                        let v19 : bool = v0 = ""
                        let v23 : UH1 =
                            if v19 then
                                v1
                            else
                                let v20 : UH1 = UH1_0
                                let v21 : UH1 = UH1_1(v0, v20)
                                method46(v1, v21)
                        let v24 : string = ""
                        method45(v24, v23, v5, v3)
                    else
                        let v27 : string = $"{v0}{v4}"
                        method45(v27, v1, v5, v3)
        | _ -&gt;
            let v37 : bool = v0 = ""
            let v41 : UH1 =
                if v37 then
                    v1
                else
                    let v38 : UH1 = UH1_0
                    let v39 : UH1 = UH1_1(v0, v38)
                    method46(v1, v39)
            struct (v41, v0)
and method44 (v0 : string, v1 : UH1, v2 : UH0, v3 : US10, v4 : US10) : struct (UH1 * string) =
    match v4 with
    | US10_2(v45) -&gt; (* Escaped *)
        match v2 with
        | UH0_1(v46, v47) -&gt; (* Cons *)
            let v48 : bool = '\\' = v46
            if v48 then
                let v49 : char = '\\'
                let v50 : US10 = US10_1(v49)
                method44(v0, v1, v47, v4, v50)
            else
                let v53 : bool = '"' = v46
                if v53 then
                    let v55 : bool =
                        match v3 with
                        | US10_0 -&gt; (* Start *)
                            true
                        | _ -&gt;
                            false
                    if v55 then
                        method45(v0, v1, v47, v4)
                    else
                        let v58 : string = $"{v0}\""
                        let v59 : US10 = US10_2(v45)
                        method44(v58, v1, v47, v4, v59)
                else
                    let v64 : bool = ' ' = v46
                    if v64 then
                        let v65 : string = $"{v0} "
                        method45(v65, v1, v47, v4)
                    else
                        let v68 : bool = 1uy = v45
                        if v68 then
                            let v69 : bool = v3 &lt;&gt; v4
                            if v69 then
                                let v70 : string = $"{v0}\{v46}"
                                method44(v70, v1, v47, v4, v3)
                            else
                                let v73 : string = $"{v0}{v46}"
                                method45(v73, v1, v47, v4)
                        else
                            let v78 : string = $"{v0}{v46}"
                            method45(v78, v1, v47, v4)
        | _ -&gt;
            let v89 : bool = 1uy = v45
            if v89 then
                let v91 : bool = v0 = ""
                let v95 : UH1 =
                    if v91 then
                        v1
                    else
                        let v92 : UH1 = UH1_0
                        let v93 : UH1 = UH1_1(v0, v92)
                        method46(v1, v93)
                struct (v95, v0)
            else
                let v97 : bool = v0 = ""
                let v101 : UH1 =
                    if v97 then
                        v1
                    else
                        let v98 : UH1 = UH1_0
                        let v99 : UH1 = UH1_1(v0, v98)
                        method46(v1, v99)
                struct (v101, v0)
    | US10_1(v106) -&gt; (* Quoted *)
        let v107 : bool = '"' = v106
        if v107 then
            match v2 with
            | UH0_1(v108, v109) -&gt; (* Cons *)
                let v110 : bool = '"' = v108
                if v110 then
                    let v111 : US10 = US10_1('\\')
                    let v112 : bool = v3 = v111
                    if v112 then
                        let v113 : US10 = US10_0
                        method44(v0, v1, v109, v4, v113)
                    else
                        let v116 : bool = '\\' = v106
                        if v116 then
                            let v117 : US10 = US10_2(0uy)
                            let v118 : bool = v3 &lt;&gt; v117
                            if v118 then
                                let v119 : string = $"{v0}\""
                                let v120 : char = '"'
                                let v121 : US10 = US10_1(v120)
                                method44(v119, v1, v109, v4, v121)
                            else
                                let v124 : US10 = US10_1('\\')
                                let v125 : bool = v3 = v124
                                if v125 then
                                    let v126 : string = $"{v0}\""
                                    let v127 : char = '"'
                                    let v128 : US10 = US10_1(v127)
                                    method44(v126, v1, v109, v4, v128)
                                else
                                    let v131 : US10 = US10_0
                                    method44(v0, v1, v109, v4, v131)
                        else
                            let v138 : bool = '\\' = v108
                            if v138 then
                                let v139 : uint8 = 1uy
                                let v140 : US10 = US10_2(v139)
                                method44(v0, v1, v109, v4, v140)
                            else
                                let v143 : US10 = US10_2(0uy)
                                let v144 : bool = v3 = v143
                                if v144 then
                                    let v145 : string = $"{v0}\""
                                    let v146 : char = '"'
                                    let v147 : US10 = US10_1(v146)
                                    method44(v145, v1, v109, v4, v147)
                                else
                                    let v150 : UH1 = UH1_0
                                    let v151 : UH1 = UH1_1(v0, v150)
                                    let v152 : UH1 = method46(v1, v151)
                                    let v153 : string = ""
                                    let v154 : US10 = US10_0
                                    method44(v153, v152, v109, v4, v154)
                else
                    let v165 : bool = '\\' = v106
                    if v165 then
                        let v166 : bool = '\\' = v108
                        if v166 then
                            let v167 : uint8 = 1uy
                            let v168 : US10 = US10_2(v167)
                            method44(v0, v1, v109, v4, v168)
                        else
                            let v171 : bool = ' ' = v108
                            if v171 then
                                let v172 : string = $"{v0} "
                                method45(v172, v1, v109, v4)
                            else
                                let v175 : string = $"{v0}{v108}"
                                method45(v175, v1, v109, v4)
                    else
                        let v182 : bool = '\\' = v108
                        if v182 then
                            let v183 : uint8 = 1uy
                            let v184 : US10 = US10_2(v183)
                            method44(v0, v1, v109, v4, v184)
                        else
                            let v187 : bool = ' ' = v108
                            if v187 then
                                let v188 : string = $"{v0} "
                                method45(v188, v1, v109, v4)
                            else
                                let v191 : string = $"{v0}{v108}"
                                method45(v191, v1, v109, v4)
            | _ -&gt;
                let v202 : bool = '\\' = v106
                if v202 then
                    let v204 : bool = v0 = ""
                    let v208 : UH1 =
                        if v204 then
                            v1
                        else
                            let v205 : UH1 = UH1_0
                            let v206 : UH1 = UH1_1(v0, v205)
                            method46(v1, v206)
                    struct (v208, v0)
                else
                    let v210 : bool = v0 = ""
                    let v214 : UH1 =
                        if v210 then
                            v1
                        else
                            let v211 : UH1 = UH1_0
                            let v212 : UH1 = UH1_1(v0, v211)
                            method46(v1, v212)
                    struct (v214, v0)
        else
            let v219 : bool = '\\' = v106
            if v219 then
                match v2 with
                | UH0_1(v220, v221) -&gt; (* Cons *)
                    let v222 : bool = '"' = v220
                    if v222 then
                        let v223 : US10 = US10_2(0uy)
                        let v224 : bool = v3 &lt;&gt; v223
                        if v224 then
                            let v225 : string = $"{v0}\""
                            let v226 : char = '"'
                            let v227 : US10 = US10_1(v226)
                            method44(v225, v1, v221, v4, v227)
                        else
                            let v230 : US10 = US10_1('\\')
                            let v231 : bool = v3 = v230
                            if v231 then
                                let v232 : string = $"{v0}\""
                                let v233 : char = '"'
                                let v234 : US10 = US10_1(v233)
                                method44(v232, v1, v221, v4, v234)
                            else
                                let v237 : US10 = US10_0
                                method44(v0, v1, v221, v4, v237)
                    else
                        let v244 : bool = '\\' = v220
                        if v244 then
                            let v245 : uint8 = 1uy
                            let v246 : US10 = US10_2(v245)
                            method44(v0, v1, v221, v4, v246)
                        else
                            let v249 : bool = ' ' = v220
                            if v249 then
                                let v250 : string = $"{v0} "
                                method45(v250, v1, v221, v4)
                            else
                                let v253 : string = $"{v0}{v220}"
                                method45(v253, v1, v221, v4)
                | _ -&gt;
                    let v263 : bool = v0 = ""
                    let v267 : UH1 =
                        if v263 then
                            v1
                        else
                            let v264 : UH1 = UH1_0
                            let v265 : UH1 = UH1_1(v0, v264)
                            method46(v1, v265)
                    struct (v267, v0)
            else
                match v2 with
                | UH0_1(v270, v271) -&gt; (* Cons *)
                    let v272 : bool = '\\' = v270
                    if v272 then
                        let v273 : uint8 = 1uy
                        let v274 : US10 = US10_2(v273)
                        method44(v0, v1, v271, v4, v274)
                    else
                        let v277 : bool = '"' = v270
                        if v277 then
                            let v278 : US10 = US10_2(0uy)
                            let v279 : bool = v3 = v278
                            if v279 then
                                let v280 : string = $"{v0}\""
                                let v281 : char = '"'
                                let v282 : US10 = US10_1(v281)
                                method44(v280, v1, v271, v4, v282)
                            else
                                let v285 : UH1 = UH1_0
                                let v286 : UH1 = UH1_1(v0, v285)
                                let v287 : UH1 = method46(v1, v286)
                                let v288 : string = ""
                                let v289 : US10 = US10_0
                                method44(v288, v287, v271, v4, v289)
                        else
                            let v294 : bool = ' ' = v270
                            if v294 then
                                let v295 : string = $"{v0} "
                                method45(v295, v1, v271, v4)
                            else
                                let v298 : string = $"{v0}{v270}"
                                method45(v298, v1, v271, v4)
                | _ -&gt;
                    let v308 : bool = v0 = ""
                    let v312 : UH1 =
                        if v308 then
                            v1
                        else
                            let v309 : UH1 = UH1_0
                            let v310 : UH1 = UH1_1(v0, v309)
                            method46(v1, v310)
                    struct (v312, v0)
    | US10_0 -&gt; (* Start *)
        match v2 with
        | UH0_1(v5, v6) -&gt; (* Cons *)
            let v7 : bool = '"' = v5
            if v7 then
                let v8 : string = ""
                let v9 : char = '"'
                let v10 : US10 = US10_1(v9)
                method44(v8, v1, v6, v4, v10)
            else
                let v13 : bool = '\\' = v5
                if v13 then
                    let v14 : uint8 = 0uy
                    let v15 : US10 = US10_2(v14)
                    method44(v0, v1, v6, v4, v15)
                else
                    let v18 : bool = ' ' = v5
                    if v18 then
                        let v20 : bool = v0 = ""
                        let v24 : UH1 =
                            if v20 then
                                v1
                            else
                                let v21 : UH1 = UH1_0
                                let v22 : UH1 = UH1_1(v0, v21)
                                method46(v1, v22)
                        let v25 : string = ""
                        method45(v25, v24, v6, v4)
                    else
                        let v28 : string = $"{v0}{v5}"
                        method45(v28, v1, v6, v4)
        | _ -&gt;
            let v38 : bool = v0 = ""
            let v42 : UH1 =
                if v38 then
                    v1
                else
                    let v39 : UH1 = UH1_0
                    let v40 : UH1 = UH1_1(v0, v39)
                    method46(v1, v40)
            struct (v42, v0)
and method47 (v0 : UH1, v1 : string list) : string list =
    match v0 with
    | UH1_1(v2, v3) -&gt; (* Cons *)
        let v4 : string list = method47(v3, v1)
        let v5 : string list = v2 :: v4 
        v5
    | UH1_0 -&gt; (* Nil *)
        v1
and method43 (v0 : string) : (string []) =
    let v1 : UH1 = UH1_0
    let v2 : string = ""
    let v3 : bool = true in let mutable _v0 = None
    #if !FABLE_COMPILER &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v4 : (string -&gt; string option) = Option.ofObj
    let v5 : string option = v4 v0
    v5 
    #else
    Some v0 
    #endif
    |&gt; fun x -&gt; _v0 &lt;- Some x
    let v6 : string option = _v0.Value
    let v7 : (string -&gt; US4) = method19()
    let v8 : US4 = US4_1
    let v9 : US4 = v6 |&gt; Option.map v7 |&gt; Option.defaultValue v8 
    let v12 : string =
        match v9 with
        | US4_1 -&gt; (* None *)
            v2
        | US4_0(v10) -&gt; (* Some *)
            v10
    let v13 : int32 = v12.Length
    let v14 : (char []) = Array.zeroCreate&lt;char&gt; (v13)
    let v15 : Mut5 = {l0 = 0} : Mut5
    while method26(v13, v15) do
        let v17 : int32 = v15.l0
        let v18 : char = v12.[int v17]
        v14.[int v17] &lt;- v18
        let v19 : int32 = v17 + 1
        v15.l0 &lt;- v19
        ()
    let v20 : ((char []) -&gt; char list) = Array.toList
    let v21 : char list = v20 v14
    let v22 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v23 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v24 : (char list -&gt; (UH0 -&gt; UH0)) = v22 v23
    let v25 : (UH0 -&gt; UH0) = v24 v21
    let v26 : UH0 = UH0_0
    let v27 : UH0 = v25 v26
    let v28 : US10 = US10_0
    let v29 : US10 = US10_0
    let struct (v30 : UH1, v31 : string) = method44(v2, v1, v27, v29, v28)
    let v32 : string list = []
    let v33 : string list = method47(v30, v32)
    let v34 : (string list -&gt; (string [])) = List.toArray
    let v35 : (string []) = v34 v33
    v35
and closure28 () (v0 : string) : std_string_String =
    let v1 : string = method14(v0)
    let v2 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v3 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1 v2
    let v4 : string = "String::from($0)"
    let v5 : std_string_String = Fable.Core.RustInterop.emitRustExpr v3 v4
    v5
and closure29 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : string, v7 : Vec&lt;std_string_String&gt;) () : string =
    let v8 : string = $"execute_with_options / file_name: {v6} / arguments: %A{v7} / options: %A{struct (v0, v1, v2, v3, v4, v5)}"
    v8
and method48 () : (unit -&gt; string) =
    closure6()
and method50 (v0 : string) : string =
    v0
and method52 (v0 : std_sync_Mutex&lt;std_process_Child option&gt;) : std_sync_Mutex&lt;std_process_Child option&gt; =
    v0
and closure30 () (v0 : std_process_Child) : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; =
    let v1 : std_process_Child option = Some v0 
    let v2 : string = "std::sync::Mutex::new($0)"
    let v3 : std_sync_Mutex&lt;std_process_Child option&gt; = Fable.Core.RustInterop.emitRustExpr v1 v2
    let v4 : std_sync_Mutex&lt;std_process_Child option&gt; = method52(v3)
    let v5 : string = "std::sync::Arc::new(v4)"
    let v6 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v5
    v6
and method51 () : (std_process_Child -&gt; std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;) =
    closure30()
and method53 (v0 : Result&lt;std_process_Child, std_io_Error&gt;) : Result&lt;std_process_Child, std_io_Error&gt; =
    v0
and closure31 () (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;) : US11 =
    US11_0(v0)
and closure32 () (v0 : std_string_String) : US11 =
    US11_1(v0)
and closure33 (v0 : std_string_String) () : string =
    let v1 : string = $"execute_with_options -1 / error: {v0}"
    v1
and method54 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;) : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; =
    v0
and method55 (v0 : std_sync_Mutex&lt;std_process_ChildStdout option&gt;) : std_sync_Mutex&lt;std_process_ChildStdout option&gt; =
    v0
and method56 (v0 : std_sync_Mutex&lt;std_process_ChildStderr option&gt;) : std_sync_Mutex&lt;std_process_ChildStderr option&gt; =
    v0
and method57 (v0 : std_sync_Mutex&lt;std_process_ChildStdin option&gt;) : std_sync_Mutex&lt;std_process_ChildStdin option&gt; =
    v0
and method58 (v0 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;) : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt; =
    v0
and method59 (v0 : std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;) : std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt; =
    v0
and method60 (v0 : std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt;) : std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt; =
    v0
and method61 (v0 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt;&gt;) : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt;&gt; =
    v0
and closure35 () (v0 : std_string_String) : US13 =
    US13_0(v0)
and closure36 () (v0 : std_string_String) : US13 =
    US13_1(v0)
and closure37 (v0 : std_string_String) () : string =
    let v1 : string = $"execute_with_options / stdout_line / stdout: {true} / e: {v0}"
    v1
and closure38 (v0 : std_string_String) () : string =
    let v1 : string = $"&gt; {v0}"
    v1
and closure34 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt;) (v1 : Result&lt;std_string_String, std_io_Error&gt;) : unit =
    let v2 : (std_io_Error -&gt; std_string_String) = method33()
    let v3 : string = "$0.map_err(|x| $1(x))"
    let v4 : Result&lt;std_string_String, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v1, v2) v3
    let v5 : (std_string_String -&gt; US13) = closure35()
    let v6 : (std_string_String -&gt; US13) = closure36()
    let v7 : US13 = match v4 with Ok x -&gt; v5 x | Error x -&gt; v6 x
    let v23 : std_string_String =
        match v7 with
        | US13_1(v12) -&gt; (* Error *)
            let v13 : US0 = US0_4
            let v14 : (unit -&gt; string) = closure37(v12)
            let v15 : (unit -&gt; string) = closure6()
            method3(v13, v14, v15)
            let v16 : string = $"[{v12}]"
            let v17 : string = method14(v16)
            let v18 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v19 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v17 v18
            let v20 : string = "String::from($0)"
            let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v20
            v21
        | US13_0(v8) -&gt; (* Ok *)
            let v9 : US0 = US0_0
            let v10 : (unit -&gt; string) = closure38(v8)
            let v11 : (unit -&gt; string) = closure6()
            method3(v9, v10, v11)
            v8
    let v24 : string = "true; $0.lock().unwrap().send($1).unwrap()"
    let v25 : bool = Fable.Core.RustInterop.emitRustExpr struct (v0, v23) v24
    ()
and method62 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt;) : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) =
    closure34(v0)
and method63 (v0 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt;&gt;) : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt;&gt; =
    v0
and closure40 (v0 : std_string_String) () : string =
    let v1 : string = $"execute_with_options / stdout_line / stdout: {false} / e: {v0}"
    v1
and closure39 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt;) (v1 : Result&lt;std_string_String, std_io_Error&gt;) : unit =
    let v2 : (std_io_Error -&gt; std_string_String) = method33()
    let v3 : string = "$0.map_err(|x| $1(x))"
    let v4 : Result&lt;std_string_String, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v1, v2) v3
    let v5 : (std_string_String -&gt; US13) = closure35()
    let v6 : (std_string_String -&gt; US13) = closure36()
    let v7 : US13 = match v4 with Ok x -&gt; v5 x | Error x -&gt; v6 x
    let v23 : std_string_String =
        match v7 with
        | US13_1(v12) -&gt; (* Error *)
            let v13 : US0 = US0_4
            let v14 : (unit -&gt; string) = closure40(v12)
            let v15 : (unit -&gt; string) = closure6()
            method3(v13, v14, v15)
            let v16 : string = $"[{v12}]"
            let v17 : string = method14(v16)
            let v18 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v19 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v17 v18
            let v20 : string = "String::from($0)"
            let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v20
            v21
        | US13_0(v8) -&gt; (* Ok *)
            let v9 : US0 = US0_0
            let v10 : (unit -&gt; string) = closure38(v8)
            let v11 : (unit -&gt; string) = closure6()
            method3(v9, v10, v11)
            v8
    let v24 : string = "true; $0.lock().unwrap().send($1).unwrap()"
    let v25 : bool = Fable.Core.RustInterop.emitRustExpr struct (v0, v23) v24
    ()
and method64 (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt;) : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) =
    closure39(v0)
and closure41 () (v0 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit)) : US14 =
    US14_0(v0)
and method65 () : ((std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) -&gt; US14) =
    closure41()
and method66 (v0 : std_sync_Mutex&lt;std_process_ChildStdin&gt;) : std_sync_Mutex&lt;std_process_ChildStdin&gt; =
    v0
and closure42 () (v0 : std_process_ChildStdin) : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; =
    let v1 : string = "std::sync::Mutex::new($0)"
    let v2 : std_sync_Mutex&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v0 v1
    let v3 : std_sync_Mutex&lt;std_process_ChildStdin&gt; = method66(v2)
    let v4 : string = "std::sync::Arc::new(v3)"
    let v5 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v4
    v5
and closure43 () (v0 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;) : US15 =
    US15_0(v0)
and method67 () : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; US15) =
    closure43()
and method68 (v0 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt;) : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; =
    v0
and closure44 () (v0 : std_process_Output) : US16 =
    US16_0(v0)
and closure45 () (v0 : std_string_String) : US16 =
    US16_1(v0)
and closure46 (v0 : std_string_String) () : string =
    let v1 : string = $"execute_with_options -2 / error: {v0}"
    v1
and closure47 (v0 : int32, v1 : string) () : string =
    let v2 : string = $"execute_with_options / exit_code: {v0} / std_trace.Length: {v1.Length}"
    v2
and method69 (v0 : (int32 * string)) : (int32 * string) =
    v0
and method49 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : string, v7 : Vec&lt;std_string_String&gt;) : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; =
    let v8 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v8
    let v9 : string = "std::process::Command::new(&amp;*$0)"
    let v10 : std_process_Command = Fable.Core.RustInterop.emitRustExpr v6 v9
    let v11 : string = "true; let mut v10 = v10"
    let v12 : bool = Fable.Core.RustInterop.emitRustExpr () v11
    let v13 : string = "std::process::Command::args(&amp;mut $0, &amp;*$1)"
    let v14 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v10, v7) v13
    let v15 : string = "true; let mut v14 = v14"
    let v16 : bool = Fable.Core.RustInterop.emitRustExpr () v15
    let v17 : string = "std::process::Command::stdout(&amp;mut $0, std::process::Stdio::piped())"
    let v18 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v14 v17
    let v19 : string = "true; let mut v18 = v18"
    let v20 : bool = Fable.Core.RustInterop.emitRustExpr () v19
    let v21 : string = "std::process::Command::stderr(&amp;mut $0, std::process::Stdio::piped())"
    let v22 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v18 v21
    let v23 : string = "true; let mut v22 = v22"
    let v24 : bool = Fable.Core.RustInterop.emitRustExpr () v23
    let v25 : string = "std::process::Command::stdin(&amp;mut $0, std::process::Stdio::piped())"
    let v26 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v22 v25
    let v27 : (string -&gt; US4) = method19()
    let v28 : US4 = US4_1
    let v29 : US4 = v5 |&gt; Option.map v27 |&gt; Option.defaultValue v28 
    let v35 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; =
        match v29 with
        | US4_1 -&gt; (* None *)
            v26
        | US4_0(v30) -&gt; (* Some *)
            let v31 : string = method50(v30)
            let v32 : string = "std::process::Command::current_dir(v26, &amp;*v31)"
            let v33 : Ref&lt;Mut&lt;std_process_Command&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v32
            v33
    let v36 : string = "true; let mut v35 = v35"
    let v37 : bool = Fable.Core.RustInterop.emitRustExpr () v36
    let v38 : string = "std::process::Command::spawn(&amp;mut $0)"
    let v39 : Result&lt;std_process_Child, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v35 v38
    let v40 : (std_process_Child -&gt; std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;) = method51()
    let v41 : Result&lt;std_process_Child, std_io_Error&gt; = method53(v39)
    let v42 : string = "v41.map(|x| v40(x))"
    let v43 : Result&lt;std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v42
    let v44 : (std_io_Error -&gt; std_string_String) = method33()
    let v45 : string = "$0.map_err(|x| $1(x))"
    let v46 : Result&lt;std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt;, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v43, v44) v45
    let v47 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; -&gt; US11) = closure31()
    let v48 : (std_string_String -&gt; US11) = closure32()
    let v49 : US11 = match v46 with Ok x -&gt; v47 x | Error x -&gt; v48 x
    let struct (v192 : int32, v193 : US3, v194 : US12) =
        match v49 with
        | US11_1(v183) -&gt; (* Error *)
            let v184 : US0 = US0_4
            let v185 : (unit -&gt; string) = closure33(v183)
            let v186 : (unit -&gt; string) = closure6()
            method3(v184, v185, v186)
            let v187 : US3 = US3_0(v183)
            let v188 : US12 = US12_1
            struct (-1, v187, v188)
        | US11_0(v50) -&gt; (* Ok *)
            let v51 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_Child option&gt;&gt; = method54(v50)
            let v52 : string = "v51.lock().unwrap().as_mut().unwrap().stdout.take().unwrap()"
            let v53 : std_process_ChildStdout = Fable.Core.RustInterop.emitRustExpr () v52
            let v54 : string = "v51.lock().unwrap().as_mut().unwrap().stderr.take().unwrap()"
            let v55 : std_process_ChildStderr = Fable.Core.RustInterop.emitRustExpr () v54
            let v56 : string = "v51.lock().unwrap().as_mut().unwrap().stdin.take().unwrap()"
            let v57 : std_process_ChildStdin = Fable.Core.RustInterop.emitRustExpr () v56
            let v58 : std_process_ChildStdout option = Some v53 
            let v59 : string = "std::sync::Mutex::new($0)"
            let v60 : std_sync_Mutex&lt;std_process_ChildStdout option&gt; = Fable.Core.RustInterop.emitRustExpr v58 v59
            let v61 : std_sync_Mutex&lt;std_process_ChildStdout option&gt; = method55(v60)
            let v62 : string = "std::sync::Arc::new(v61)"
            let v63 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdout option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v62
            let v64 : std_process_ChildStderr option = Some v55 
            let v65 : string = "std::sync::Mutex::new($0)"
            let v66 : std_sync_Mutex&lt;std_process_ChildStderr option&gt; = Fable.Core.RustInterop.emitRustExpr v64 v65
            let v67 : std_sync_Mutex&lt;std_process_ChildStderr option&gt; = method56(v66)
            let v68 : string = "std::sync::Arc::new(v67)"
            let v69 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStderr option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v68
            let v70 : std_process_ChildStdin option = Some v57 
            let v71 : string = "std::sync::Mutex::new($0)"
            let v72 : std_sync_Mutex&lt;std_process_ChildStdin option&gt; = Fable.Core.RustInterop.emitRustExpr v70 v71
            let v73 : std_sync_Mutex&lt;std_process_ChildStdin option&gt; = method57(v72)
            let v74 : string = "std::sync::Arc::new(v73)"
            let v75 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin option&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v74
            let v76 : string = "{ let (sender, receiver) = std::sync::mpsc::channel(); (sender, std::sync::Arc::new(receiver)) }"
            let struct (v77 : std_sync_mpsc_Sender&lt;std_string_String&gt;, v78 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;) = Fable.Core.RustInterop.emitRustExpr () v76
            let v79 : std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt; = method58(v78)
            let v80 : string = "true; let v79 = v79"
            let v81 : bool = Fable.Core.RustInterop.emitRustExpr v79 v80
            let v82 : string = "std::sync::Mutex::new($0)"
            let v83 : std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v77 v82
            let v84 : std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt; = method59(v83)
            let v85 : string = "std::sync::Arc::new(v84)"
            let v86 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v85
            let v87 : string = "v86.clone()"
            let v88 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v87
            let v89 : string = "v86.clone()"
            let v90 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_mpsc_Sender&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v89
            let v91 : string = "std::sync::Mutex::new($0)"
            let v92 : std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v79 v91
            let v93 : std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt; = method60(v92)
            let v94 : string = "std::sync::Arc::new(v93)"
            let v95 : std_sync_Arc&lt;std_sync_Mutex&lt;std_sync_Arc&lt;std_sync_mpsc_Receiver&lt;std_string_String&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v94
            let v96 : string = "std::thread::spawn(move || { //"
            let v97 : std_thread_JoinHandle&lt;unit&gt; = Fable.Core.RustInterop.emitRustExpr () v96
            let v98 : string = "v63.lock().unwrap().take().unwrap()"
            let v99 : std_process_ChildStdout = Fable.Core.RustInterop.emitRustExpr () v98
            let v100 : string = "std::io::BufReader::new(v99)"
            let v101 : std_io_BufReader&lt;std_process_ChildStdout&gt; = Fable.Core.RustInterop.emitRustExpr () v100
            let v102 : string = "std::io::BufRead::lines(v101)"
            let v103 : std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v102
            let v104 : string = "std::sync::Mutex::new($0)"
            let v105 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v103 v104
            let v106 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt;&gt; = method61(v105)
            let v107 : string = "std::sync::Arc::new(v106)"
            let v108 : std_sync_Arc&lt;std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStdout&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v107
            let v109 : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) = method62(v88)
            let v110 : string = "true; for line in $0.lock().unwrap().by_ref() { v109(line) }"
            let v111 : bool = Fable.Core.RustInterop.emitRustExpr v108 v110
            let v112 : string = "true; })"
            let v113 : bool = Fable.Core.RustInterop.emitRustExpr () v112
            let v114 : string = "std::thread::spawn(move || { //"
            let v115 : std_thread_JoinHandle&lt;unit&gt; = Fable.Core.RustInterop.emitRustExpr () v114
            let v116 : string = "v69.lock().unwrap().take().unwrap()"
            let v117 : std_process_ChildStderr = Fable.Core.RustInterop.emitRustExpr () v116
            let v118 : string = "std::io::BufReader::new(v117)"
            let v119 : std_io_BufReader&lt;std_process_ChildStderr&gt; = Fable.Core.RustInterop.emitRustExpr () v118
            let v120 : string = "std::io::BufRead::lines(v119)"
            let v121 : std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v120
            let v122 : string = "std::sync::Mutex::new($0)"
            let v123 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v121 v122
            let v124 : std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt;&gt; = method63(v123)
            let v125 : string = "std::sync::Arc::new(v124)"
            let v126 : std_sync_Arc&lt;std_sync_Mutex&lt;std_io_Lines&lt;std_io_BufReader&lt;std_process_ChildStderr&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v125
            let v127 : (Result&lt;std_string_String, std_io_Error&gt; -&gt; unit) = method64(v86)
            let v128 : string = "true; for line in $0.lock().unwrap().by_ref() { v127(line) }"
            let v129 : bool = Fable.Core.RustInterop.emitRustExpr v126 v128
            let v130 : string = "true; })"
            let v131 : bool = Fable.Core.RustInterop.emitRustExpr () v130
            let v132 : ((std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) -&gt; US14) = method65()
            let v133 : US14 = US14_1
            let v134 : US14 = v4 |&gt; Option.map v132 |&gt; Option.defaultValue v133 
            match v134 with
            | US14_1 -&gt; (* None *)
                ()
            | US14_0(v135) -&gt; (* Some *)
                let v136 : string = "v75.lock().unwrap().take()"
                let v137 : std_process_ChildStdin option = Fable.Core.RustInterop.emitRustExpr () v136
                let v138 : string = "$0.map(|x| $1(x))"
                let v139 : (std_process_ChildStdin -&gt; std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;) = closure42()
                let v140 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; option = Fable.Core.RustInterop.emitRustExpr struct (v137, v139) v138
                let v141 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; US15) = method67()
                let v142 : US15 = US15_1
                let v143 : US15 = v140 |&gt; Option.map v141 |&gt; Option.defaultValue v142 
                match v143 with
                | US15_1 -&gt; (* None *)
                    ()
                | US15_0(v144) -&gt; (* Some *)
                    v135 v144
                    let v145 : string = "$0.lock()"
                    let v146 : Result&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;, std_sync_PoisonError&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v144 v145
                    let v147 : string = "$0.unwrap()"
                    let v148 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v146 v147
                    let v149 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = method68(v148)
                    let v150 : string = "true; let mut v149 = v149"
                    let v151 : bool = Fable.Core.RustInterop.emitRustExpr () v150
                    let v152 : string = "true; std::io::Write::flush(&amp;mut *$0).unwrap()"
                    let v153 : bool = Fable.Core.RustInterop.emitRustExpr v149 v152
                    ()
            let v154 : string = "v51.lock().unwrap().take().unwrap().wait_with_output()"
            let v155 : Result&lt;std_process_Output, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v154
            let v156 : (std_io_Error -&gt; std_string_String) = method33()
            let v157 : string = "$0.map_err(|x| $1(x))"
            let v158 : Result&lt;std_process_Output, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v155, v156) v157
            let v159 : string = "true; v97.join().unwrap()"
            let v160 : bool = Fable.Core.RustInterop.emitRustExpr () v159
            let v161 : string = "true; v115.join().unwrap()"
            let v162 : bool = Fable.Core.RustInterop.emitRustExpr () v161
            let v163 : (std_process_Output -&gt; US16) = closure44()
            let v164 : (std_string_String -&gt; US16) = closure45()
            let v165 : US16 = match v158 with Ok x -&gt; v163 x | Error x -&gt; v164 x
            match v165 with
            | US16_1(v171) -&gt; (* Error *)
                let v172 : US0 = US0_4
                let v173 : (unit -&gt; string) = closure46(v171)
                let v174 : (unit -&gt; string) = closure6()
                method3(v172, v173, v174)
                let v175 : US3 = US3_0(v171)
                let v176 : US12 = US12_1
                struct (-2, v175, v176)
            | US16_0(v166) -&gt; (* Ok *)
                let v167 : string = "$0.status.code().unwrap()"
                let v168 : int32 = Fable.Core.RustInterop.emitRustExpr v166 v167
                let v169 : US3 = US3_1
                let v170 : US12 = US12_0(v95)
                struct (v168, v169, v170)
    let v201 : US3 =
        match v194 with
        | US12_1 -&gt; (* None *)
            US3_1
        | US12_0(v195) -&gt; (* Some *)
            let v196 : string = "$0.lock().unwrap().iter().collect::&lt;Vec&lt;String&gt;&gt;().join(\"\\n\")"
            let v197 : std_string_String = Fable.Core.RustInterop.emitRustExpr v195 v196
            US3_0(v197)
    let v208 : US4 =
        match v201 with
        | US3_1 -&gt; (* None *)
            US4_1
        | US3_0(v202) -&gt; (* Some *)
            let v203 : string = "fable_library_rust::String_::fromString($0)"
            let v204 : string = Fable.Core.RustInterop.emitRustExpr v202 v203
            US4_0(v204)
    let v215 : US4 =
        match v193 with
        | US3_1 -&gt; (* None *)
            US4_1
        | US3_0(v209) -&gt; (* Some *)
            let v210 : string = "fable_library_rust::String_::fromString($0)"
            let v211 : string = Fable.Core.RustInterop.emitRustExpr v209 v210
            US4_0(v211)
    let v219 : string =
        match v215 with
        | US4_1 -&gt; (* None *)
            let v217 : string = ""
            v217
        | US4_0(v216) -&gt; (* Some *)
            v216
    let v222 : string =
        match v208 with
        | US4_1 -&gt; (* None *)
            v219
        | US4_0(v220) -&gt; (* Some *)
            v220
    let v223 : US0 = US0_0
    let v224 : (unit -&gt; string) = closure47(v192, v222)
    let v225 : (unit -&gt; string) = closure6()
    method3(v223, v224, v225)
    let v226 : (int32 * string) = v192, v222
    let v227 : (int32 * string) = method69(v226)
    let v228 : string = "v227 }}})"
    Fable.Core.RustInterop.emitRustExpr () v228
    let v229 : string = "{{ //"
    Fable.Core.RustInterop.emitRustExpr () v229
    let v230 : string = "__result"
    let v231 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v230
    v231
and closure48 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option) () : string =
    let v6 : string = $"execute_with_options_async / options: %A{struct (v0, v1, v2, v3, v4, v5)}"
    v6
and closure50 () (v0 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;)) : US17 =
    US17_0(v0)
and method70 () : ((struct (bool * string * int32) -&gt; Async&lt;unit&gt;) -&gt; US17) =
    closure50()
and closure51 (v0 : string) () : string =
    let v1 : string = $"&gt; {v0}"
    v1
and closure49 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : System.Diagnostics.Process, v7 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) (v8 : System.Diagnostics.DataReceivedEventArgs) : unit =
    let v9 : Async&lt;unit&gt; option = None
    let v10 : bool = true in let mutable _v9 = v9
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v11 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v11
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v12 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v12
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v13 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v13
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v14 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v14
#endif
    
#if FABLE_COMPILER_PYTHON
    let v15 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v15
#endif
    
#else
    let v16 : Async&lt;unit&gt; option = None
    let mutable _v16 = v16
    async {
    let v17 : string = v8.Data
    let v18 : string = null |&gt; unbox&lt;string&gt;
    let v19 : bool = v17 = v18
    let v20 : bool = v19 &lt;&gt; true
    if v20 then
        let v21 : ((struct (bool * string * int32) -&gt; Async&lt;unit&gt;) -&gt; US17) = method70()
        let v22 : US17 = US17_1
        let v23 : US17 = v3 |&gt; Option.map v21 |&gt; Option.defaultValue v22 
        match v23 with
        | US17_1 -&gt; (* None *)
            ()
        | US17_0(v24) -&gt; (* Some *)
            let v25 : int32 = v6.Id
            let v26 : Async&lt;unit&gt; = v24 struct (false, v17, v25)
            do! v26 
            ()
        let v27 : US0 = US0_0
        let v28 : (unit -&gt; string) = closure51(v17)
        let v29 : (unit -&gt; string) = closure6()
        method3(v27, v28, v29)
        let v30 : string = ""
        let v31 : string = $"{v30}{v17}{v30}"
        let v32 : (string -&gt; unit) = v7.Push
        v32 v31
    }
    |&gt; fun x -&gt; _v16 &lt;- Some x
    let v33 : Async&lt;unit&gt; = _v16 |&gt; Option.get
    v33
#endif
    |&gt; fun x -&gt; _v9 &lt;- Some x
    let v34 : Async&lt;unit&gt; = _v9.Value
    let v35 : unit option = None
    let v36 : bool = true in let mutable _v35 = v35
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#else
    let v37 : (Async&lt;unit&gt; -&gt; unit) = Async.StartImmediate
    v37 v34
    ()
#endif
    |&gt; fun x -&gt; _v35 &lt;- Some x
    _v35.Value
    ()
and closure52 (v0 : System.Threading.CancellationToken option, v1 : string, v2 : (struct (string * string) []), v3 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option, v4 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option, v5 : string option, v6 : System.Diagnostics.Process, v7 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) (v8 : System.Diagnostics.DataReceivedEventArgs) : unit =
    let v9 : Async&lt;unit&gt; option = None
    let v10 : bool = true in let mutable _v9 = v9
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v11 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v11
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v12 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v12
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v13 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v13
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v14 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v14
#endif
    
#if FABLE_COMPILER_PYTHON
    let v15 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v15
#endif
    
#else
    let v16 : Async&lt;unit&gt; option = None
    let mutable _v16 = v16
    async {
    let v17 : string = v8.Data
    let v18 : string = null |&gt; unbox&lt;string&gt;
    let v19 : bool = v17 = v18
    let v20 : bool = v19 &lt;&gt; true
    if v20 then
        let v21 : ((struct (bool * string * int32) -&gt; Async&lt;unit&gt;) -&gt; US17) = method70()
        let v22 : US17 = US17_1
        let v23 : US17 = v3 |&gt; Option.map v21 |&gt; Option.defaultValue v22 
        match v23 with
        | US17_1 -&gt; (* None *)
            ()
        | US17_0(v24) -&gt; (* Some *)
            let v25 : int32 = v6.Id
            let v26 : Async&lt;unit&gt; = v24 struct (true, v17, v25)
            do! v26 
            ()
        let v27 : US0 = US0_0
        let v28 : (unit -&gt; string) = closure51(v17)
        let v29 : (unit -&gt; string) = closure6()
        method3(v27, v28, v29)
        let v30 : string = "["
        let v31 : string = "]"
        let v32 : string = $"{v30}{v17}{v31}"
        let v33 : (string -&gt; unit) = v7.Push
        v33 v32
    }
    |&gt; fun x -&gt; _v16 &lt;- Some x
    let v34 : Async&lt;unit&gt; = _v16 |&gt; Option.get
    v34
#endif
    |&gt; fun x -&gt; _v9 &lt;- Some x
    let v35 : Async&lt;unit&gt; = _v9.Value
    let v36 : unit option = None
    let v37 : bool = true in let mutable _v36 = v36
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#else
    let v38 : (Async&lt;unit&gt; -&gt; unit) = Async.StartImmediate
    v38 v35
    ()
#endif
    |&gt; fun x -&gt; _v36 &lt;- Some x
    _v36.Value
    ()
and closure53 () (v0 : System.Threading.CancellationToken) : US18 =
    US18_0(v0)
and method71 () : (System.Threading.CancellationToken -&gt; US18) =
    closure53()
and closure54 (v0 : System.Diagnostics.Process) () : unit =
    let v1 : bool option = None
    let v2 : bool = true in let mutable _v1 = v1
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v3 : bool = null |&gt; unbox&lt;bool&gt;
    v3
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v4 : bool = null |&gt; unbox&lt;bool&gt;
    v4
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v5 : bool = null |&gt; unbox&lt;bool&gt;
    v5
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v6 : bool = null |&gt; unbox&lt;bool&gt;
    v6
#endif
    
#if FABLE_COMPILER_PYTHON
    let v7 : bool = null |&gt; unbox&lt;bool&gt;
    v7
#endif
    
#else
    let v8 : bool = v0.HasExited
    v8
#endif
    |&gt; fun x -&gt; _v1 &lt;- Some x
    let v9 : bool = _v1.Value
    let v10 : bool = v9 = false
    if v10 then
        let v11 : unit option = None
        let v12 : bool = true in let mutable _v11 = v11
        
#if FABLE_COMPILER || WASM || CONTRACT
        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
        null |&gt; unbox&lt;unit&gt;
        ()
#endif
        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
        null |&gt; unbox&lt;unit&gt;
        ()
#endif
        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
        null |&gt; unbox&lt;unit&gt;
        ()
#endif
        
#if FABLE_COMPILER_TYPESCRIPT
        null |&gt; unbox&lt;unit&gt;
        ()
#endif
        
#if FABLE_COMPILER_PYTHON
        null |&gt; unbox&lt;unit&gt;
        ()
#endif
        
#else
        let v13 : (unit -&gt; unit) = v0.Kill
        v13 ()
        ()
#endif
        |&gt; fun x -&gt; _v11 &lt;- Some x
        _v11.Value
        ()
and closure55 (v0 : System.Threading.Tasks.TaskCanceledException) () : string =
    let v1 : string = $"execute_with_options_async / WaitForExitAsync / ex: %A{v0}"
    v1
and method72 () : string =
    let v0 : string = "\n"
    v0
and closure56 (v0 : int32, v1 : string) () : string =
    let v2 : string = $"execute_with_options_async / exit_code: {v0} / output.Length: {v1.Length}"
    v2
and method73 (v0 : string, v1 : string, v2 : string) : struct (string * string) =
    let v3 : string option = None
    let v4 : bool = true in let mutable _v3 = v3
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v5 : string = method14(v1)
    let v6 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v7 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v5 v6
    let v8 : string = "String::from($0)"
    let v9 : std_string_String = Fable.Core.RustInterop.emitRustExpr v7 v8
    let v10 : string = "std::path::PathBuf::from($0)"
    let v11 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "$0.file_name()"
    let v13 : Ref&lt;std_ffi_OsStr&gt; option = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "$0.unwrap()"
    let v15 : Ref&lt;std_ffi_OsStr&gt; = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "$0.to_os_string()"
    let v17 : std_ffi_OsString = Fable.Core.RustInterop.emitRustExpr v15 v16
    let v18 : string = "$0.to_str()"
    let v19 : Ref&lt;Str&gt; option = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : string = "$0.unwrap()"
    let v21 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v19 v20
    let v22 : string = "String::from($0)"
    let v23 : std_string_String = Fable.Core.RustInterop.emitRustExpr v21 v22
    let v24 : string = "fable_library_rust::String_::fromString($0)"
    let v25 : string = Fable.Core.RustInterop.emitRustExpr v23 v24
    v25
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v26 : string = null |&gt; unbox&lt;string&gt;
    v26
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v27 : string = null |&gt; unbox&lt;string&gt;
    v27
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v28 : string = null |&gt; unbox&lt;string&gt;
    v28
#endif
    
#if FABLE_COMPILER_PYTHON
    let v29 : string = null |&gt; unbox&lt;string&gt;
    v29
#endif
    
#else
    let v30 : (string -&gt; string) = System.IO.Path.GetFileName
    let v31 : string = v30 v1
    v31
#endif
    |&gt; fun x -&gt; _v3 &lt;- Some x
    let v32 : string = _v3.Value
    let v33 : string = method13(v2, v32)
    let v34 : string = "."
    let v35 : int32 = v1.LastIndexOf v34
    let v36 : int32 = v35 - 1
    let v37 : string = v1.[int 0..int v36]
    let v38 : int32 = v33.LastIndexOf v34
    let v39 : int32 = v38 - 1
    let v40 : string = v33.[int 0..int v39]
    let v41 : string = ".md"
    let v42 : bool = v0.EndsWith v41
    let v43 : bool = v42 = false
    let v46 : string =
        if v43 then
            let v44 : string = $"{v1}.{v0}"
            v44
        else
            let v45 : string = $"{v37}.{v0}"
            v45
    let v49 : string =
        if v43 then
            let v47 : string = $"{v33}.{v0}"
            v47
        else
            let v48 : string = $"{v40}.{v0}"
            v48
    struct (v49, v46)
and closure57 () () : string =
    let v0 : string = "documents.run / par_map / origin_hash |&gt; sm'.contains local_git_hash |&gt; not / hash2 = None || hash1 &lt;&gt;. (hash2 |&gt; optionm.value)"
    v0
and closure58 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : int32, v5 : string, v6 : string, v7 : int32, v8 : string, v9 : string, v10 : US4) () : string =
    let v11 : (unit -&gt; string) = closure6()
    let v12 : string = $"file: {v1} / real_path: {v2} / relative_path: {v0} / origin_hash_exit_code: {v4} / origin_hash: {v3} / local_git_hash_exit_code: {v7} / local_git_hash: {v6} / hash1: {v9} / hash2: %A{v10} / dist_path: {v5} / cache_path: {v8} / {v11 ()}"
    v12
and method74 (v0 : string) : string =
    v0
and method76 (v0 : int32, v1 : Mut6) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method77 (v0 : string) : string =
    v0
and method78 (v0 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt;) : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; =
    v0
and closure61 (v0 : string) (v1 : std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt;) : unit =
    let v2 : string = "$0.lock()"
    let v3 : Result&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;, std_sync_PoisonError&lt;std_sync_MutexGuard&lt;std_process_ChildStdin&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v1 v2
    let v4 : string = "$0.unwrap()"
    let v5 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = Fable.Core.RustInterop.emitRustExpr v3 v4
    let v6 : string = method77(v0)
    let v7 : string = "v6.as_bytes()"
    let v8 : Ref&lt;Slice&lt;uint8&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v7
    let v9 : std_sync_MutexGuard&lt;std_process_ChildStdin&gt; = method78(v5)
    let v10 : string = "true; let mut v9 = v9"
    let v11 : bool = Fable.Core.RustInterop.emitRustExpr () v10
    let v12 : string = "true; std::io::Write::write_all(&amp;mut *$0, v8).unwrap()"
    let v13 : bool = Fable.Core.RustInterop.emitRustExpr v9 v12
    ()
and method79 (v0 : int32, v1 : Mut7) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method80 (v0 : string) : string =
    v0
and closure62 () () : string =
    let v0 : string = "documents.hangul"
    v0
and closure63 (v0 : string, v1 : int32, v2 : string) () : string =
    let v3 : int32 = v2 |&gt; String.length
    let v4 : (unit -&gt; string) = closure6()
    let v5 : string = $"exit_code: %A{v1} / result_len: {v3} / output_path: {v0} / {v4 ()}"
    v5
and method75 (v0 : string, v1 : string, v2 : string, v3 : string) : US21 =
    let v4 : string option = None
    let v5 : bool = true in let mutable _v4 = v4
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v6 : Vec&lt;uint8&gt; option = None
    let v7 : bool = true in let mutable _v6 = v6
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v8 : string = "std::fs::read(&amp;*$0).unwrap()"
    let v9 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v3 v8
    v9
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v10 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v10
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v11 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v11
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v12 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v12
#endif
    
#if FABLE_COMPILER_PYTHON
    let v13 : Vec&lt;uint8&gt; = null |&gt; unbox&lt;Vec&lt;uint8&gt;&gt;
    v13
#endif
    
#else
    let v14 : (uint8 []) = v3 |&gt; System.IO.File.ReadAllBytes
    let v15 : string = "$0.to_vec()"
    let v16 : Vec&lt;uint8&gt; = Fable.Core.RustInterop.emitRustExpr v14 v15
    v16
#endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v17 : Vec&lt;uint8&gt; = _v6.Value
    let v18 : string = "std::string::String::from_utf8(v17)"
    let v19 : Result&lt;std_string_String, std_string_FromUtf8Error&gt; = Fable.Core.RustInterop.emitRustExpr () v18
    let v20 : string = "$0.unwrap()"
    let v21 : std_string_String = Fable.Core.RustInterop.emitRustExpr v19 v20
    let v22 : string = "fable_library_rust::String_::fromString($0)"
    let v23 : string = Fable.Core.RustInterop.emitRustExpr v21 v22
    v23
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v24 : string = null |&gt; unbox&lt;string&gt;
    v24
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v25 : string = null |&gt; unbox&lt;string&gt;
    v25
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v26 : string = null |&gt; unbox&lt;string&gt;
    v26
#endif
    
#if FABLE_COMPILER_PYTHON
    let v27 : string = null |&gt; unbox&lt;string&gt;
    v27
#endif
    
#else
    let v28 : string = v3 |&gt; System.IO.File.ReadAllText
    v28
#endif
    |&gt; fun x -&gt; _v4 &lt;- Some x
    let v29 : string = _v4.Value
    let v30 : string = "\n"
    let v31 : (string []) = v29.Split v30
    let v32 : int32 = v31.Length
    let v33 : (string []) = Array.zeroCreate&lt;string&gt; (v32)
    let v34 : Mut5 = {l0 = 0} : Mut5
    while method26(v32, v34) do
        let v36 : int32 = v34.l0
        let v37 : string = v31.[int v36]
        let v38 : string = v37.Trim ()
        v33.[int v36] &lt;- v38
        let v39 : int32 = v36 + 1
        v34.l0 &lt;- v39
        ()
    let v40 : int32 = v33.Length
    let v41 : (string []) = Array.zeroCreate&lt;string&gt; (v40)
    let v42 : Mut6 = {l0 = 0; l1 = 0} : Mut6
    while method76(v40, v42) do
        let v44 : int32 = v42.l0
        let v45 : int32 = v42.l1
        let v46 : string = v33.[int v44]
        let v47 : string = ""
        let v48 : bool = v47 &lt;&gt; v46
        let v50 : int32 =
            if v48 then
                v41.[int v45] &lt;- v46
                let v49 : int32 = v45 + 1
                v49
            else
                v45
        let v51 : int32 = v44 + 1
        v42.l0 &lt;- v51
        v42.l1 &lt;- v50
        ()
    let v52 : int32 = v42.l1
    let v53 : (string []) = Array.zeroCreate&lt;string&gt; (v52)
    let v54 : Mut5 = {l0 = 0} : Mut5
    while method26(v52, v54) do
        let v56 : int32 = v54.l0
        let v57 : string = v41.[int v56]
        v53.[int v56] &lt;- v57
        let v58 : int32 = v56 + 1
        v54.l0 &lt;- v58
        ()
    let v59 : string seq = seq { for i = 0 to v53.Length - 1 do yield v53.[i] }
    let v60 : string = method72()
    let v61 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v62 : (string seq -&gt; string) = v61 v60
    let v63 : string = v62 v59
    let v64 : string = $"{v63}

"
    let v65 : string option = None
    let v66 : System.Threading.CancellationToken option = None
    let v67 : (struct (string * string) []) = [||]
    let v68 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v69 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v70 : bool option = None
    let v71 : bool = true in let mutable _v70 = v70
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v72 : string = "cfg!(windows)"
    let v73 : bool = Fable.Core.RustInterop.emitRustExpr () v72
    v73
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v74 : bool = null |&gt; unbox&lt;bool&gt;
    v74
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v75 : bool = null |&gt; unbox&lt;bool&gt;
    v75
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v76 : bool = null |&gt; unbox&lt;bool&gt;
    v76
#endif
    
#if FABLE_COMPILER_PYTHON
    let v77 : bool = null |&gt; unbox&lt;bool&gt;
    v77
#endif
    
#else
    let v78 : System.Runtime.InteropServices.OSPlatform = System.Runtime.InteropServices.OSPlatform.Windows
    let v79 : (System.Runtime.InteropServices.OSPlatform -&gt; bool) = System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform
    let v80 : bool = v79 v78
    v80
#endif
    |&gt; fun x -&gt; _v70 &lt;- Some x
    let v81 : bool = _v70.Value
    let v84 : string =
        if v81 then
            let v82 : string = ".exe"
            v82
        else
            let v83 : string = ""
            v83
    let v85 : string = $"../vault/deps/hangulize/cmd/hangulize/hangulize{v84}"
    let v86 : string = method13(v0, v85)
    let v87 : string = $"{v86} {v1}"
    let v88 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) = closure61(v64)
    let v89 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = Some v88 
    let v90 : struct (int32 * string) option = None
    let v91 : bool = true in let mutable _v90 = v90
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v92 : string = method39(v66, v87, v67, v68, v89, v65)
    let struct (v93 : string, v94 : string) = method40()
    let v95 : int32 = v92.Length
    let v96 : (char []) = Array.zeroCreate&lt;char&gt; (v95)
    let v97 : Mut5 = {l0 = 0} : Mut5
    while method26(v95, v97) do
        let v99 : int32 = v97.l0
        let v100 : char = v92.[int v99]
        v96.[int v99] &lt;- v100
        let v101 : int32 = v99 + 1
        v97.l0 &lt;- v101
        ()
    let v102 : ((char []) -&gt; char list) = Array.toList
    let v103 : char list = v102 v96
    let v104 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v105 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v106 : (char list -&gt; (UH0 -&gt; UH0)) = v104 v105
    let v107 : (UH0 -&gt; UH0) = v106 v103
    let v108 : UH0 = UH0_0
    let v109 : UH0 = v107 v108
    let v110 : US8 = US8_0
    let struct (v111 : string, v112 : string) = method42(v94, v93, v109, v110)
    let v113 : (string []) = method43(v112)
    let v114 : string = "$0.to_vec()"
    let v115 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v113 v114
    let v116 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
    let v117 : (string -&gt; std_string_String) = closure28()
    let v118 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v115, v117) v116
    let v119 : US0 = US0_1
    let v120 : (unit -&gt; string) = closure29(v66, v87, v67, v68, v89, v65, v111, v118)
    let v121 : (unit -&gt; string) = method48()
    method3(v119, v120, v121)
    let v122 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v66, v87, v67, v68, v89, v65, v111, v118)
    let v123 : string = "futures_lite::future::block_on($0)"
    let v124 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v122 v123
    let (a, b) = v124
    let v125 : int32 = a
    let v126 : string = b
    struct (v125, v126)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v127 : int32, v128 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v127, v128)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v129 : int32, v130 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v129, v130)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v131 : int32, v132 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v131, v132)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v133 : int32, v134 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v133, v134)
#endif
    
#else
    let v135 : Async&lt;struct (int32 * string)&gt; option = None
    let v136 : bool = true in let mutable _v135 = v135
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v137 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v137
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v138 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v138
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v139 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v139
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v140 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v140
#endif
    
#if FABLE_COMPILER_PYTHON
    let v141 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v141
#endif
    
#else
    let v142 : Async&lt;struct (int32 * string)&gt; option = None
    let v143 : bool = true in let mutable _v142 = v142
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v144 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v144
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v145 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v145
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v146 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v146
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v147 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v147
#endif
    
#if FABLE_COMPILER_PYTHON
    let v148 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v148
#endif
    
#else
    let v149 : Async&lt;struct (int32 * string)&gt; option = None
    let mutable _v149 = v149
    async {
    let struct (v150 : string, v151 : string) = method40()
    let v152 : int32 = v87.Length
    let v153 : (char []) = Array.zeroCreate&lt;char&gt; (v152)
    let v154 : Mut5 = {l0 = 0} : Mut5
    while method26(v152, v154) do
        let v156 : int32 = v154.l0
        let v157 : char = v87.[int v156]
        v153.[int v156] &lt;- v157
        let v158 : int32 = v156 + 1
        v154.l0 &lt;- v158
        ()
    let v159 : ((char []) -&gt; char list) = Array.toList
    let v160 : char list = v159 v153
    let v161 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v162 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v163 : (char list -&gt; (UH0 -&gt; UH0)) = v161 v162
    let v164 : (UH0 -&gt; UH0) = v163 v160
    let v165 : UH0 = UH0_0
    let v166 : UH0 = v164 v165
    let v167 : US8 = US8_0
    let struct (v168 : string, v169 : string) = method42(v151, v150, v166, v167)
    let v170 : (string -&gt; US4) = method19()
    let v171 : US4 = US4_1
    let v172 : US4 = v65 |&gt; Option.map v170 |&gt; Option.defaultValue v171 
    let v176 : string =
        match v172 with
        | US4_1 -&gt; (* None *)
            let v174 : string = ""
            v174
        | US4_0(v173) -&gt; (* Some *)
            v173
    let v177 : US0 = US0_1
    let v178 : (unit -&gt; string) = closure48(v66, v87, v67, v68, v89, v65)
    let v179 : (unit -&gt; string) = method48()
    method3(v177, v178, v179)
    let v180 : System.Text.Encoding = System.Text.Encoding.UTF8
    let v181 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v169, StandardOutputEncoding = v180, WorkingDirectory = v176, FileName = v168, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
    let v182 : int32 = v67.Length
    let v183 : Mut5 = {l0 = 0} : Mut5
    while method26(v182, v183) do
        let v185 : int32 = v183.l0
        let struct (v186 : string, v187 : string) = v67.[int v185]
        v181.EnvironmentVariables.[v186] &lt;- v187 
        let v188 : int32 = v185 + 1
        v183.l0 &lt;- v188
        ()
    let v189 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v181)
    use v189 = v189 
    let v190 : System.Diagnostics.Process = v189 
    let v191 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
    let v192 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v191 ()
    let v193 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v66, v87, v67, v68, v89, v65, v190, v192)
    v190.OutputDataReceived.Add v193 
    let v194 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v66, v87, v67, v68, v89, v65, v190, v192)
    v190.ErrorDataReceived.Add v194 
    let v195 : (unit -&gt; bool) = v190.Start
    let v196 : bool = v195 ()
    let v197 : bool = v196 = false
    if v197 then
        let v198 : string = $"execute_with_options_async / process_start error"
        failwith&lt;unit&gt; v198
    let v199 : (unit -&gt; unit) = v190.BeginErrorReadLine
    v199 ()
    let v200 : (unit -&gt; unit) = v190.BeginOutputReadLine
    v200 ()
    let v201 : (System.Threading.CancellationToken -&gt; US18) = method71()
    let v202 : US18 = US18_1
    let v203 : US18 = v66 |&gt; Option.map v201 |&gt; Option.defaultValue v202 
    let v207 : System.Threading.CancellationToken =
        match v203 with
        | US18_1 -&gt; (* None *)
            let v205 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
            v205
        | US18_0(v204) -&gt; (* Some *)
            v204
    let v208 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v209 : bool = true in let mutable _v208 = v208
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v210 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v210
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v211 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v211
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v212 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v212
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v213 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v213
#endif
    
#if FABLE_COMPILER_PYTHON
    let v214 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v214
#endif
    
#else
    let v215 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v216 : bool = true in let mutable _v215 = v215
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v217 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v217
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v218 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v218
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v219 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v219
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v220 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v220
#endif
    
#if FABLE_COMPILER_PYTHON
    let v221 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v221
#endif
    
#else
    let v222 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let mutable _v222 = v222
    async {
    let v223 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
    let! v223 = v223 
    let v224 : System.Threading.CancellationToken = v223 
    let v225 : System.Threading.CancellationToken = Async.DefaultCancellationToken
    let v226 : (System.Threading.CancellationToken []) = [|v224; v225; v207|]
    let v227 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
    let v228 : System.Threading.CancellationTokenSource = v227 v226
    let v229 : System.Threading.CancellationToken = v228.Token
    return v229 
    }
    |&gt; fun x -&gt; _v222 &lt;- Some x
    let v230 : Async&lt;System.Threading.CancellationToken&gt; = _v222 |&gt; Option.get
    v230
#endif
    |&gt; fun x -&gt; _v215 &lt;- Some x
    let v231 : Async&lt;System.Threading.CancellationToken&gt; = _v215.Value
    v231
#endif
    |&gt; fun x -&gt; _v208 &lt;- Some x
    let v232 : Async&lt;System.Threading.CancellationToken&gt; = _v208.Value
    let! v232 = v232 
    let v233 : System.Threading.CancellationToken = v232 
    let v234 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v233.Register
    let v235 : (unit -&gt; unit) = closure54(v190)
    let v236 : System.Threading.CancellationTokenRegistration = v234 v235
    use v236 = v236 
    let v237 : System.Threading.CancellationTokenRegistration = v236 
    let v238 : Async&lt;int32&gt; option = None
    let v239 : bool = true in let mutable _v238 = v238
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v240 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v240
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v241 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v241
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v242 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v242
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v243 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v243
#endif
    
#if FABLE_COMPILER_PYTHON
    let v244 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v244
#endif
    
#else
    let v245 : Async&lt;int32&gt; option = None
    let mutable _v245 = v245
    async {
    try
    let v246 : System.Threading.Tasks.Task = v190.WaitForExitAsync v233 
    let v247 : Async&lt;unit&gt; option = None
    let v248 : bool = true in let mutable _v247 = v247
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v249 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v249
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v250 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v250
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v251 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v251
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v252 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v252
#endif
    
#if FABLE_COMPILER_PYTHON
    let v253 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v253
#endif
    
#else
    let v254 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
    let v255 : Async&lt;unit&gt; = v254 v246
    v255
#endif
    |&gt; fun x -&gt; _v247 &lt;- Some x
    let v256 : Async&lt;unit&gt; = _v247.Value
    do! v256 
    let v257 : int32 = v190.ExitCode
    return v257 
    with ex -&gt;
    let v258 : exn = ex
    let v259 : string option = None
    let v260 : bool = true in let mutable _v259 = v259
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v261 : string = $"%A{v258}"
    v261
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v262 : string = $"%A{v258}"
    v262
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v263 : string = $"%A{v258}"
    v263
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v264 : string = $"%A{v258}"
    v264
#endif
    
#if FABLE_COMPILER_PYTHON
    let v265 : string = $"%A{v258}"
    v265
#endif
    
#else
    let v266 : string = $"{v258.GetType ()}: {v258.Message}"
    v266
#endif
    |&gt; fun x -&gt; _v259 &lt;- Some x
    let v267 : string = _v259.Value
    let v268 : (string -&gt; unit) = v192.Push
    v268 v267
    let v269 : System.Threading.Tasks.TaskCanceledException = v258 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
    let v270 : US0 = US0_3
    let v271 : (unit -&gt; string) = closure55(v269)
    let v272 : (unit -&gt; string) = method48()
    method3(v270, v271, v272)
    return -2147483648 
    (*
    *)
    }
    |&gt; fun x -&gt; _v245 &lt;- Some x
    let v273 : Async&lt;int32&gt; = _v245 |&gt; Option.get
    v273
#endif
    |&gt; fun x -&gt; _v238 &lt;- Some x
    let v274 : Async&lt;int32&gt; = _v238.Value
    let! v274 = v274 
    let v275 : int32 = v274 
    let v276 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
    let v277 : string seq = v276 v192
    let v278 : string = method72()
    let v279 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v280 : (string seq -&gt; string) = v279 v278
    let v281 : string = v280 v277
    let v282 : US0 = US0_1
    let v283 : (unit -&gt; string) = closure56(v275, v281)
    let v284 : (unit -&gt; string) = method48()
    method3(v282, v283, v284)
    return struct (v275, v281) 
    }
    |&gt; fun x -&gt; _v149 &lt;- Some x
    let v285 : Async&lt;struct (int32 * string)&gt; = _v149 |&gt; Option.get
    v285
#endif
    |&gt; fun x -&gt; _v142 &lt;- Some x
    let v286 : Async&lt;struct (int32 * string)&gt; = _v142.Value
    v286
#endif
    |&gt; fun x -&gt; _v135 &lt;- Some x
    let v287 : Async&lt;struct (int32 * string)&gt; = _v135.Value
    let v288 : struct (int32 * string) option = None
    let v289 : bool = true in let mutable _v288 = v288
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let struct (v290 : int32, v291 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v290, v291)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v292 : int32, v293 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v292, v293)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v294 : int32, v295 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v294, v295)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v296 : int32, v297 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v296, v297)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v298 : int32, v299 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v298, v299)
#endif
    
#else
    let v300 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
    let struct (v301 : int32, v302 : string) = v300 v287
    struct (v301, v302)
#endif
    |&gt; fun x -&gt; _v288 &lt;- Some x
    let struct (v303 : int32, v304 : string) = _v288.Value
    struct (v303, v304)
#endif
    |&gt; fun x -&gt; _v90 &lt;- Some x
    let struct (v305 : int32, v306 : string) = _v90.Value
    let v307 : (string []) = v306.Split v30
    let v308 : int32 = v307.Length
    let v309 : string = ""
    let v310 : Mut7 = {l0 = 0; l1 = v309; l2 = 0; l3 = 0} : Mut7
    while method79(v40, v310) do
        let v312 : int32 = v310.l0
        let struct (v313 : string, v314 : int32, v315 : int32) = v310.l1, v310.l2, v310.l3
        let v316 : string = v33.[int v312]
        let v317 : bool = v316 = ""
        let struct (v331 : string, v332 : int32, v333 : int32) =
            if v317 then
                let v318 : string = $"{v313}
"
                let v319 : int32 = v314 + 1
                let v320 : int32 = v315 + 1
                struct (v318, v319, v320)
            else
                let v321 : int32 = v314 - v315
                let v322 : bool = v321 &gt;= v308
                let v329 : string =
                    if v322 then
                        v313
                    else
                        let v323 : string = v307.[int v321]
                        let v324 : int32 = v308 - 1
                        let v325 : bool = v321 = v324
                        if v325 then
                            let v326 : string = $"{v313}{v323}"
                            v326
                        else
                            let v327 : string = $"{v313}{v323}
"
                            v327
                let v330 : int32 = v314 + 1
                struct (v329, v330, v315)
        let v334 : int32 = v312 + 1
        v310.l0 &lt;- v334
        v310.l1 &lt;- v331
        v310.l2 &lt;- v332
        v310.l3 &lt;- v333
        ()
    let struct (v335 : string, v336 : int32, v337 : int32) = v310.l1, v310.l2, v310.l3
    let v338 : unit option = None
    let v339 : bool = true in let mutable _v338 = v338
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v340 : string = "std::fs::write(&amp;*$0, &amp;*$1).unwrap()"
    Fable.Core.RustInterop.emitRustExpr struct (v2, v335) v340
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#if FABLE_COMPILER_PYTHON
    null |&gt; unbox&lt;unit&gt;
    ()
#endif
    
#else
    let v341 : string = method80(v335)
    System.IO.File.WriteAllText (v2, v341)
    ()
#endif
    |&gt; fun x -&gt; _v338 &lt;- Some x
    _v338.Value
    let v342 : US0 = US0_2
    let v343 : (unit -&gt; string) = closure62()
    let v344 : (unit -&gt; string) = closure63(v2, v305, v335)
    method3(v342, v343, v344)
    US21_0(v305, v335)
and closure64 () () : string =
    let v0 : string = "documents.files_fn / error"
    v0
and closure65 (v0 : string, v1 : int32) () : string =
    let v2 : (unit -&gt; string) = closure6()
    let v3 : string = $"exit_code: %A{v1} / result: {v0} / {v2 ()}"
    v3
and closure60 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : string) (v5 : string) : US19 =
    let struct (v6 : string, v7 : string) = method73(v5, v4, v0)
    let v8 : bool option = None
    let v9 : bool = true in let mutable _v8 = v8
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v10 : string = method14(v7)
    let v11 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v12 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "String::from($0)"
    let v14 : std_string_String = Fable.Core.RustInterop.emitRustExpr v12 v13
    let v15 : string = "std::path::PathBuf::from($0)"
    let v16 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v17 : string = "$0.exists()"
    let v18 : bool = Fable.Core.RustInterop.emitRustExpr v16 v17
    let v21 : bool =
        if v18 then
            let v19 : string = "$0.is_file()"
            let v20 : bool = Fable.Core.RustInterop.emitRustExpr v16 v19
            v20
        else
            false
    v21
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v22 : bool = null |&gt; unbox&lt;bool&gt;
    v22
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v23 : bool = null |&gt; unbox&lt;bool&gt;
    v23
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v24 : string = "fs"
    let v25 : IFsExistsSync = Fable.Core.JsInterop.importAll v24
    let v26 : string = "$0.existsSync($1)"
    let v27 : bool = Fable.Core.JsInterop.emitJsExpr struct (v25, v7) v26
    v27
#endif
    
#if FABLE_COMPILER_PYTHON
    let v28 : bool = null |&gt; unbox&lt;bool&gt;
    v28
#endif
    
#else
    let v29 : (string -&gt; bool) = System.IO.File.Exists
    let v30 : bool = v29 v7
    v30
#endif
    |&gt; fun x -&gt; _v8 &lt;- Some x
    let v31 : bool = _v8.Value
    let v55 : bool =
        if v31 then
            let v32 : bool option = None
            let v33 : bool = true in let mutable _v32 = v32
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v34 : string = method14(v6)
            let v35 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v36 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v34 v35
            let v37 : string = "String::from($0)"
            let v38 : std_string_String = Fable.Core.RustInterop.emitRustExpr v36 v37
            let v39 : string = "std::path::PathBuf::from($0)"
            let v40 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v38 v39
            let v41 : string = "$0.exists()"
            let v42 : bool = Fable.Core.RustInterop.emitRustExpr v40 v41
            let v45 : bool =
                if v42 then
                    let v43 : string = "$0.is_file()"
                    let v44 : bool = Fable.Core.RustInterop.emitRustExpr v40 v43
                    v44
                else
                    false
            v45
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v46 : bool = null |&gt; unbox&lt;bool&gt;
            v46
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v47 : bool = null |&gt; unbox&lt;bool&gt;
            v47
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v48 : IFsExistsSync = Fable.Core.JsInterop.importAll v24
            let v49 : string = "$0.existsSync($1)"
            let v50 : bool = Fable.Core.JsInterop.emitJsExpr struct (v48, v6) v49
            v50
#endif
            
#if FABLE_COMPILER_PYTHON
            let v51 : bool = null |&gt; unbox&lt;bool&gt;
            v51
#endif
            
#else
            let v52 : (string -&gt; bool) = System.IO.File.Exists
            let v53 : bool = v52 v6
            v53
#endif
            |&gt; fun x -&gt; _v32 &lt;- Some x
            let v54 : bool = _v32.Value
            v54
        else
            false
    let v562 : bool =
        if v55 then
            let v56 : string option = None
            let v57 : bool = true in let mutable _v56 = v56
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v58 : string = method22()
            let v59 : string = method23(v7)
            let v60 : string = method24()
            let v61 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v62 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v58, v59, v60) v61
            let v63 : string = "String::from($0)"
            let v64 : std_string_String = Fable.Core.RustInterop.emitRustExpr v62 v63
            let v65 : string = "fable_library_rust::String_::fromString($0)"
            let v66 : string = Fable.Core.RustInterop.emitRustExpr v64 v65
            v66
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v67 : string = null |&gt; unbox&lt;string&gt;
            v67
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v68 : string = null |&gt; unbox&lt;string&gt;
            v68
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v69 : string = null |&gt; unbox&lt;string&gt;
            v69
#endif
            
#if FABLE_COMPILER_PYTHON
            let v70 : string = null |&gt; unbox&lt;string&gt;
            v70
#endif
            
#else
            let v71 : string = "^\\\\\\\\\\?\\\\"
            let v72 : string = ""
            let v73 : string = System.Text.RegularExpressions.Regex.Replace (v7, v71, v72)
            v73
#endif
            |&gt; fun x -&gt; _v56 &lt;- Some x
            let v74 : string = _v56.Value
            let v75 : string = $"{v74.[0] |&gt; string |&gt; _.ToLower()}{v74.[1..]}"
            let v76 : string = "\\"
            let v77 : string = "/"
            let v78 : string = v75.Replace (v76, v77)
            let v79 : string option = None
            let v80 : System.Threading.CancellationToken option = None
            let v81 : (struct (string * string) []) = [||]
            let v82 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
            let v83 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
            let v84 : string = $"pwsh -c \"(Get-FileHash \\\"{v78}\\\" -Algorithm SHA256).Hash\""
            let v85 : struct (int32 * string) option = None
            let v86 : bool = true in let mutable _v85 = v85
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v87 : string = method39(v80, v84, v81, v82, v83, v79)
            let struct (v88 : string, v89 : string) = method40()
            let v90 : int32 = v87.Length
            let v91 : (char []) = Array.zeroCreate&lt;char&gt; (v90)
            let v92 : Mut5 = {l0 = 0} : Mut5
            while method26(v90, v92) do
                let v94 : int32 = v92.l0
                let v95 : char = v87.[int v94]
                v91.[int v94] &lt;- v95
                let v96 : int32 = v94 + 1
                v92.l0 &lt;- v96
                ()
            let v97 : ((char []) -&gt; char list) = Array.toList
            let v98 : char list = v97 v91
            let v99 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v100 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v101 : (char list -&gt; (UH0 -&gt; UH0)) = v99 v100
            let v102 : (UH0 -&gt; UH0) = v101 v98
            let v103 : UH0 = UH0_0
            let v104 : UH0 = v102 v103
            let v105 : US8 = US8_0
            let struct (v106 : string, v107 : string) = method42(v89, v88, v104, v105)
            let v108 : (string []) = method43(v107)
            let v109 : string = "$0.to_vec()"
            let v110 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v108 v109
            let v111 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
            let v112 : (string -&gt; std_string_String) = closure28()
            let v113 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v110, v112) v111
            let v114 : US0 = US0_1
            let v115 : (unit -&gt; string) = closure29(v80, v84, v81, v82, v83, v79, v106, v113)
            let v116 : (unit -&gt; string) = method48()
            method3(v114, v115, v116)
            let v117 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v80, v84, v81, v82, v83, v79, v106, v113)
            let v118 : string = "futures_lite::future::block_on($0)"
            let v119 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v117 v118
            let (a, b) = v119
            let v120 : int32 = a
            let v121 : string = b
            struct (v120, v121)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v122 : int32, v123 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v122, v123)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v124 : int32, v125 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v124, v125)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v126 : int32, v127 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v126, v127)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v128 : int32, v129 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v128, v129)
#endif
            
#else
            let v130 : Async&lt;struct (int32 * string)&gt; option = None
            let v131 : bool = true in let mutable _v130 = v130
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v132 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v132
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v133 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v133
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v134 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v134
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v135 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v135
#endif
            
#if FABLE_COMPILER_PYTHON
            let v136 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v136
#endif
            
#else
            let v137 : Async&lt;struct (int32 * string)&gt; option = None
            let v138 : bool = true in let mutable _v137 = v137
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v139 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v139
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v140 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v140
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v141 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v141
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v142 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v142
#endif
            
#if FABLE_COMPILER_PYTHON
            let v143 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v143
#endif
            
#else
            let v144 : Async&lt;struct (int32 * string)&gt; option = None
            let mutable _v144 = v144
            async {
            let struct (v145 : string, v146 : string) = method40()
            let v147 : int32 = v84.Length
            let v148 : (char []) = Array.zeroCreate&lt;char&gt; (v147)
            let v149 : Mut5 = {l0 = 0} : Mut5
            while method26(v147, v149) do
                let v151 : int32 = v149.l0
                let v152 : char = v84.[int v151]
                v148.[int v151] &lt;- v152
                let v153 : int32 = v151 + 1
                v149.l0 &lt;- v153
                ()
            let v154 : ((char []) -&gt; char list) = Array.toList
            let v155 : char list = v154 v148
            let v156 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v157 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v158 : (char list -&gt; (UH0 -&gt; UH0)) = v156 v157
            let v159 : (UH0 -&gt; UH0) = v158 v155
            let v160 : UH0 = UH0_0
            let v161 : UH0 = v159 v160
            let v162 : US8 = US8_0
            let struct (v163 : string, v164 : string) = method42(v146, v145, v161, v162)
            let v165 : (string -&gt; US4) = method19()
            let v166 : US4 = US4_1
            let v167 : US4 = v79 |&gt; Option.map v165 |&gt; Option.defaultValue v166 
            let v170 : string =
                match v167 with
                | US4_1 -&gt; (* None *)
                    v72
                | US4_0(v168) -&gt; (* Some *)
                    v168
            let v171 : US0 = US0_1
            let v172 : (unit -&gt; string) = closure48(v80, v84, v81, v82, v83, v79)
            let v173 : (unit -&gt; string) = method48()
            method3(v171, v172, v173)
            let v174 : System.Text.Encoding = System.Text.Encoding.UTF8
            let v175 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v164, StandardOutputEncoding = v174, WorkingDirectory = v170, FileName = v163, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
            let v176 : int32 = v81.Length
            let v177 : Mut5 = {l0 = 0} : Mut5
            while method26(v176, v177) do
                let v179 : int32 = v177.l0
                let struct (v180 : string, v181 : string) = v81.[int v179]
                v175.EnvironmentVariables.[v180] &lt;- v181 
                let v182 : int32 = v179 + 1
                v177.l0 &lt;- v182
                ()
            let v183 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v175)
            use v183 = v183 
            let v184 : System.Diagnostics.Process = v183 
            let v185 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
            let v186 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v185 ()
            let v187 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v80, v84, v81, v82, v83, v79, v184, v186)
            v184.OutputDataReceived.Add v187 
            let v188 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v80, v84, v81, v82, v83, v79, v184, v186)
            v184.ErrorDataReceived.Add v188 
            let v189 : (unit -&gt; bool) = v184.Start
            let v190 : bool = v189 ()
            let v191 : bool = v190 = false
            if v191 then
                let v192 : string = $"execute_with_options_async / process_start error"
                failwith&lt;unit&gt; v192
            let v193 : (unit -&gt; unit) = v184.BeginErrorReadLine
            v193 ()
            let v194 : (unit -&gt; unit) = v184.BeginOutputReadLine
            v194 ()
            let v195 : (System.Threading.CancellationToken -&gt; US18) = method71()
            let v196 : US18 = US18_1
            let v197 : US18 = v80 |&gt; Option.map v195 |&gt; Option.defaultValue v196 
            let v201 : System.Threading.CancellationToken =
                match v197 with
                | US18_1 -&gt; (* None *)
                    let v199 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                    v199
                | US18_0(v198) -&gt; (* Some *)
                    v198
            let v202 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v203 : bool = true in let mutable _v202 = v202
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v204 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v204
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v205 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v205
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v206 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v206
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v207 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v207
#endif
            
#if FABLE_COMPILER_PYTHON
            let v208 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v208
#endif
            
#else
            let v209 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v210 : bool = true in let mutable _v209 = v209
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v211 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v211
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v212 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v212
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v213 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v213
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v214 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v214
#endif
            
#if FABLE_COMPILER_PYTHON
            let v215 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v215
#endif
            
#else
            let v216 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let mutable _v216 = v216
            async {
            let v217 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
            let! v217 = v217 
            let v218 : System.Threading.CancellationToken = v217 
            let v219 : System.Threading.CancellationToken = Async.DefaultCancellationToken
            let v220 : (System.Threading.CancellationToken []) = [|v218; v219; v201|]
            let v221 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
            let v222 : System.Threading.CancellationTokenSource = v221 v220
            let v223 : System.Threading.CancellationToken = v222.Token
            return v223 
            }
            |&gt; fun x -&gt; _v216 &lt;- Some x
            let v224 : Async&lt;System.Threading.CancellationToken&gt; = _v216 |&gt; Option.get
            v224
#endif
            |&gt; fun x -&gt; _v209 &lt;- Some x
            let v225 : Async&lt;System.Threading.CancellationToken&gt; = _v209.Value
            v225
#endif
            |&gt; fun x -&gt; _v202 &lt;- Some x
            let v226 : Async&lt;System.Threading.CancellationToken&gt; = _v202.Value
            let! v226 = v226 
            let v227 : System.Threading.CancellationToken = v226 
            let v228 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v227.Register
            let v229 : (unit -&gt; unit) = closure54(v184)
            let v230 : System.Threading.CancellationTokenRegistration = v228 v229
            use v230 = v230 
            let v231 : System.Threading.CancellationTokenRegistration = v230 
            let v232 : Async&lt;int32&gt; option = None
            let v233 : bool = true in let mutable _v232 = v232
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v234 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v234
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v235 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v235
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v236 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v236
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v237 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v237
#endif
            
#if FABLE_COMPILER_PYTHON
            let v238 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v238
#endif
            
#else
            let v239 : Async&lt;int32&gt; option = None
            let mutable _v239 = v239
            async {
            try
            let v240 : System.Threading.Tasks.Task = v184.WaitForExitAsync v227 
            let v241 : Async&lt;unit&gt; option = None
            let v242 : bool = true in let mutable _v241 = v241
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v243 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v243
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v244 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v244
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v245 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v245
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v246 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v246
#endif
            
#if FABLE_COMPILER_PYTHON
            let v247 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v247
#endif
            
#else
            let v248 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
            let v249 : Async&lt;unit&gt; = v248 v240
            v249
#endif
            |&gt; fun x -&gt; _v241 &lt;- Some x
            let v250 : Async&lt;unit&gt; = _v241.Value
            do! v250 
            let v251 : int32 = v184.ExitCode
            return v251 
            with ex -&gt;
            let v252 : exn = ex
            let v253 : string option = None
            let v254 : bool = true in let mutable _v253 = v253
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v255 : string = $"%A{v252}"
            v255
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v256 : string = $"%A{v252}"
            v256
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v257 : string = $"%A{v252}"
            v257
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v258 : string = $"%A{v252}"
            v258
#endif
            
#if FABLE_COMPILER_PYTHON
            let v259 : string = $"%A{v252}"
            v259
#endif
            
#else
            let v260 : string = $"{v252.GetType ()}: {v252.Message}"
            v260
#endif
            |&gt; fun x -&gt; _v253 &lt;- Some x
            let v261 : string = _v253.Value
            let v262 : (string -&gt; unit) = v186.Push
            v262 v261
            let v263 : System.Threading.Tasks.TaskCanceledException = v252 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
            let v264 : US0 = US0_3
            let v265 : (unit -&gt; string) = closure55(v263)
            let v266 : (unit -&gt; string) = method48()
            method3(v264, v265, v266)
            return -2147483648 
            (*
            *)
            }
            |&gt; fun x -&gt; _v239 &lt;- Some x
            let v267 : Async&lt;int32&gt; = _v239 |&gt; Option.get
            v267
#endif
            |&gt; fun x -&gt; _v232 &lt;- Some x
            let v268 : Async&lt;int32&gt; = _v232.Value
            let! v268 = v268 
            let v269 : int32 = v268 
            let v270 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
            let v271 : string seq = v270 v186
            let v272 : string = method72()
            let v273 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v274 : (string seq -&gt; string) = v273 v272
            let v275 : string = v274 v271
            let v276 : US0 = US0_1
            let v277 : (unit -&gt; string) = closure56(v269, v275)
            let v278 : (unit -&gt; string) = method48()
            method3(v276, v277, v278)
            return struct (v269, v275) 
            }
            |&gt; fun x -&gt; _v144 &lt;- Some x
            let v279 : Async&lt;struct (int32 * string)&gt; = _v144 |&gt; Option.get
            v279
#endif
            |&gt; fun x -&gt; _v137 &lt;- Some x
            let v280 : Async&lt;struct (int32 * string)&gt; = _v137.Value
            v280
#endif
            |&gt; fun x -&gt; _v130 &lt;- Some x
            let v281 : Async&lt;struct (int32 * string)&gt; = _v130.Value
            let v282 : struct (int32 * string) option = None
            let v283 : bool = true in let mutable _v282 = v282
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let struct (v284 : int32, v285 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v284, v285)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v286 : int32, v287 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v286, v287)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v288 : int32, v289 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v288, v289)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v290 : int32, v291 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v290, v291)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v292 : int32, v293 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v292, v293)
#endif
            
#else
            let v294 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
            let struct (v295 : int32, v296 : string) = v294 v281
            struct (v295, v296)
#endif
            |&gt; fun x -&gt; _v282 &lt;- Some x
            let struct (v297 : int32, v298 : string) = _v282.Value
            struct (v297, v298)
#endif
            |&gt; fun x -&gt; _v85 &lt;- Some x
            let struct (v299 : int32, v300 : string) = _v85.Value
            let v301 : bool = v299 = 0
            let v304 : US20 =
                if v301 then
                    US20_0(v300)
                else
                    US20_1(v300)
            let v310 : string =
                match v304 with
                | US20_1(v306) -&gt; (* Error *)
                    let v307 : string = $"resultm.get / Result value was Error: {v306}"
                    failwith&lt;string&gt; v307
                | US20_0(v305) -&gt; (* Ok *)
                    v305
            let v311 : string option = None
            let v312 : bool = true in let mutable _v311 = v311
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v313 : string = method22()
            let v314 : string = method23(v6)
            let v315 : string = method24()
            let v316 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v317 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v313, v314, v315) v316
            let v318 : string = "String::from($0)"
            let v319 : std_string_String = Fable.Core.RustInterop.emitRustExpr v317 v318
            let v320 : string = "fable_library_rust::String_::fromString($0)"
            let v321 : string = Fable.Core.RustInterop.emitRustExpr v319 v320
            v321
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v322 : string = null |&gt; unbox&lt;string&gt;
            v322
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v323 : string = null |&gt; unbox&lt;string&gt;
            v323
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v324 : string = null |&gt; unbox&lt;string&gt;
            v324
#endif
            
#if FABLE_COMPILER_PYTHON
            let v325 : string = null |&gt; unbox&lt;string&gt;
            v325
#endif
            
#else
            let v326 : string = System.Text.RegularExpressions.Regex.Replace (v6, v71, v72)
            v326
#endif
            |&gt; fun x -&gt; _v311 &lt;- Some x
            let v327 : string = _v311.Value
            let v328 : string = $"{v327.[0] |&gt; string |&gt; _.ToLower()}{v327.[1..]}"
            let v329 : string = v328.Replace (v76, v77)
            let v330 : string option = None
            let v331 : System.Threading.CancellationToken option = None
            let v332 : (struct (string * string) []) = [||]
            let v333 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
            let v334 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
            let v335 : string = $"pwsh -c \"(Get-FileHash \\\"{v329}\\\" -Algorithm SHA256).Hash\""
            let v336 : struct (int32 * string) option = None
            let v337 : bool = true in let mutable _v336 = v336
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v338 : string = method39(v331, v335, v332, v333, v334, v330)
            let struct (v339 : string, v340 : string) = method40()
            let v341 : int32 = v338.Length
            let v342 : (char []) = Array.zeroCreate&lt;char&gt; (v341)
            let v343 : Mut5 = {l0 = 0} : Mut5
            while method26(v341, v343) do
                let v345 : int32 = v343.l0
                let v346 : char = v338.[int v345]
                v342.[int v345] &lt;- v346
                let v347 : int32 = v345 + 1
                v343.l0 &lt;- v347
                ()
            let v348 : ((char []) -&gt; char list) = Array.toList
            let v349 : char list = v348 v342
            let v350 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v351 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v352 : (char list -&gt; (UH0 -&gt; UH0)) = v350 v351
            let v353 : (UH0 -&gt; UH0) = v352 v349
            let v354 : UH0 = UH0_0
            let v355 : UH0 = v353 v354
            let v356 : US8 = US8_0
            let struct (v357 : string, v358 : string) = method42(v340, v339, v355, v356)
            let v359 : (string []) = method43(v358)
            let v360 : string = "$0.to_vec()"
            let v361 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v359 v360
            let v362 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
            let v363 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v361, v112) v362
            let v364 : US0 = US0_1
            let v365 : (unit -&gt; string) = closure29(v331, v335, v332, v333, v334, v330, v357, v363)
            let v366 : (unit -&gt; string) = method48()
            method3(v364, v365, v366)
            let v367 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v331, v335, v332, v333, v334, v330, v357, v363)
            let v368 : string = "futures_lite::future::block_on($0)"
            let v369 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v367 v368
            let (a, b) = v369
            let v370 : int32 = a
            let v371 : string = b
            struct (v370, v371)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v372 : int32, v373 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v372, v373)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v374 : int32, v375 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v374, v375)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v376 : int32, v377 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v376, v377)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v378 : int32, v379 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v378, v379)
#endif
            
#else
            let v380 : Async&lt;struct (int32 * string)&gt; option = None
            let v381 : bool = true in let mutable _v380 = v380
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v382 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v382
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v383 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v383
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v384 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v384
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v385 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v385
#endif
            
#if FABLE_COMPILER_PYTHON
            let v386 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v386
#endif
            
#else
            let v387 : Async&lt;struct (int32 * string)&gt; option = None
            let v388 : bool = true in let mutable _v387 = v387
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v389 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v389
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v390 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v390
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v391 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v391
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v392 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v392
#endif
            
#if FABLE_COMPILER_PYTHON
            let v393 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v393
#endif
            
#else
            let v394 : Async&lt;struct (int32 * string)&gt; option = None
            let mutable _v394 = v394
            async {
            let struct (v395 : string, v396 : string) = method40()
            let v397 : int32 = v335.Length
            let v398 : (char []) = Array.zeroCreate&lt;char&gt; (v397)
            let v399 : Mut5 = {l0 = 0} : Mut5
            while method26(v397, v399) do
                let v401 : int32 = v399.l0
                let v402 : char = v335.[int v401]
                v398.[int v401] &lt;- v402
                let v403 : int32 = v401 + 1
                v399.l0 &lt;- v403
                ()
            let v404 : ((char []) -&gt; char list) = Array.toList
            let v405 : char list = v404 v398
            let v406 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v407 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v408 : (char list -&gt; (UH0 -&gt; UH0)) = v406 v407
            let v409 : (UH0 -&gt; UH0) = v408 v405
            let v410 : UH0 = UH0_0
            let v411 : UH0 = v409 v410
            let v412 : US8 = US8_0
            let struct (v413 : string, v414 : string) = method42(v396, v395, v411, v412)
            let v415 : (string -&gt; US4) = method19()
            let v416 : US4 = US4_1
            let v417 : US4 = v330 |&gt; Option.map v415 |&gt; Option.defaultValue v416 
            let v420 : string =
                match v417 with
                | US4_1 -&gt; (* None *)
                    v72
                | US4_0(v418) -&gt; (* Some *)
                    v418
            let v421 : US0 = US0_1
            let v422 : (unit -&gt; string) = closure48(v331, v335, v332, v333, v334, v330)
            let v423 : (unit -&gt; string) = method48()
            method3(v421, v422, v423)
            let v424 : System.Text.Encoding = System.Text.Encoding.UTF8
            let v425 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v414, StandardOutputEncoding = v424, WorkingDirectory = v420, FileName = v413, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
            let v426 : int32 = v332.Length
            let v427 : Mut5 = {l0 = 0} : Mut5
            while method26(v426, v427) do
                let v429 : int32 = v427.l0
                let struct (v430 : string, v431 : string) = v332.[int v429]
                v425.EnvironmentVariables.[v430] &lt;- v431 
                let v432 : int32 = v429 + 1
                v427.l0 &lt;- v432
                ()
            let v433 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v425)
            use v433 = v433 
            let v434 : System.Diagnostics.Process = v433 
            let v435 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
            let v436 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v435 ()
            let v437 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v331, v335, v332, v333, v334, v330, v434, v436)
            v434.OutputDataReceived.Add v437 
            let v438 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v331, v335, v332, v333, v334, v330, v434, v436)
            v434.ErrorDataReceived.Add v438 
            let v439 : (unit -&gt; bool) = v434.Start
            let v440 : bool = v439 ()
            let v441 : bool = v440 = false
            if v441 then
                let v442 : string = $"execute_with_options_async / process_start error"
                failwith&lt;unit&gt; v442
            let v443 : (unit -&gt; unit) = v434.BeginErrorReadLine
            v443 ()
            let v444 : (unit -&gt; unit) = v434.BeginOutputReadLine
            v444 ()
            let v445 : (System.Threading.CancellationToken -&gt; US18) = method71()
            let v446 : US18 = US18_1
            let v447 : US18 = v331 |&gt; Option.map v445 |&gt; Option.defaultValue v446 
            let v451 : System.Threading.CancellationToken =
                match v447 with
                | US18_1 -&gt; (* None *)
                    let v449 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                    v449
                | US18_0(v448) -&gt; (* Some *)
                    v448
            let v452 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v453 : bool = true in let mutable _v452 = v452
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v454 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v454
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v455 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v455
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v456 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v456
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v457 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v457
#endif
            
#if FABLE_COMPILER_PYTHON
            let v458 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v458
#endif
            
#else
            let v459 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v460 : bool = true in let mutable _v459 = v459
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v461 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v461
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v462 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v462
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v463 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v463
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v464 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v464
#endif
            
#if FABLE_COMPILER_PYTHON
            let v465 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v465
#endif
            
#else
            let v466 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let mutable _v466 = v466
            async {
            let v467 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
            let! v467 = v467 
            let v468 : System.Threading.CancellationToken = v467 
            let v469 : System.Threading.CancellationToken = Async.DefaultCancellationToken
            let v470 : (System.Threading.CancellationToken []) = [|v468; v469; v451|]
            let v471 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
            let v472 : System.Threading.CancellationTokenSource = v471 v470
            let v473 : System.Threading.CancellationToken = v472.Token
            return v473 
            }
            |&gt; fun x -&gt; _v466 &lt;- Some x
            let v474 : Async&lt;System.Threading.CancellationToken&gt; = _v466 |&gt; Option.get
            v474
#endif
            |&gt; fun x -&gt; _v459 &lt;- Some x
            let v475 : Async&lt;System.Threading.CancellationToken&gt; = _v459.Value
            v475
#endif
            |&gt; fun x -&gt; _v452 &lt;- Some x
            let v476 : Async&lt;System.Threading.CancellationToken&gt; = _v452.Value
            let! v476 = v476 
            let v477 : System.Threading.CancellationToken = v476 
            let v478 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v477.Register
            let v479 : (unit -&gt; unit) = closure54(v434)
            let v480 : System.Threading.CancellationTokenRegistration = v478 v479
            use v480 = v480 
            let v481 : System.Threading.CancellationTokenRegistration = v480 
            let v482 : Async&lt;int32&gt; option = None
            let v483 : bool = true in let mutable _v482 = v482
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v484 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v484
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v485 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v485
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v486 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v486
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v487 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v487
#endif
            
#if FABLE_COMPILER_PYTHON
            let v488 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v488
#endif
            
#else
            let v489 : Async&lt;int32&gt; option = None
            let mutable _v489 = v489
            async {
            try
            let v490 : System.Threading.Tasks.Task = v434.WaitForExitAsync v477 
            let v491 : Async&lt;unit&gt; option = None
            let v492 : bool = true in let mutable _v491 = v491
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v493 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v493
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v494 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v494
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v495 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v495
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v496 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v496
#endif
            
#if FABLE_COMPILER_PYTHON
            let v497 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v497
#endif
            
#else
            let v498 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
            let v499 : Async&lt;unit&gt; = v498 v490
            v499
#endif
            |&gt; fun x -&gt; _v491 &lt;- Some x
            let v500 : Async&lt;unit&gt; = _v491.Value
            do! v500 
            let v501 : int32 = v434.ExitCode
            return v501 
            with ex -&gt;
            let v502 : exn = ex
            let v503 : string option = None
            let v504 : bool = true in let mutable _v503 = v503
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v505 : string = $"%A{v502}"
            v505
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v506 : string = $"%A{v502}"
            v506
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v507 : string = $"%A{v502}"
            v507
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v508 : string = $"%A{v502}"
            v508
#endif
            
#if FABLE_COMPILER_PYTHON
            let v509 : string = $"%A{v502}"
            v509
#endif
            
#else
            let v510 : string = $"{v502.GetType ()}: {v502.Message}"
            v510
#endif
            |&gt; fun x -&gt; _v503 &lt;- Some x
            let v511 : string = _v503.Value
            let v512 : (string -&gt; unit) = v436.Push
            v512 v511
            let v513 : System.Threading.Tasks.TaskCanceledException = v502 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
            let v514 : US0 = US0_3
            let v515 : (unit -&gt; string) = closure55(v513)
            let v516 : (unit -&gt; string) = method48()
            method3(v514, v515, v516)
            return -2147483648 
            (*
            *)
            }
            |&gt; fun x -&gt; _v489 &lt;- Some x
            let v517 : Async&lt;int32&gt; = _v489 |&gt; Option.get
            v517
#endif
            |&gt; fun x -&gt; _v482 &lt;- Some x
            let v518 : Async&lt;int32&gt; = _v482.Value
            let! v518 = v518 
            let v519 : int32 = v518 
            let v520 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
            let v521 : string seq = v520 v436
            let v522 : string = method72()
            let v523 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v524 : (string seq -&gt; string) = v523 v522
            let v525 : string = v524 v521
            let v526 : US0 = US0_1
            let v527 : (unit -&gt; string) = closure56(v519, v525)
            let v528 : (unit -&gt; string) = method48()
            method3(v526, v527, v528)
            return struct (v519, v525) 
            }
            |&gt; fun x -&gt; _v394 &lt;- Some x
            let v529 : Async&lt;struct (int32 * string)&gt; = _v394 |&gt; Option.get
            v529
#endif
            |&gt; fun x -&gt; _v387 &lt;- Some x
            let v530 : Async&lt;struct (int32 * string)&gt; = _v387.Value
            v530
#endif
            |&gt; fun x -&gt; _v380 &lt;- Some x
            let v531 : Async&lt;struct (int32 * string)&gt; = _v380.Value
            let v532 : struct (int32 * string) option = None
            let v533 : bool = true in let mutable _v532 = v532
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let struct (v534 : int32, v535 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v534, v535)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v536 : int32, v537 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v536, v537)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v538 : int32, v539 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v538, v539)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v540 : int32, v541 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v540, v541)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v542 : int32, v543 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v542, v543)
#endif
            
#else
            let v544 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
            let struct (v545 : int32, v546 : string) = v544 v531
            struct (v545, v546)
#endif
            |&gt; fun x -&gt; _v532 &lt;- Some x
            let struct (v547 : int32, v548 : string) = _v532.Value
            struct (v547, v548)
#endif
            |&gt; fun x -&gt; _v336 &lt;- Some x
            let struct (v549 : int32, v550 : string) = _v336.Value
            let v551 : bool = v549 = 0
            let v554 : US20 =
                if v551 then
                    US20_0(v550)
                else
                    US20_1(v550)
            let v560 : string =
                match v554 with
                | US20_1(v556) -&gt; (* Error *)
                    let v557 : string = $"resultm.get / Result value was Error: {v556}"
                    failwith&lt;string&gt; v557
                | US20_0(v555) -&gt; (* Ok *)
                    v555
            let v561 : bool = v310 = v560
            v561
        else
            false
    let v563 : bool = v562 = false
    if v563 then
        let v564 : US21 = method75(v2, v3, v7, v4)
        match v564 with
        | US21_1(v608, v609) -&gt; (* Error *)
            let v610 : (string * string) = v7, v609
            let v611 : Result&lt;string, (string * string)&gt; = Error v610
            US19_0(v611)
        | US21_0(v565, v566) -&gt; (* Ok *)
            let v567 : bool = v565 &lt;&gt; 0
            if v567 then
                let v568 : US0 = US0_2
                let v569 : (unit -&gt; string) = closure64()
                let v570 : (unit -&gt; string) = closure65(v566, v565)
                method3(v568, v569, v570)
                let v571 : (string * string) = v7, v566
                let v572 : Result&lt;string, (string * string)&gt; = Error v571
                US19_0(v572)
            else
                let v574 : bool option = None
                let v575 : bool = true in let mutable _v574 = v574
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v576 : string = method14(v7)
                let v577 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                let v578 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v576 v577
                let v579 : string = "String::from($0)"
                let v580 : std_string_String = Fable.Core.RustInterop.emitRustExpr v578 v579
                let v581 : string = "std::path::PathBuf::from($0)"
                let v582 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v580 v581
                let v583 : string = "$0.exists()"
                let v584 : bool = Fable.Core.RustInterop.emitRustExpr v582 v583
                let v587 : bool =
                    if v584 then
                        let v585 : string = "$0.is_file()"
                        let v586 : bool = Fable.Core.RustInterop.emitRustExpr v582 v585
                        v586
                    else
                        false
                v587
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v588 : bool = null |&gt; unbox&lt;bool&gt;
                v588
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v589 : bool = null |&gt; unbox&lt;bool&gt;
                v589
#endif
                
#if FABLE_COMPILER_TYPESCRIPT
                let v590 : IFsExistsSync = Fable.Core.JsInterop.importAll v24
                let v591 : string = "$0.existsSync($1)"
                let v592 : bool = Fable.Core.JsInterop.emitJsExpr struct (v590, v7) v591
                v592
#endif
                
#if FABLE_COMPILER_PYTHON
                let v593 : bool = null |&gt; unbox&lt;bool&gt;
                v593
#endif
                
#else
                let v594 : (string -&gt; bool) = System.IO.File.Exists
                let v595 : bool = v594 v7
                v595
#endif
                |&gt; fun x -&gt; _v574 &lt;- Some x
                let v596 : bool = _v574.Value
                if v596 then
                    let v597 : unit option = None
                    let v598 : bool = true in let mutable _v597 = v597
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v599 : string = method74(v6)
                    let v600 : string = "std::fs::copy(&amp;*$0, &amp;*v599)"
                    let v601 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v7 v600
                    let v602 : string = "$0.unwrap()"
                    let v603 : uint64 = Fable.Core.RustInterop.emitRustExpr v601 v602
                    ()
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_PYTHON
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#else
                    System.IO.File.Copy (v7, v6, true)
                    ()
#endif
                    |&gt; fun x -&gt; _v597 &lt;- Some x
                    _v597.Value
                    ()
                else
                    let v604 : string = $"documents.files_fn / {v7} should exist"
                    failwith&lt;unit&gt; v604
                let v605 : Result&lt;string, (string * string)&gt; = Ok v7
                US19_0(v605)
    else
        US19_1
and closure59 (v0 : string, v1 : string, v2 : string, v3 : string) (v4 : string) : (string -&gt; US19) =
    closure60(v0, v1, v2, v3, v4)
and closure68 () () : string =
    let v0 : string = "documents.crowbook / result contains ERROR"
    v0
and closure69 (v0 : string, v1 : string, v2 : int32) () : string =
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"exit_code: %A{v2} / result: {v1} / output_path: {v0} / {v3 ()}"
    v4
and method81 (v0 : string, v1 : string, v2 : string, v3 : string) : US21 =
    let v4 : string = $"crowbook --single \"{v1}\" --output \"{v0}\" --to {v3} --set rendering.num_depth 6 html.css.add \\\"''' body {{ color: #e8e6e3; background-color: #202324; }} a {{ color: #989693; }} '''\\\""
    let v5 : string option = None
    let v6 : System.Threading.CancellationToken option = None
    let v7 : (struct (string * string) []) = [||]
    let v8 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v9 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v10 : string option = Some v2 
    let v11 : struct (int32 * string) option = None
    let v12 : bool = true in let mutable _v11 = v11
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v13 : string = method39(v6, v4, v7, v8, v9, v10)
    let struct (v14 : string, v15 : string) = method40()
    let v16 : int32 = v13.Length
    let v17 : (char []) = Array.zeroCreate&lt;char&gt; (v16)
    let v18 : Mut5 = {l0 = 0} : Mut5
    while method26(v16, v18) do
        let v20 : int32 = v18.l0
        let v21 : char = v13.[int v20]
        v17.[int v20] &lt;- v21
        let v22 : int32 = v20 + 1
        v18.l0 &lt;- v22
        ()
    let v23 : ((char []) -&gt; char list) = Array.toList
    let v24 : char list = v23 v17
    let v25 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v26 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v27 : (char list -&gt; (UH0 -&gt; UH0)) = v25 v26
    let v28 : (UH0 -&gt; UH0) = v27 v24
    let v29 : UH0 = UH0_0
    let v30 : UH0 = v28 v29
    let v31 : US8 = US8_0
    let struct (v32 : string, v33 : string) = method42(v15, v14, v30, v31)
    let v34 : (string []) = method43(v33)
    let v35 : string = "$0.to_vec()"
    let v36 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v34 v35
    let v37 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
    let v38 : (string -&gt; std_string_String) = closure28()
    let v39 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v36, v38) v37
    let v40 : US0 = US0_1
    let v41 : (unit -&gt; string) = closure29(v6, v4, v7, v8, v9, v10, v32, v39)
    let v42 : (unit -&gt; string) = method48()
    method3(v40, v41, v42)
    let v43 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v6, v4, v7, v8, v9, v10, v32, v39)
    let v44 : string = "futures_lite::future::block_on($0)"
    let v45 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v43 v44
    let (a, b) = v45
    let v46 : int32 = a
    let v47 : string = b
    struct (v46, v47)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v48 : int32, v49 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v48, v49)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v50 : int32, v51 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v50, v51)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v52 : int32, v53 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v52, v53)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v54 : int32, v55 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v54, v55)
#endif
    
#else
    let v56 : Async&lt;struct (int32 * string)&gt; option = None
    let v57 : bool = true in let mutable _v56 = v56
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v58 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v58
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v59 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v59
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v60 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v60
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v61 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v61
#endif
    
#if FABLE_COMPILER_PYTHON
    let v62 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v62
#endif
    
#else
    let v63 : Async&lt;struct (int32 * string)&gt; option = None
    let v64 : bool = true in let mutable _v63 = v63
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v65 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v65
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v66 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v66
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v67 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v67
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v68 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v68
#endif
    
#if FABLE_COMPILER_PYTHON
    let v69 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v69
#endif
    
#else
    let v70 : Async&lt;struct (int32 * string)&gt; option = None
    let mutable _v70 = v70
    async {
    let struct (v71 : string, v72 : string) = method40()
    let v73 : int32 = v4.Length
    let v74 : (char []) = Array.zeroCreate&lt;char&gt; (v73)
    let v75 : Mut5 = {l0 = 0} : Mut5
    while method26(v73, v75) do
        let v77 : int32 = v75.l0
        let v78 : char = v4.[int v77]
        v74.[int v77] &lt;- v78
        let v79 : int32 = v77 + 1
        v75.l0 &lt;- v79
        ()
    let v80 : ((char []) -&gt; char list) = Array.toList
    let v81 : char list = v80 v74
    let v82 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v83 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v84 : (char list -&gt; (UH0 -&gt; UH0)) = v82 v83
    let v85 : (UH0 -&gt; UH0) = v84 v81
    let v86 : UH0 = UH0_0
    let v87 : UH0 = v85 v86
    let v88 : US8 = US8_0
    let struct (v89 : string, v90 : string) = method42(v72, v71, v87, v88)
    let v91 : (string -&gt; US4) = method19()
    let v92 : US4 = US4_1
    let v93 : US4 = v10 |&gt; Option.map v91 |&gt; Option.defaultValue v92 
    let v97 : string =
        match v93 with
        | US4_1 -&gt; (* None *)
            let v95 : string = ""
            v95
        | US4_0(v94) -&gt; (* Some *)
            v94
    let v98 : US0 = US0_1
    let v99 : (unit -&gt; string) = closure48(v6, v4, v7, v8, v9, v10)
    let v100 : (unit -&gt; string) = method48()
    method3(v98, v99, v100)
    let v101 : System.Text.Encoding = System.Text.Encoding.UTF8
    let v102 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v90, StandardOutputEncoding = v101, WorkingDirectory = v97, FileName = v89, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
    let v103 : int32 = v7.Length
    let v104 : Mut5 = {l0 = 0} : Mut5
    while method26(v103, v104) do
        let v106 : int32 = v104.l0
        let struct (v107 : string, v108 : string) = v7.[int v106]
        v102.EnvironmentVariables.[v107] &lt;- v108 
        let v109 : int32 = v106 + 1
        v104.l0 &lt;- v109
        ()
    let v110 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v102)
    use v110 = v110 
    let v111 : System.Diagnostics.Process = v110 
    let v112 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
    let v113 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v112 ()
    let v114 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v6, v4, v7, v8, v9, v10, v111, v113)
    v111.OutputDataReceived.Add v114 
    let v115 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v6, v4, v7, v8, v9, v10, v111, v113)
    v111.ErrorDataReceived.Add v115 
    let v116 : (unit -&gt; bool) = v111.Start
    let v117 : bool = v116 ()
    let v118 : bool = v117 = false
    if v118 then
        let v119 : string = $"execute_with_options_async / process_start error"
        failwith&lt;unit&gt; v119
    let v120 : (unit -&gt; unit) = v111.BeginErrorReadLine
    v120 ()
    let v121 : (unit -&gt; unit) = v111.BeginOutputReadLine
    v121 ()
    let v122 : (System.Threading.CancellationToken -&gt; US18) = method71()
    let v123 : US18 = US18_1
    let v124 : US18 = v6 |&gt; Option.map v122 |&gt; Option.defaultValue v123 
    let v128 : System.Threading.CancellationToken =
        match v124 with
        | US18_1 -&gt; (* None *)
            let v126 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
            v126
        | US18_0(v125) -&gt; (* Some *)
            v125
    let v129 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v130 : bool = true in let mutable _v129 = v129
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v131 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v131
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v132 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v132
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v133 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v133
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v134 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v134
#endif
    
#if FABLE_COMPILER_PYTHON
    let v135 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v135
#endif
    
#else
    let v136 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v137 : bool = true in let mutable _v136 = v136
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v138 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v138
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v139 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v139
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v140 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v140
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v141 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v141
#endif
    
#if FABLE_COMPILER_PYTHON
    let v142 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v142
#endif
    
#else
    let v143 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let mutable _v143 = v143
    async {
    let v144 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
    let! v144 = v144 
    let v145 : System.Threading.CancellationToken = v144 
    let v146 : System.Threading.CancellationToken = Async.DefaultCancellationToken
    let v147 : (System.Threading.CancellationToken []) = [|v145; v146; v128|]
    let v148 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
    let v149 : System.Threading.CancellationTokenSource = v148 v147
    let v150 : System.Threading.CancellationToken = v149.Token
    return v150 
    }
    |&gt; fun x -&gt; _v143 &lt;- Some x
    let v151 : Async&lt;System.Threading.CancellationToken&gt; = _v143 |&gt; Option.get
    v151
#endif
    |&gt; fun x -&gt; _v136 &lt;- Some x
    let v152 : Async&lt;System.Threading.CancellationToken&gt; = _v136.Value
    v152
#endif
    |&gt; fun x -&gt; _v129 &lt;- Some x
    let v153 : Async&lt;System.Threading.CancellationToken&gt; = _v129.Value
    let! v153 = v153 
    let v154 : System.Threading.CancellationToken = v153 
    let v155 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v154.Register
    let v156 : (unit -&gt; unit) = closure54(v111)
    let v157 : System.Threading.CancellationTokenRegistration = v155 v156
    use v157 = v157 
    let v158 : System.Threading.CancellationTokenRegistration = v157 
    let v159 : Async&lt;int32&gt; option = None
    let v160 : bool = true in let mutable _v159 = v159
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v161 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v161
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v162 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v162
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v163 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v163
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v164 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v164
#endif
    
#if FABLE_COMPILER_PYTHON
    let v165 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v165
#endif
    
#else
    let v166 : Async&lt;int32&gt; option = None
    let mutable _v166 = v166
    async {
    try
    let v167 : System.Threading.Tasks.Task = v111.WaitForExitAsync v154 
    let v168 : Async&lt;unit&gt; option = None
    let v169 : bool = true in let mutable _v168 = v168
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v170 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v170
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v171 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v171
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v172 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v172
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v173 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v173
#endif
    
#if FABLE_COMPILER_PYTHON
    let v174 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v174
#endif
    
#else
    let v175 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
    let v176 : Async&lt;unit&gt; = v175 v167
    v176
#endif
    |&gt; fun x -&gt; _v168 &lt;- Some x
    let v177 : Async&lt;unit&gt; = _v168.Value
    do! v177 
    let v178 : int32 = v111.ExitCode
    return v178 
    with ex -&gt;
    let v179 : exn = ex
    let v180 : string option = None
    let v181 : bool = true in let mutable _v180 = v180
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v182 : string = $"%A{v179}"
    v182
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v183 : string = $"%A{v179}"
    v183
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v184 : string = $"%A{v179}"
    v184
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v185 : string = $"%A{v179}"
    v185
#endif
    
#if FABLE_COMPILER_PYTHON
    let v186 : string = $"%A{v179}"
    v186
#endif
    
#else
    let v187 : string = $"{v179.GetType ()}: {v179.Message}"
    v187
#endif
    |&gt; fun x -&gt; _v180 &lt;- Some x
    let v188 : string = _v180.Value
    let v189 : (string -&gt; unit) = v113.Push
    v189 v188
    let v190 : System.Threading.Tasks.TaskCanceledException = v179 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
    let v191 : US0 = US0_3
    let v192 : (unit -&gt; string) = closure55(v190)
    let v193 : (unit -&gt; string) = method48()
    method3(v191, v192, v193)
    return -2147483648 
    (*
    *)
    }
    |&gt; fun x -&gt; _v166 &lt;- Some x
    let v194 : Async&lt;int32&gt; = _v166 |&gt; Option.get
    v194
#endif
    |&gt; fun x -&gt; _v159 &lt;- Some x
    let v195 : Async&lt;int32&gt; = _v159.Value
    let! v195 = v195 
    let v196 : int32 = v195 
    let v197 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
    let v198 : string seq = v197 v113
    let v199 : string = method72()
    let v200 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v201 : (string seq -&gt; string) = v200 v199
    let v202 : string = v201 v198
    let v203 : US0 = US0_1
    let v204 : (unit -&gt; string) = closure56(v196, v202)
    let v205 : (unit -&gt; string) = method48()
    method3(v203, v204, v205)
    return struct (v196, v202) 
    }
    |&gt; fun x -&gt; _v70 &lt;- Some x
    let v206 : Async&lt;struct (int32 * string)&gt; = _v70 |&gt; Option.get
    v206
#endif
    |&gt; fun x -&gt; _v63 &lt;- Some x
    let v207 : Async&lt;struct (int32 * string)&gt; = _v63.Value
    v207
#endif
    |&gt; fun x -&gt; _v56 &lt;- Some x
    let v208 : Async&lt;struct (int32 * string)&gt; = _v56.Value
    let v209 : struct (int32 * string) option = None
    let v210 : bool = true in let mutable _v209 = v209
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let struct (v211 : int32, v212 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v211, v212)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v213 : int32, v214 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v213, v214)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v215 : int32, v216 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v215, v216)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v217 : int32, v218 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v217, v218)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v219 : int32, v220 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v219, v220)
#endif
    
#else
    let v221 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
    let struct (v222 : int32, v223 : string) = v221 v208
    struct (v222, v223)
#endif
    |&gt; fun x -&gt; _v209 &lt;- Some x
    let struct (v224 : int32, v225 : string) = _v209.Value
    struct (v224, v225)
#endif
    |&gt; fun x -&gt; _v11 &lt;- Some x
    let struct (v226 : int32, v227 : string) = _v11.Value
    let v228 : string = "ERROR"
    let v229 : bool = v227.Contains v228
    if v229 then
        let v230 : US0 = US0_2
        let v231 : (unit -&gt; string) = closure68()
        let v232 : (unit -&gt; string) = closure69(v0, v227, v226)
        method3(v230, v231, v232)
        US21_1(v226, v227)
    else
        US21_0(v226, v227)
and closure67 (v0 : string, v1 : string, v2 : string) (v3 : string) : US19 =
    let struct (v4 : string, v5 : string) = method73(v3, v2, v0)
    let v6 : bool option = None
    let v7 : bool = true in let mutable _v6 = v6
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v8 : string = method14(v5)
    let v9 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v10 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v8 v9
    let v11 : string = "String::from($0)"
    let v12 : std_string_String = Fable.Core.RustInterop.emitRustExpr v10 v11
    let v13 : string = "std::path::PathBuf::from($0)"
    let v14 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v12 v13
    let v15 : string = "$0.exists()"
    let v16 : bool = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v19 : bool =
        if v16 then
            let v17 : string = "$0.is_file()"
            let v18 : bool = Fable.Core.RustInterop.emitRustExpr v14 v17
            v18
        else
            false
    v19
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v20 : bool = null |&gt; unbox&lt;bool&gt;
    v20
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v21 : bool = null |&gt; unbox&lt;bool&gt;
    v21
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v22 : string = "fs"
    let v23 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
    let v24 : string = "$0.existsSync($1)"
    let v25 : bool = Fable.Core.JsInterop.emitJsExpr struct (v23, v5) v24
    v25
#endif
    
#if FABLE_COMPILER_PYTHON
    let v26 : bool = null |&gt; unbox&lt;bool&gt;
    v26
#endif
    
#else
    let v27 : (string -&gt; bool) = System.IO.File.Exists
    let v28 : bool = v27 v5
    v28
#endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v29 : bool = _v6.Value
    let v53 : bool =
        if v29 then
            let v30 : bool option = None
            let v31 : bool = true in let mutable _v30 = v30
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v32 : string = method14(v4)
            let v33 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v34 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v32 v33
            let v35 : string = "String::from($0)"
            let v36 : std_string_String = Fable.Core.RustInterop.emitRustExpr v34 v35
            let v37 : string = "std::path::PathBuf::from($0)"
            let v38 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v36 v37
            let v39 : string = "$0.exists()"
            let v40 : bool = Fable.Core.RustInterop.emitRustExpr v38 v39
            let v43 : bool =
                if v40 then
                    let v41 : string = "$0.is_file()"
                    let v42 : bool = Fable.Core.RustInterop.emitRustExpr v38 v41
                    v42
                else
                    false
            v43
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v44 : bool = null |&gt; unbox&lt;bool&gt;
            v44
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v45 : bool = null |&gt; unbox&lt;bool&gt;
            v45
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v46 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
            let v47 : string = "$0.existsSync($1)"
            let v48 : bool = Fable.Core.JsInterop.emitJsExpr struct (v46, v4) v47
            v48
#endif
            
#if FABLE_COMPILER_PYTHON
            let v49 : bool = null |&gt; unbox&lt;bool&gt;
            v49
#endif
            
#else
            let v50 : (string -&gt; bool) = System.IO.File.Exists
            let v51 : bool = v50 v4
            v51
#endif
            |&gt; fun x -&gt; _v30 &lt;- Some x
            let v52 : bool = _v30.Value
            v52
        else
            false
    let v560 : bool =
        if v53 then
            let v54 : string option = None
            let v55 : bool = true in let mutable _v54 = v54
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v56 : string = method22()
            let v57 : string = method23(v5)
            let v58 : string = method24()
            let v59 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v60 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v56, v57, v58) v59
            let v61 : string = "String::from($0)"
            let v62 : std_string_String = Fable.Core.RustInterop.emitRustExpr v60 v61
            let v63 : string = "fable_library_rust::String_::fromString($0)"
            let v64 : string = Fable.Core.RustInterop.emitRustExpr v62 v63
            v64
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v65 : string = null |&gt; unbox&lt;string&gt;
            v65
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v66 : string = null |&gt; unbox&lt;string&gt;
            v66
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v67 : string = null |&gt; unbox&lt;string&gt;
            v67
#endif
            
#if FABLE_COMPILER_PYTHON
            let v68 : string = null |&gt; unbox&lt;string&gt;
            v68
#endif
            
#else
            let v69 : string = "^\\\\\\\\\\?\\\\"
            let v70 : string = ""
            let v71 : string = System.Text.RegularExpressions.Regex.Replace (v5, v69, v70)
            v71
#endif
            |&gt; fun x -&gt; _v54 &lt;- Some x
            let v72 : string = _v54.Value
            let v73 : string = $"{v72.[0] |&gt; string |&gt; _.ToLower()}{v72.[1..]}"
            let v74 : string = "\\"
            let v75 : string = "/"
            let v76 : string = v73.Replace (v74, v75)
            let v77 : string option = None
            let v78 : System.Threading.CancellationToken option = None
            let v79 : (struct (string * string) []) = [||]
            let v80 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
            let v81 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
            let v82 : string = $"pwsh -c \"(Get-FileHash \\\"{v76}\\\" -Algorithm SHA256).Hash\""
            let v83 : struct (int32 * string) option = None
            let v84 : bool = true in let mutable _v83 = v83
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v85 : string = method39(v78, v82, v79, v80, v81, v77)
            let struct (v86 : string, v87 : string) = method40()
            let v88 : int32 = v85.Length
            let v89 : (char []) = Array.zeroCreate&lt;char&gt; (v88)
            let v90 : Mut5 = {l0 = 0} : Mut5
            while method26(v88, v90) do
                let v92 : int32 = v90.l0
                let v93 : char = v85.[int v92]
                v89.[int v92] &lt;- v93
                let v94 : int32 = v92 + 1
                v90.l0 &lt;- v94
                ()
            let v95 : ((char []) -&gt; char list) = Array.toList
            let v96 : char list = v95 v89
            let v97 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v98 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v99 : (char list -&gt; (UH0 -&gt; UH0)) = v97 v98
            let v100 : (UH0 -&gt; UH0) = v99 v96
            let v101 : UH0 = UH0_0
            let v102 : UH0 = v100 v101
            let v103 : US8 = US8_0
            let struct (v104 : string, v105 : string) = method42(v87, v86, v102, v103)
            let v106 : (string []) = method43(v105)
            let v107 : string = "$0.to_vec()"
            let v108 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v106 v107
            let v109 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
            let v110 : (string -&gt; std_string_String) = closure28()
            let v111 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v108, v110) v109
            let v112 : US0 = US0_1
            let v113 : (unit -&gt; string) = closure29(v78, v82, v79, v80, v81, v77, v104, v111)
            let v114 : (unit -&gt; string) = method48()
            method3(v112, v113, v114)
            let v115 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v78, v82, v79, v80, v81, v77, v104, v111)
            let v116 : string = "futures_lite::future::block_on($0)"
            let v117 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v115 v116
            let (a, b) = v117
            let v118 : int32 = a
            let v119 : string = b
            struct (v118, v119)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v120 : int32, v121 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v120, v121)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v122 : int32, v123 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v122, v123)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v124 : int32, v125 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v124, v125)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v126 : int32, v127 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v126, v127)
#endif
            
#else
            let v128 : Async&lt;struct (int32 * string)&gt; option = None
            let v129 : bool = true in let mutable _v128 = v128
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v130 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v130
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v131 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v131
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v132 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v132
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v133 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v133
#endif
            
#if FABLE_COMPILER_PYTHON
            let v134 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v134
#endif
            
#else
            let v135 : Async&lt;struct (int32 * string)&gt; option = None
            let v136 : bool = true in let mutable _v135 = v135
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v137 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v137
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v138 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v138
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v139 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v139
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v140 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v140
#endif
            
#if FABLE_COMPILER_PYTHON
            let v141 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v141
#endif
            
#else
            let v142 : Async&lt;struct (int32 * string)&gt; option = None
            let mutable _v142 = v142
            async {
            let struct (v143 : string, v144 : string) = method40()
            let v145 : int32 = v82.Length
            let v146 : (char []) = Array.zeroCreate&lt;char&gt; (v145)
            let v147 : Mut5 = {l0 = 0} : Mut5
            while method26(v145, v147) do
                let v149 : int32 = v147.l0
                let v150 : char = v82.[int v149]
                v146.[int v149] &lt;- v150
                let v151 : int32 = v149 + 1
                v147.l0 &lt;- v151
                ()
            let v152 : ((char []) -&gt; char list) = Array.toList
            let v153 : char list = v152 v146
            let v154 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v155 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v156 : (char list -&gt; (UH0 -&gt; UH0)) = v154 v155
            let v157 : (UH0 -&gt; UH0) = v156 v153
            let v158 : UH0 = UH0_0
            let v159 : UH0 = v157 v158
            let v160 : US8 = US8_0
            let struct (v161 : string, v162 : string) = method42(v144, v143, v159, v160)
            let v163 : (string -&gt; US4) = method19()
            let v164 : US4 = US4_1
            let v165 : US4 = v77 |&gt; Option.map v163 |&gt; Option.defaultValue v164 
            let v168 : string =
                match v165 with
                | US4_1 -&gt; (* None *)
                    v70
                | US4_0(v166) -&gt; (* Some *)
                    v166
            let v169 : US0 = US0_1
            let v170 : (unit -&gt; string) = closure48(v78, v82, v79, v80, v81, v77)
            let v171 : (unit -&gt; string) = method48()
            method3(v169, v170, v171)
            let v172 : System.Text.Encoding = System.Text.Encoding.UTF8
            let v173 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v162, StandardOutputEncoding = v172, WorkingDirectory = v168, FileName = v161, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
            let v174 : int32 = v79.Length
            let v175 : Mut5 = {l0 = 0} : Mut5
            while method26(v174, v175) do
                let v177 : int32 = v175.l0
                let struct (v178 : string, v179 : string) = v79.[int v177]
                v173.EnvironmentVariables.[v178] &lt;- v179 
                let v180 : int32 = v177 + 1
                v175.l0 &lt;- v180
                ()
            let v181 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v173)
            use v181 = v181 
            let v182 : System.Diagnostics.Process = v181 
            let v183 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
            let v184 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v183 ()
            let v185 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v78, v82, v79, v80, v81, v77, v182, v184)
            v182.OutputDataReceived.Add v185 
            let v186 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v78, v82, v79, v80, v81, v77, v182, v184)
            v182.ErrorDataReceived.Add v186 
            let v187 : (unit -&gt; bool) = v182.Start
            let v188 : bool = v187 ()
            let v189 : bool = v188 = false
            if v189 then
                let v190 : string = $"execute_with_options_async / process_start error"
                failwith&lt;unit&gt; v190
            let v191 : (unit -&gt; unit) = v182.BeginErrorReadLine
            v191 ()
            let v192 : (unit -&gt; unit) = v182.BeginOutputReadLine
            v192 ()
            let v193 : (System.Threading.CancellationToken -&gt; US18) = method71()
            let v194 : US18 = US18_1
            let v195 : US18 = v78 |&gt; Option.map v193 |&gt; Option.defaultValue v194 
            let v199 : System.Threading.CancellationToken =
                match v195 with
                | US18_1 -&gt; (* None *)
                    let v197 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                    v197
                | US18_0(v196) -&gt; (* Some *)
                    v196
            let v200 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v201 : bool = true in let mutable _v200 = v200
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v202 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v202
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v203 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v203
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v204 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v204
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v205 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v205
#endif
            
#if FABLE_COMPILER_PYTHON
            let v206 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v206
#endif
            
#else
            let v207 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v208 : bool = true in let mutable _v207 = v207
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v209 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v209
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v210 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v210
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v211 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v211
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v212 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v212
#endif
            
#if FABLE_COMPILER_PYTHON
            let v213 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v213
#endif
            
#else
            let v214 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let mutable _v214 = v214
            async {
            let v215 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
            let! v215 = v215 
            let v216 : System.Threading.CancellationToken = v215 
            let v217 : System.Threading.CancellationToken = Async.DefaultCancellationToken
            let v218 : (System.Threading.CancellationToken []) = [|v216; v217; v199|]
            let v219 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
            let v220 : System.Threading.CancellationTokenSource = v219 v218
            let v221 : System.Threading.CancellationToken = v220.Token
            return v221 
            }
            |&gt; fun x -&gt; _v214 &lt;- Some x
            let v222 : Async&lt;System.Threading.CancellationToken&gt; = _v214 |&gt; Option.get
            v222
#endif
            |&gt; fun x -&gt; _v207 &lt;- Some x
            let v223 : Async&lt;System.Threading.CancellationToken&gt; = _v207.Value
            v223
#endif
            |&gt; fun x -&gt; _v200 &lt;- Some x
            let v224 : Async&lt;System.Threading.CancellationToken&gt; = _v200.Value
            let! v224 = v224 
            let v225 : System.Threading.CancellationToken = v224 
            let v226 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v225.Register
            let v227 : (unit -&gt; unit) = closure54(v182)
            let v228 : System.Threading.CancellationTokenRegistration = v226 v227
            use v228 = v228 
            let v229 : System.Threading.CancellationTokenRegistration = v228 
            let v230 : Async&lt;int32&gt; option = None
            let v231 : bool = true in let mutable _v230 = v230
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v232 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v232
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v233 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v233
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v234 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v234
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v235 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v235
#endif
            
#if FABLE_COMPILER_PYTHON
            let v236 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v236
#endif
            
#else
            let v237 : Async&lt;int32&gt; option = None
            let mutable _v237 = v237
            async {
            try
            let v238 : System.Threading.Tasks.Task = v182.WaitForExitAsync v225 
            let v239 : Async&lt;unit&gt; option = None
            let v240 : bool = true in let mutable _v239 = v239
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v241 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v241
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v242 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v242
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v243 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v243
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v244 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v244
#endif
            
#if FABLE_COMPILER_PYTHON
            let v245 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v245
#endif
            
#else
            let v246 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
            let v247 : Async&lt;unit&gt; = v246 v238
            v247
#endif
            |&gt; fun x -&gt; _v239 &lt;- Some x
            let v248 : Async&lt;unit&gt; = _v239.Value
            do! v248 
            let v249 : int32 = v182.ExitCode
            return v249 
            with ex -&gt;
            let v250 : exn = ex
            let v251 : string option = None
            let v252 : bool = true in let mutable _v251 = v251
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v253 : string = $"%A{v250}"
            v253
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v254 : string = $"%A{v250}"
            v254
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v255 : string = $"%A{v250}"
            v255
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v256 : string = $"%A{v250}"
            v256
#endif
            
#if FABLE_COMPILER_PYTHON
            let v257 : string = $"%A{v250}"
            v257
#endif
            
#else
            let v258 : string = $"{v250.GetType ()}: {v250.Message}"
            v258
#endif
            |&gt; fun x -&gt; _v251 &lt;- Some x
            let v259 : string = _v251.Value
            let v260 : (string -&gt; unit) = v184.Push
            v260 v259
            let v261 : System.Threading.Tasks.TaskCanceledException = v250 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
            let v262 : US0 = US0_3
            let v263 : (unit -&gt; string) = closure55(v261)
            let v264 : (unit -&gt; string) = method48()
            method3(v262, v263, v264)
            return -2147483648 
            (*
            *)
            }
            |&gt; fun x -&gt; _v237 &lt;- Some x
            let v265 : Async&lt;int32&gt; = _v237 |&gt; Option.get
            v265
#endif
            |&gt; fun x -&gt; _v230 &lt;- Some x
            let v266 : Async&lt;int32&gt; = _v230.Value
            let! v266 = v266 
            let v267 : int32 = v266 
            let v268 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
            let v269 : string seq = v268 v184
            let v270 : string = method72()
            let v271 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v272 : (string seq -&gt; string) = v271 v270
            let v273 : string = v272 v269
            let v274 : US0 = US0_1
            let v275 : (unit -&gt; string) = closure56(v267, v273)
            let v276 : (unit -&gt; string) = method48()
            method3(v274, v275, v276)
            return struct (v267, v273) 
            }
            |&gt; fun x -&gt; _v142 &lt;- Some x
            let v277 : Async&lt;struct (int32 * string)&gt; = _v142 |&gt; Option.get
            v277
#endif
            |&gt; fun x -&gt; _v135 &lt;- Some x
            let v278 : Async&lt;struct (int32 * string)&gt; = _v135.Value
            v278
#endif
            |&gt; fun x -&gt; _v128 &lt;- Some x
            let v279 : Async&lt;struct (int32 * string)&gt; = _v128.Value
            let v280 : struct (int32 * string) option = None
            let v281 : bool = true in let mutable _v280 = v280
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let struct (v282 : int32, v283 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v282, v283)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v284 : int32, v285 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v284, v285)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v286 : int32, v287 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v286, v287)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v288 : int32, v289 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v288, v289)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v290 : int32, v291 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v290, v291)
#endif
            
#else
            let v292 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
            let struct (v293 : int32, v294 : string) = v292 v279
            struct (v293, v294)
#endif
            |&gt; fun x -&gt; _v280 &lt;- Some x
            let struct (v295 : int32, v296 : string) = _v280.Value
            struct (v295, v296)
#endif
            |&gt; fun x -&gt; _v83 &lt;- Some x
            let struct (v297 : int32, v298 : string) = _v83.Value
            let v299 : bool = v297 = 0
            let v302 : US20 =
                if v299 then
                    US20_0(v298)
                else
                    US20_1(v298)
            let v308 : string =
                match v302 with
                | US20_1(v304) -&gt; (* Error *)
                    let v305 : string = $"resultm.get / Result value was Error: {v304}"
                    failwith&lt;string&gt; v305
                | US20_0(v303) -&gt; (* Ok *)
                    v303
            let v309 : string option = None
            let v310 : bool = true in let mutable _v309 = v309
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v311 : string = method22()
            let v312 : string = method23(v4)
            let v313 : string = method24()
            let v314 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v315 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v311, v312, v313) v314
            let v316 : string = "String::from($0)"
            let v317 : std_string_String = Fable.Core.RustInterop.emitRustExpr v315 v316
            let v318 : string = "fable_library_rust::String_::fromString($0)"
            let v319 : string = Fable.Core.RustInterop.emitRustExpr v317 v318
            v319
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v320 : string = null |&gt; unbox&lt;string&gt;
            v320
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v321 : string = null |&gt; unbox&lt;string&gt;
            v321
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v322 : string = null |&gt; unbox&lt;string&gt;
            v322
#endif
            
#if FABLE_COMPILER_PYTHON
            let v323 : string = null |&gt; unbox&lt;string&gt;
            v323
#endif
            
#else
            let v324 : string = System.Text.RegularExpressions.Regex.Replace (v4, v69, v70)
            v324
#endif
            |&gt; fun x -&gt; _v309 &lt;- Some x
            let v325 : string = _v309.Value
            let v326 : string = $"{v325.[0] |&gt; string |&gt; _.ToLower()}{v325.[1..]}"
            let v327 : string = v326.Replace (v74, v75)
            let v328 : string option = None
            let v329 : System.Threading.CancellationToken option = None
            let v330 : (struct (string * string) []) = [||]
            let v331 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
            let v332 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
            let v333 : string = $"pwsh -c \"(Get-FileHash \\\"{v327}\\\" -Algorithm SHA256).Hash\""
            let v334 : struct (int32 * string) option = None
            let v335 : bool = true in let mutable _v334 = v334
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v336 : string = method39(v329, v333, v330, v331, v332, v328)
            let struct (v337 : string, v338 : string) = method40()
            let v339 : int32 = v336.Length
            let v340 : (char []) = Array.zeroCreate&lt;char&gt; (v339)
            let v341 : Mut5 = {l0 = 0} : Mut5
            while method26(v339, v341) do
                let v343 : int32 = v341.l0
                let v344 : char = v336.[int v343]
                v340.[int v343] &lt;- v344
                let v345 : int32 = v343 + 1
                v341.l0 &lt;- v345
                ()
            let v346 : ((char []) -&gt; char list) = Array.toList
            let v347 : char list = v346 v340
            let v348 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v349 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v350 : (char list -&gt; (UH0 -&gt; UH0)) = v348 v349
            let v351 : (UH0 -&gt; UH0) = v350 v347
            let v352 : UH0 = UH0_0
            let v353 : UH0 = v351 v352
            let v354 : US8 = US8_0
            let struct (v355 : string, v356 : string) = method42(v338, v337, v353, v354)
            let v357 : (string []) = method43(v356)
            let v358 : string = "$0.to_vec()"
            let v359 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v357 v358
            let v360 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
            let v361 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v359, v110) v360
            let v362 : US0 = US0_1
            let v363 : (unit -&gt; string) = closure29(v329, v333, v330, v331, v332, v328, v355, v361)
            let v364 : (unit -&gt; string) = method48()
            method3(v362, v363, v364)
            let v365 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v329, v333, v330, v331, v332, v328, v355, v361)
            let v366 : string = "futures_lite::future::block_on($0)"
            let v367 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v365 v366
            let (a, b) = v367
            let v368 : int32 = a
            let v369 : string = b
            struct (v368, v369)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v370 : int32, v371 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v370, v371)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v372 : int32, v373 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v372, v373)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v374 : int32, v375 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v374, v375)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v376 : int32, v377 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v376, v377)
#endif
            
#else
            let v378 : Async&lt;struct (int32 * string)&gt; option = None
            let v379 : bool = true in let mutable _v378 = v378
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v380 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v380
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v381 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v381
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v382 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v382
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v383 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v383
#endif
            
#if FABLE_COMPILER_PYTHON
            let v384 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v384
#endif
            
#else
            let v385 : Async&lt;struct (int32 * string)&gt; option = None
            let v386 : bool = true in let mutable _v385 = v385
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v387 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v387
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v388 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v388
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v389 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v389
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v390 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v390
#endif
            
#if FABLE_COMPILER_PYTHON
            let v391 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v391
#endif
            
#else
            let v392 : Async&lt;struct (int32 * string)&gt; option = None
            let mutable _v392 = v392
            async {
            let struct (v393 : string, v394 : string) = method40()
            let v395 : int32 = v333.Length
            let v396 : (char []) = Array.zeroCreate&lt;char&gt; (v395)
            let v397 : Mut5 = {l0 = 0} : Mut5
            while method26(v395, v397) do
                let v399 : int32 = v397.l0
                let v400 : char = v333.[int v399]
                v396.[int v399] &lt;- v400
                let v401 : int32 = v399 + 1
                v397.l0 &lt;- v401
                ()
            let v402 : ((char []) -&gt; char list) = Array.toList
            let v403 : char list = v402 v396
            let v404 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v405 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v406 : (char list -&gt; (UH0 -&gt; UH0)) = v404 v405
            let v407 : (UH0 -&gt; UH0) = v406 v403
            let v408 : UH0 = UH0_0
            let v409 : UH0 = v407 v408
            let v410 : US8 = US8_0
            let struct (v411 : string, v412 : string) = method42(v394, v393, v409, v410)
            let v413 : (string -&gt; US4) = method19()
            let v414 : US4 = US4_1
            let v415 : US4 = v328 |&gt; Option.map v413 |&gt; Option.defaultValue v414 
            let v418 : string =
                match v415 with
                | US4_1 -&gt; (* None *)
                    v70
                | US4_0(v416) -&gt; (* Some *)
                    v416
            let v419 : US0 = US0_1
            let v420 : (unit -&gt; string) = closure48(v329, v333, v330, v331, v332, v328)
            let v421 : (unit -&gt; string) = method48()
            method3(v419, v420, v421)
            let v422 : System.Text.Encoding = System.Text.Encoding.UTF8
            let v423 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v412, StandardOutputEncoding = v422, WorkingDirectory = v418, FileName = v411, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
            let v424 : int32 = v330.Length
            let v425 : Mut5 = {l0 = 0} : Mut5
            while method26(v424, v425) do
                let v427 : int32 = v425.l0
                let struct (v428 : string, v429 : string) = v330.[int v427]
                v423.EnvironmentVariables.[v428] &lt;- v429 
                let v430 : int32 = v427 + 1
                v425.l0 &lt;- v430
                ()
            let v431 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v423)
            use v431 = v431 
            let v432 : System.Diagnostics.Process = v431 
            let v433 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
            let v434 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v433 ()
            let v435 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v329, v333, v330, v331, v332, v328, v432, v434)
            v432.OutputDataReceived.Add v435 
            let v436 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v329, v333, v330, v331, v332, v328, v432, v434)
            v432.ErrorDataReceived.Add v436 
            let v437 : (unit -&gt; bool) = v432.Start
            let v438 : bool = v437 ()
            let v439 : bool = v438 = false
            if v439 then
                let v440 : string = $"execute_with_options_async / process_start error"
                failwith&lt;unit&gt; v440
            let v441 : (unit -&gt; unit) = v432.BeginErrorReadLine
            v441 ()
            let v442 : (unit -&gt; unit) = v432.BeginOutputReadLine
            v442 ()
            let v443 : (System.Threading.CancellationToken -&gt; US18) = method71()
            let v444 : US18 = US18_1
            let v445 : US18 = v329 |&gt; Option.map v443 |&gt; Option.defaultValue v444 
            let v449 : System.Threading.CancellationToken =
                match v445 with
                | US18_1 -&gt; (* None *)
                    let v447 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                    v447
                | US18_0(v446) -&gt; (* Some *)
                    v446
            let v450 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v451 : bool = true in let mutable _v450 = v450
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v452 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v452
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v453 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v453
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v454 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v454
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v455 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v455
#endif
            
#if FABLE_COMPILER_PYTHON
            let v456 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v456
#endif
            
#else
            let v457 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v458 : bool = true in let mutable _v457 = v457
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v459 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v459
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v460 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v460
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v461 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v461
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v462 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v462
#endif
            
#if FABLE_COMPILER_PYTHON
            let v463 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v463
#endif
            
#else
            let v464 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let mutable _v464 = v464
            async {
            let v465 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
            let! v465 = v465 
            let v466 : System.Threading.CancellationToken = v465 
            let v467 : System.Threading.CancellationToken = Async.DefaultCancellationToken
            let v468 : (System.Threading.CancellationToken []) = [|v466; v467; v449|]
            let v469 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
            let v470 : System.Threading.CancellationTokenSource = v469 v468
            let v471 : System.Threading.CancellationToken = v470.Token
            return v471 
            }
            |&gt; fun x -&gt; _v464 &lt;- Some x
            let v472 : Async&lt;System.Threading.CancellationToken&gt; = _v464 |&gt; Option.get
            v472
#endif
            |&gt; fun x -&gt; _v457 &lt;- Some x
            let v473 : Async&lt;System.Threading.CancellationToken&gt; = _v457.Value
            v473
#endif
            |&gt; fun x -&gt; _v450 &lt;- Some x
            let v474 : Async&lt;System.Threading.CancellationToken&gt; = _v450.Value
            let! v474 = v474 
            let v475 : System.Threading.CancellationToken = v474 
            let v476 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v475.Register
            let v477 : (unit -&gt; unit) = closure54(v432)
            let v478 : System.Threading.CancellationTokenRegistration = v476 v477
            use v478 = v478 
            let v479 : System.Threading.CancellationTokenRegistration = v478 
            let v480 : Async&lt;int32&gt; option = None
            let v481 : bool = true in let mutable _v480 = v480
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v482 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v482
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v483 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v483
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v484 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v484
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v485 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v485
#endif
            
#if FABLE_COMPILER_PYTHON
            let v486 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v486
#endif
            
#else
            let v487 : Async&lt;int32&gt; option = None
            let mutable _v487 = v487
            async {
            try
            let v488 : System.Threading.Tasks.Task = v432.WaitForExitAsync v475 
            let v489 : Async&lt;unit&gt; option = None
            let v490 : bool = true in let mutable _v489 = v489
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v491 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v491
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v492 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v492
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v493 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v493
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v494 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v494
#endif
            
#if FABLE_COMPILER_PYTHON
            let v495 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v495
#endif
            
#else
            let v496 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
            let v497 : Async&lt;unit&gt; = v496 v488
            v497
#endif
            |&gt; fun x -&gt; _v489 &lt;- Some x
            let v498 : Async&lt;unit&gt; = _v489.Value
            do! v498 
            let v499 : int32 = v432.ExitCode
            return v499 
            with ex -&gt;
            let v500 : exn = ex
            let v501 : string option = None
            let v502 : bool = true in let mutable _v501 = v501
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v503 : string = $"%A{v500}"
            v503
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v504 : string = $"%A{v500}"
            v504
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v505 : string = $"%A{v500}"
            v505
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v506 : string = $"%A{v500}"
            v506
#endif
            
#if FABLE_COMPILER_PYTHON
            let v507 : string = $"%A{v500}"
            v507
#endif
            
#else
            let v508 : string = $"{v500.GetType ()}: {v500.Message}"
            v508
#endif
            |&gt; fun x -&gt; _v501 &lt;- Some x
            let v509 : string = _v501.Value
            let v510 : (string -&gt; unit) = v434.Push
            v510 v509
            let v511 : System.Threading.Tasks.TaskCanceledException = v500 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
            let v512 : US0 = US0_3
            let v513 : (unit -&gt; string) = closure55(v511)
            let v514 : (unit -&gt; string) = method48()
            method3(v512, v513, v514)
            return -2147483648 
            (*
            *)
            }
            |&gt; fun x -&gt; _v487 &lt;- Some x
            let v515 : Async&lt;int32&gt; = _v487 |&gt; Option.get
            v515
#endif
            |&gt; fun x -&gt; _v480 &lt;- Some x
            let v516 : Async&lt;int32&gt; = _v480.Value
            let! v516 = v516 
            let v517 : int32 = v516 
            let v518 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
            let v519 : string seq = v518 v434
            let v520 : string = method72()
            let v521 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v522 : (string seq -&gt; string) = v521 v520
            let v523 : string = v522 v519
            let v524 : US0 = US0_1
            let v525 : (unit -&gt; string) = closure56(v517, v523)
            let v526 : (unit -&gt; string) = method48()
            method3(v524, v525, v526)
            return struct (v517, v523) 
            }
            |&gt; fun x -&gt; _v392 &lt;- Some x
            let v527 : Async&lt;struct (int32 * string)&gt; = _v392 |&gt; Option.get
            v527
#endif
            |&gt; fun x -&gt; _v385 &lt;- Some x
            let v528 : Async&lt;struct (int32 * string)&gt; = _v385.Value
            v528
#endif
            |&gt; fun x -&gt; _v378 &lt;- Some x
            let v529 : Async&lt;struct (int32 * string)&gt; = _v378.Value
            let v530 : struct (int32 * string) option = None
            let v531 : bool = true in let mutable _v530 = v530
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let struct (v532 : int32, v533 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v532, v533)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v534 : int32, v535 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v534, v535)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v536 : int32, v537 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v536, v537)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v538 : int32, v539 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v538, v539)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v540 : int32, v541 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v540, v541)
#endif
            
#else
            let v542 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
            let struct (v543 : int32, v544 : string) = v542 v529
            struct (v543, v544)
#endif
            |&gt; fun x -&gt; _v530 &lt;- Some x
            let struct (v545 : int32, v546 : string) = _v530.Value
            struct (v545, v546)
#endif
            |&gt; fun x -&gt; _v334 &lt;- Some x
            let struct (v547 : int32, v548 : string) = _v334.Value
            let v549 : bool = v547 = 0
            let v552 : US20 =
                if v549 then
                    US20_0(v548)
                else
                    US20_1(v548)
            let v558 : string =
                match v552 with
                | US20_1(v554) -&gt; (* Error *)
                    let v555 : string = $"resultm.get / Result value was Error: {v554}"
                    failwith&lt;string&gt; v555
                | US20_0(v553) -&gt; (* Ok *)
                    v553
            let v559 : bool = v308 = v558
            v559
        else
            false
    let v561 : bool = v560 = false
    if v561 then
        let v562 : US21 = method81(v5, v2, v1, v3)
        match v562 with
        | US21_1(v606, v607) -&gt; (* Error *)
            let v608 : (string * string) = v5, v607
            let v609 : Result&lt;string, (string * string)&gt; = Error v608
            US19_0(v609)
        | US21_0(v563, v564) -&gt; (* Ok *)
            let v565 : bool = v563 &lt;&gt; 0
            if v565 then
                let v566 : US0 = US0_2
                let v567 : (unit -&gt; string) = closure64()
                let v568 : (unit -&gt; string) = closure65(v564, v563)
                method3(v566, v567, v568)
                let v569 : (string * string) = v5, v564
                let v570 : Result&lt;string, (string * string)&gt; = Error v569
                US19_0(v570)
            else
                let v572 : bool option = None
                let v573 : bool = true in let mutable _v572 = v572
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v574 : string = method14(v5)
                let v575 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                let v576 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v574 v575
                let v577 : string = "String::from($0)"
                let v578 : std_string_String = Fable.Core.RustInterop.emitRustExpr v576 v577
                let v579 : string = "std::path::PathBuf::from($0)"
                let v580 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v578 v579
                let v581 : string = "$0.exists()"
                let v582 : bool = Fable.Core.RustInterop.emitRustExpr v580 v581
                let v585 : bool =
                    if v582 then
                        let v583 : string = "$0.is_file()"
                        let v584 : bool = Fable.Core.RustInterop.emitRustExpr v580 v583
                        v584
                    else
                        false
                v585
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                let v586 : bool = null |&gt; unbox&lt;bool&gt;
                v586
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                let v587 : bool = null |&gt; unbox&lt;bool&gt;
                v587
#endif
                
#if FABLE_COMPILER_TYPESCRIPT
                let v588 : IFsExistsSync = Fable.Core.JsInterop.importAll v22
                let v589 : string = "$0.existsSync($1)"
                let v590 : bool = Fable.Core.JsInterop.emitJsExpr struct (v588, v5) v589
                v590
#endif
                
#if FABLE_COMPILER_PYTHON
                let v591 : bool = null |&gt; unbox&lt;bool&gt;
                v591
#endif
                
#else
                let v592 : (string -&gt; bool) = System.IO.File.Exists
                let v593 : bool = v592 v5
                v593
#endif
                |&gt; fun x -&gt; _v572 &lt;- Some x
                let v594 : bool = _v572.Value
                if v594 then
                    let v595 : unit option = None
                    let v596 : bool = true in let mutable _v595 = v595
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v597 : string = method74(v4)
                    let v598 : string = "std::fs::copy(&amp;*$0, &amp;*v597)"
                    let v599 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v5 v598
                    let v600 : string = "$0.unwrap()"
                    let v601 : uint64 = Fable.Core.RustInterop.emitRustExpr v599 v600
                    ()
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#if FABLE_COMPILER_PYTHON
                    null |&gt; unbox&lt;unit&gt;
                    ()
#endif
                    
#else
                    System.IO.File.Copy (v5, v4, true)
                    ()
#endif
                    |&gt; fun x -&gt; _v595 &lt;- Some x
                    _v595.Value
                    ()
                else
                    let v602 : string = $"documents.files_fn / {v5} should exist"
                    failwith&lt;unit&gt; v602
                let v603 : Result&lt;string, (string * string)&gt; = Ok v5
                US19_0(v603)
    else
        US19_1
and closure66 (v0 : string, v1 : string) (v2 : string) : (string -&gt; US19) =
    closure67(v0, v1, v2)
and closure70 () () : string =
    let v0 : string = "documents.run / par_map / files' = [] / listm.iter"
    v0
and closure71 (v0 : string, v1 : string) () : string =
    let v2 : (unit -&gt; string) = closure6()
    let v3 : string = $"output_path: %A{v1} / output_cache_path: {v0} / {v2 ()}"
    v3
and method82 (v0 : UH2, v1 : UH3 list) : UH3 list =
    match v0 with
    | UH2_1(v2, v3) -&gt; (* Cons *)
        let v4 : UH3 list = method82(v3, v1)
        let v5 : UH3 list = v2 :: v4 
        v5
    | UH2_0 -&gt; (* Nil *)
        v1
and method83 (v0 : int32, v1 : Mut8) : bool =
    let v2 : int32 = v1.l0
    let v3 : bool = v2 &lt; v0
    v3
and method84 (v0 : UH3, v1 : struct (string * string * (string -&gt; (string -&gt; US19))) list) : struct (string * string * (string -&gt; (string -&gt; US19))) list =
    match v0 with
    | UH3_1(v2, v3, v4, v5) -&gt; (* Cons *)
        let v6 : struct (string * string * (string -&gt; (string -&gt; US19))) list = method84(v5, v1)
        let v7 : struct (string * string * (string -&gt; (string -&gt; US19))) list = struct (v2, v3, v4) :: v6 
        v7
    | UH3_0 -&gt; (* Nil *)
        v1
and closure72 () struct (v0 : string, v1 : string, v2 : (string -&gt; (string -&gt; US19))) : Result&lt;string, (string * string)&gt; option =
    let v3 : (string -&gt; US19) = v2 v1
    let v4 : US19 = v3 v0
    match v4 with
    | US19_1 -&gt; (* None *)
        let v7 : Result&lt;string, (string * string)&gt; option = None
        v7
    | US19_0(v5) -&gt; (* Some *)
        let v6 : Result&lt;string, (string * string)&gt; option = Some v5 
        v6
and method85 (v0 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; =
    v0
and method86 (v0 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; =
    v0
and closure25 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : string) (v5 : string) : Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt; =
    let v6 : string option = None
    let v7 : bool = true in let mutable _v6 = v6
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v8 : string = method21(v5)
    let v9 : string = method14(v8)
    let v10 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v11 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v9 v10
    let v12 : string = "String::from($0)"
    let v13 : std_string_String = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = "std::path::PathBuf::from($0)"
    let v15 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "$0.exists()"
    let v17 : bool = Fable.Core.RustInterop.emitRustExpr v15 v16
    let v18 : bool = v17 = false
    let v168 : string =
        if v18 then
            let v19 : string option = None
            let v20 : bool = true in let mutable _v19 = v19
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v21 : string = "std::env::current_dir()"
            let v22 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v21
            let v23 : string = "$0.unwrap()"
            let v24 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v22 v23
            let v25 : string = "$0.display()"
            let v26 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v24 v25
            let v27 : std_string_String option = None
            let v28 : bool = true in let mutable _v27 = v27
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v29 : string = @$"format!(""{{}}"", $0)"
            let v30 : std_string_String = Fable.Core.RustInterop.emitRustExpr v26 v29
            v30
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v31 : string = @$"format!(""{{}}"", $0)"
            let v32 : std_string_String = Fable.Core.RustInterop.emitRustExpr v26 v31
            v32
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v33 : string = @$"format!(""{{}}"", $0)"
            let v34 : std_string_String = Fable.Core.RustInterop.emitRustExpr v26 v33
            v34
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v35 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v35
#endif
            
#if FABLE_COMPILER_PYTHON
            let v36 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v36
#endif
            
#else
            let v37 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v37
#endif
            |&gt; fun x -&gt; _v27 &lt;- Some x
            let v38 : std_string_String = _v27.Value
            let v39 : string = "fable_library_rust::String_::fromString($0)"
            let v40 : string = Fable.Core.RustInterop.emitRustExpr v38 v39
            v40
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v41 : string = null |&gt; unbox&lt;string&gt;
            v41
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v42 : string = null |&gt; unbox&lt;string&gt;
            v42
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v43 : string = null |&gt; unbox&lt;string&gt;
            v43
#endif
            
#if FABLE_COMPILER_PYTHON
            let v44 : string = null |&gt; unbox&lt;string&gt;
            v44
#endif
            
#else
            let v45 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v46 : string = v45 ()
            v46
#endif
            |&gt; fun x -&gt; _v19 &lt;- Some x
            let v47 : string = _v19.Value
            let v48 : string = method13(v47, v8)
            let v49 : string option = None
            let v50 : bool = true in let mutable _v49 = v49
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v51 : string = method22()
            let v52 : string = method23(v48)
            let v53 : string = method24()
            let v54 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v55 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v51, v52, v53) v54
            let v56 : string = "String::from($0)"
            let v57 : std_string_String = Fable.Core.RustInterop.emitRustExpr v55 v56
            let v58 : string = "fable_library_rust::String_::fromString($0)"
            let v59 : string = Fable.Core.RustInterop.emitRustExpr v57 v58
            v59
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v60 : string = null |&gt; unbox&lt;string&gt;
            v60
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v61 : string = null |&gt; unbox&lt;string&gt;
            v61
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v62 : string = null |&gt; unbox&lt;string&gt;
            v62
#endif
            
#if FABLE_COMPILER_PYTHON
            let v63 : string = null |&gt; unbox&lt;string&gt;
            v63
#endif
            
#else
            let v64 : string = "^\\\\\\\\\\?\\\\"
            let v65 : string = ""
            let v66 : string = System.Text.RegularExpressions.Regex.Replace (v48, v64, v65)
            v66
#endif
            |&gt; fun x -&gt; _v49 &lt;- Some x
            let v67 : string = _v49.Value
            let v68 : string = $"{v67.[0] |&gt; string |&gt; _.ToLower()}{v67.[1..]}"
            let v69 : string = "\\"
            let v70 : string = "/"
            let v71 : string = v68.Replace (v69, v70)
            let v72 : (string []) = v71.Split v70
            let v73 : (string []) = [||]
            let v74 : int32 = v72.Length
            let v75 : Mut4 = {l0 = 0; l1 = 0; l2 = v73} : Mut4
            while method25(v74, v75) do
                let v77 : int32 = v75.l0
                let v78 : int32 =  -v77
                let v79 : int32 = v78 + v74
                let v80 : int32 = v79 - 1
                let struct (v81 : int32, v82 : (string [])) = v75.l1, v75.l2
                let v83 : string = v72.[int v80]
                let v84 : bool = ".." = v83
                let struct (v126 : int32, v127 : (string [])) =
                    if v84 then
                        let v85 : int32 = v81 + 1
                        struct (v85, v82)
                    else
                        let v86 : bool = "." = v83
                        if v86 then
                            struct (v81, v82)
                        else
                            let v87 : bool = 0 = v81
                            if v87 then
                                let v88 : string = ":"
                                let v89 : bool = v83.EndsWith v88
                                if v89 then
                                    let v90 : string = $"{v47.[0]}:"
                                    let v91 : (string []) = [|v90|]
                                    let v92 : int32 = v91.Length
                                    let v93 : int32 = v82.Length
                                    let v94 : int32 = v92 + v93
                                    let v95 : (string []) = Array.zeroCreate&lt;string&gt; (v94)
                                    let v96 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v94, v96) do
                                        let v98 : int32 = v96.l0
                                        let v99 : bool = v98 &lt; v92
                                        let v103 : string =
                                            if v99 then
                                                let v100 : string = v91.[int v98]
                                                v100
                                            else
                                                let v101 : int32 = v98 - v92
                                                let v102 : string = v82.[int v101]
                                                v102
                                        v95.[int v98] &lt;- v103
                                        let v104 : int32 = v98 + 1
                                        v96.l0 &lt;- v104
                                        ()
                                    struct (0, v95)
                                else
                                    let v105 : (string []) = [|v83|]
                                    let v106 : int32 = v105.Length
                                    let v107 : int32 = v82.Length
                                    let v108 : int32 = v106 + v107
                                    let v109 : (string []) = Array.zeroCreate&lt;string&gt; (v108)
                                    let v110 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v108, v110) do
                                        let v112 : int32 = v110.l0
                                        let v113 : bool = v112 &lt; v106
                                        let v117 : string =
                                            if v113 then
                                                let v114 : string = v105.[int v112]
                                                v114
                                            else
                                                let v115 : int32 = v112 - v106
                                                let v116 : string = v82.[int v115]
                                                v116
                                        v109.[int v112] &lt;- v117
                                        let v118 : int32 = v112 + 1
                                        v110.l0 &lt;- v118
                                        ()
                                    struct (0, v109)
                            else
                                let v121 : int32 = v81 - 1
                                struct (v121, v82)
                let v128 : int32 = v77 + 1
                v75.l0 &lt;- v128
                v75.l1 &lt;- v126
                v75.l2 &lt;- v127
                ()
            let struct (v129 : int32, v130 : (string [])) = v75.l1, v75.l2
            let v131 : string seq = seq { for i = 0 to v130.Length - 1 do yield v130.[i] }
            let v132 : char option = None
            let v133 : bool = true in let mutable _v132 = v132
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v134 : string = "std::path::MAIN_SEPARATOR"
            let v135 : char = Fable.Core.RustInterop.emitRustExpr () v134
            v135
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v136 : char = null |&gt; unbox&lt;char&gt;
            v136
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v137 : char = null |&gt; unbox&lt;char&gt;
            v137
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v138 : char = null |&gt; unbox&lt;char&gt;
            v138
#endif
            
#if FABLE_COMPILER_PYTHON
            let v139 : char = null |&gt; unbox&lt;char&gt;
            v139
#endif
            
#else
            let v140 : char = System.IO.Path.DirectorySeparatorChar
            v140
#endif
            |&gt; fun x -&gt; _v132 &lt;- Some x
            let v141 : char = _v132.Value
            let v142 : (char -&gt; string) = _.ToString()
            let v143 : string = v142 v141
            let v144 : string = method27(v143)
            let v145 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v146 : (string seq -&gt; string) = v145 v144
            v146 v131
        else
            let v148 : string = "std::fs::canonicalize(&amp;*$0)"
            let v149 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v8 v148
            let v150 : string = "$0.unwrap()"
            let v151 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v149 v150
            let v152 : string = "$0.display()"
            let v153 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v151 v152
            let v154 : std_string_String option = None
            let v155 : bool = true in let mutable _v154 = v154
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v156 : string = @$"format!(""{{}}"", $0)"
            let v157 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v156
            v157
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v158 : string = @$"format!(""{{}}"", $0)"
            let v159 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v158
            v159
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v160 : string = @$"format!(""{{}}"", $0)"
            let v161 : std_string_String = Fable.Core.RustInterop.emitRustExpr v153 v160
            v161
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v162 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v162
#endif
            
#if FABLE_COMPILER_PYTHON
            let v163 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v163
#endif
            
#else
            let v164 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v164
#endif
            |&gt; fun x -&gt; _v154 &lt;- Some x
            let v165 : std_string_String = _v154.Value
            let v166 : string = "fable_library_rust::String_::fromString($0)"
            let v167 : string = Fable.Core.RustInterop.emitRustExpr v165 v166
            v167
    v168
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v169 : string = null |&gt; unbox&lt;string&gt;
    v169
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v170 : string = null |&gt; unbox&lt;string&gt;
    v170
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v171 : string = null |&gt; unbox&lt;string&gt;
    v171
#endif
    
#if FABLE_COMPILER_PYTHON
    let v172 : string = null |&gt; unbox&lt;string&gt;
    v172
#endif
    
#else
    let v173 : string = method28(v5)
    let v174 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v175 : string = v174 v173
    v175
#endif
    |&gt; fun x -&gt; _v6 &lt;- Some x
    let v176 : string = _v6.Value
    let v177 : string = method14(v176)
    let v178 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v179 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v177 v178
    let v180 : string = "String::from($0)"
    let v181 : std_string_String = Fable.Core.RustInterop.emitRustExpr v179 v180
    let v182 : string = "std::path::PathBuf::from($0)"
    let v183 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v181 v182
    let v184 : string = "$0.display()"
    let v185 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v183 v184
    let v186 : std_string_String option = None
    let v187 : bool = true in let mutable _v186 = v186
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v188 : string = @$"format!(""{{}}"", $0)"
    let v189 : std_string_String = Fable.Core.RustInterop.emitRustExpr v185 v188
    v189
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v190 : string = @$"format!(""{{}}"", $0)"
    let v191 : std_string_String = Fable.Core.RustInterop.emitRustExpr v185 v190
    v191
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v192 : string = @$"format!(""{{}}"", $0)"
    let v193 : std_string_String = Fable.Core.RustInterop.emitRustExpr v185 v192
    v193
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v194 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v194
#endif
    
#if FABLE_COMPILER_PYTHON
    let v195 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v195
#endif
    
#else
    let v196 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
    v196
#endif
    |&gt; fun x -&gt; _v186 &lt;- Some x
    let v197 : std_string_String = _v186.Value
    let v198 : string = "fable_library_rust::String_::fromString($0)"
    let v199 : string = Fable.Core.RustInterop.emitRustExpr v197 v198
    let v200 : string = ""
    let v201 : string = v199.Replace (v3, v200)
    let v202 : string = "\\"
    let v203 : string = "/"
    let v204 : string = v201.Replace (v202, v203)
    let v205 : string = $".{v204}"
    let v206 : string option = None
    let v207 : bool = true in let mutable _v206 = v206
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v208 : string = method22()
    let v209 : string = method23(v176)
    let v210 : string = method24()
    let v211 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
    let v212 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v208, v209, v210) v211
    let v213 : string = "String::from($0)"
    let v214 : std_string_String = Fable.Core.RustInterop.emitRustExpr v212 v213
    let v215 : string = "fable_library_rust::String_::fromString($0)"
    let v216 : string = Fable.Core.RustInterop.emitRustExpr v214 v215
    v216
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v217 : string = null |&gt; unbox&lt;string&gt;
    v217
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v218 : string = null |&gt; unbox&lt;string&gt;
    v218
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v219 : string = null |&gt; unbox&lt;string&gt;
    v219
#endif
    
#if FABLE_COMPILER_PYTHON
    let v220 : string = null |&gt; unbox&lt;string&gt;
    v220
#endif
    
#else
    let v221 : string = "^\\\\\\\\\\?\\\\"
    let v222 : string = System.Text.RegularExpressions.Regex.Replace (v176, v221, v200)
    v222
#endif
    |&gt; fun x -&gt; _v206 &lt;- Some x
    let v223 : string = _v206.Value
    let v224 : string = $"{v223.[0] |&gt; string |&gt; _.ToLower()}{v223.[1..]}"
    let v225 : string = v224.Replace (v202, v203)
    let v226 : string = method13(v2, v205)
    let v227 : string = method38(v226)
    let v228 : string option = None
    let v229 : System.Threading.CancellationToken option = None
    let v230 : (struct (string * string) []) = [||]
    let v231 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v232 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v233 : string = $"git ls-tree --format='%%(objectname)' origin/gh-pages \"{v227}\""
    let v234 : string option = Some v2 
    let v235 : struct (int32 * string) option = None
    let v236 : bool = true in let mutable _v235 = v235
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v237 : string = method39(v229, v233, v230, v231, v232, v234)
    let struct (v238 : string, v239 : string) = method40()
    let v240 : int32 = v237.Length
    let v241 : (char []) = Array.zeroCreate&lt;char&gt; (v240)
    let v242 : Mut5 = {l0 = 0} : Mut5
    while method26(v240, v242) do
        let v244 : int32 = v242.l0
        let v245 : char = v237.[int v244]
        v241.[int v244] &lt;- v245
        let v246 : int32 = v244 + 1
        v242.l0 &lt;- v246
        ()
    let v247 : ((char []) -&gt; char list) = Array.toList
    let v248 : char list = v247 v241
    let v249 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v250 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v251 : (char list -&gt; (UH0 -&gt; UH0)) = v249 v250
    let v252 : (UH0 -&gt; UH0) = v251 v248
    let v253 : UH0 = UH0_0
    let v254 : UH0 = v252 v253
    let v255 : US8 = US8_0
    let struct (v256 : string, v257 : string) = method42(v239, v238, v254, v255)
    let v258 : (string []) = method43(v257)
    let v259 : string = "$0.to_vec()"
    let v260 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v258 v259
    let v261 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
    let v262 : (string -&gt; std_string_String) = closure28()
    let v263 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v260, v262) v261
    let v264 : US0 = US0_1
    let v265 : (unit -&gt; string) = closure29(v229, v233, v230, v231, v232, v234, v256, v263)
    let v266 : (unit -&gt; string) = method48()
    method3(v264, v265, v266)
    let v267 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v229, v233, v230, v231, v232, v234, v256, v263)
    let v268 : string = "futures_lite::future::block_on($0)"
    let v269 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v267 v268
    let (a, b) = v269
    let v270 : int32 = a
    let v271 : string = b
    struct (v270, v271)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v272 : int32, v273 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v272, v273)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v274 : int32, v275 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v274, v275)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v276 : int32, v277 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v276, v277)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v278 : int32, v279 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v278, v279)
#endif
    
#else
    let v280 : Async&lt;struct (int32 * string)&gt; option = None
    let v281 : bool = true in let mutable _v280 = v280
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v282 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v282
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v283 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v283
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v284 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v284
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v285 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v285
#endif
    
#if FABLE_COMPILER_PYTHON
    let v286 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v286
#endif
    
#else
    let v287 : Async&lt;struct (int32 * string)&gt; option = None
    let v288 : bool = true in let mutable _v287 = v287
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v289 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v289
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v290 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v290
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v291 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v291
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v292 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v292
#endif
    
#if FABLE_COMPILER_PYTHON
    let v293 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v293
#endif
    
#else
    let v294 : Async&lt;struct (int32 * string)&gt; option = None
    let mutable _v294 = v294
    async {
    let struct (v295 : string, v296 : string) = method40()
    let v297 : int32 = v233.Length
    let v298 : (char []) = Array.zeroCreate&lt;char&gt; (v297)
    let v299 : Mut5 = {l0 = 0} : Mut5
    while method26(v297, v299) do
        let v301 : int32 = v299.l0
        let v302 : char = v233.[int v301]
        v298.[int v301] &lt;- v302
        let v303 : int32 = v301 + 1
        v299.l0 &lt;- v303
        ()
    let v304 : ((char []) -&gt; char list) = Array.toList
    let v305 : char list = v304 v298
    let v306 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v307 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v308 : (char list -&gt; (UH0 -&gt; UH0)) = v306 v307
    let v309 : (UH0 -&gt; UH0) = v308 v305
    let v310 : UH0 = UH0_0
    let v311 : UH0 = v309 v310
    let v312 : US8 = US8_0
    let struct (v313 : string, v314 : string) = method42(v296, v295, v311, v312)
    let v315 : (string -&gt; US4) = method19()
    let v316 : US4 = US4_1
    let v317 : US4 = v234 |&gt; Option.map v315 |&gt; Option.defaultValue v316 
    let v320 : string =
        match v317 with
        | US4_1 -&gt; (* None *)
            v200
        | US4_0(v318) -&gt; (* Some *)
            v318
    let v321 : US0 = US0_1
    let v322 : (unit -&gt; string) = closure48(v229, v233, v230, v231, v232, v234)
    let v323 : (unit -&gt; string) = method48()
    method3(v321, v322, v323)
    let v324 : System.Text.Encoding = System.Text.Encoding.UTF8
    let v325 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v314, StandardOutputEncoding = v324, WorkingDirectory = v320, FileName = v313, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
    let v326 : int32 = v230.Length
    let v327 : Mut5 = {l0 = 0} : Mut5
    while method26(v326, v327) do
        let v329 : int32 = v327.l0
        let struct (v330 : string, v331 : string) = v230.[int v329]
        v325.EnvironmentVariables.[v330] &lt;- v331 
        let v332 : int32 = v329 + 1
        v327.l0 &lt;- v332
        ()
    let v333 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v325)
    use v333 = v333 
    let v334 : System.Diagnostics.Process = v333 
    let v335 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
    let v336 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v335 ()
    let v337 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v229, v233, v230, v231, v232, v234, v334, v336)
    v334.OutputDataReceived.Add v337 
    let v338 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v229, v233, v230, v231, v232, v234, v334, v336)
    v334.ErrorDataReceived.Add v338 
    let v339 : (unit -&gt; bool) = v334.Start
    let v340 : bool = v339 ()
    let v341 : bool = v340 = false
    if v341 then
        let v342 : string = $"execute_with_options_async / process_start error"
        failwith&lt;unit&gt; v342
    let v343 : (unit -&gt; unit) = v334.BeginErrorReadLine
    v343 ()
    let v344 : (unit -&gt; unit) = v334.BeginOutputReadLine
    v344 ()
    let v345 : (System.Threading.CancellationToken -&gt; US18) = method71()
    let v346 : US18 = US18_1
    let v347 : US18 = v229 |&gt; Option.map v345 |&gt; Option.defaultValue v346 
    let v351 : System.Threading.CancellationToken =
        match v347 with
        | US18_1 -&gt; (* None *)
            let v349 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
            v349
        | US18_0(v348) -&gt; (* Some *)
            v348
    let v352 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v353 : bool = true in let mutable _v352 = v352
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v354 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v354
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v355 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v355
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v356 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v356
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v357 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v357
#endif
    
#if FABLE_COMPILER_PYTHON
    let v358 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v358
#endif
    
#else
    let v359 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v360 : bool = true in let mutable _v359 = v359
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v361 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v361
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v362 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v362
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v363 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v363
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v364 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v364
#endif
    
#if FABLE_COMPILER_PYTHON
    let v365 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v365
#endif
    
#else
    let v366 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let mutable _v366 = v366
    async {
    let v367 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
    let! v367 = v367 
    let v368 : System.Threading.CancellationToken = v367 
    let v369 : System.Threading.CancellationToken = Async.DefaultCancellationToken
    let v370 : (System.Threading.CancellationToken []) = [|v368; v369; v351|]
    let v371 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
    let v372 : System.Threading.CancellationTokenSource = v371 v370
    let v373 : System.Threading.CancellationToken = v372.Token
    return v373 
    }
    |&gt; fun x -&gt; _v366 &lt;- Some x
    let v374 : Async&lt;System.Threading.CancellationToken&gt; = _v366 |&gt; Option.get
    v374
#endif
    |&gt; fun x -&gt; _v359 &lt;- Some x
    let v375 : Async&lt;System.Threading.CancellationToken&gt; = _v359.Value
    v375
#endif
    |&gt; fun x -&gt; _v352 &lt;- Some x
    let v376 : Async&lt;System.Threading.CancellationToken&gt; = _v352.Value
    let! v376 = v376 
    let v377 : System.Threading.CancellationToken = v376 
    let v378 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v377.Register
    let v379 : (unit -&gt; unit) = closure54(v334)
    let v380 : System.Threading.CancellationTokenRegistration = v378 v379
    use v380 = v380 
    let v381 : System.Threading.CancellationTokenRegistration = v380 
    let v382 : Async&lt;int32&gt; option = None
    let v383 : bool = true in let mutable _v382 = v382
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v384 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v384
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v385 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v385
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v386 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v386
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v387 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v387
#endif
    
#if FABLE_COMPILER_PYTHON
    let v388 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v388
#endif
    
#else
    let v389 : Async&lt;int32&gt; option = None
    let mutable _v389 = v389
    async {
    try
    let v390 : System.Threading.Tasks.Task = v334.WaitForExitAsync v377 
    let v391 : Async&lt;unit&gt; option = None
    let v392 : bool = true in let mutable _v391 = v391
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v393 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v393
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v394 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v394
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v395 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v395
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v396 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v396
#endif
    
#if FABLE_COMPILER_PYTHON
    let v397 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v397
#endif
    
#else
    let v398 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
    let v399 : Async&lt;unit&gt; = v398 v390
    v399
#endif
    |&gt; fun x -&gt; _v391 &lt;- Some x
    let v400 : Async&lt;unit&gt; = _v391.Value
    do! v400 
    let v401 : int32 = v334.ExitCode
    return v401 
    with ex -&gt;
    let v402 : exn = ex
    let v403 : string option = None
    let v404 : bool = true in let mutable _v403 = v403
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v405 : string = $"%A{v402}"
    v405
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v406 : string = $"%A{v402}"
    v406
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v407 : string = $"%A{v402}"
    v407
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v408 : string = $"%A{v402}"
    v408
#endif
    
#if FABLE_COMPILER_PYTHON
    let v409 : string = $"%A{v402}"
    v409
#endif
    
#else
    let v410 : string = $"{v402.GetType ()}: {v402.Message}"
    v410
#endif
    |&gt; fun x -&gt; _v403 &lt;- Some x
    let v411 : string = _v403.Value
    let v412 : (string -&gt; unit) = v336.Push
    v412 v411
    let v413 : System.Threading.Tasks.TaskCanceledException = v402 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
    let v414 : US0 = US0_3
    let v415 : (unit -&gt; string) = closure55(v413)
    let v416 : (unit -&gt; string) = method48()
    method3(v414, v415, v416)
    return -2147483648 
    (*
    *)
    }
    |&gt; fun x -&gt; _v389 &lt;- Some x
    let v417 : Async&lt;int32&gt; = _v389 |&gt; Option.get
    v417
#endif
    |&gt; fun x -&gt; _v382 &lt;- Some x
    let v418 : Async&lt;int32&gt; = _v382.Value
    let! v418 = v418 
    let v419 : int32 = v418 
    let v420 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
    let v421 : string seq = v420 v336
    let v422 : string = method72()
    let v423 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v424 : (string seq -&gt; string) = v423 v422
    let v425 : string = v424 v421
    let v426 : US0 = US0_1
    let v427 : (unit -&gt; string) = closure56(v419, v425)
    let v428 : (unit -&gt; string) = method48()
    method3(v426, v427, v428)
    return struct (v419, v425) 
    }
    |&gt; fun x -&gt; _v294 &lt;- Some x
    let v429 : Async&lt;struct (int32 * string)&gt; = _v294 |&gt; Option.get
    v429
#endif
    |&gt; fun x -&gt; _v287 &lt;- Some x
    let v430 : Async&lt;struct (int32 * string)&gt; = _v287.Value
    v430
#endif
    |&gt; fun x -&gt; _v280 &lt;- Some x
    let v431 : Async&lt;struct (int32 * string)&gt; = _v280.Value
    let v432 : struct (int32 * string) option = None
    let v433 : bool = true in let mutable _v432 = v432
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let struct (v434 : int32, v435 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v434, v435)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v436 : int32, v437 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v436, v437)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v438 : int32, v439 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v438, v439)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v440 : int32, v441 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v440, v441)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v442 : int32, v443 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v442, v443)
#endif
    
#else
    let v444 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
    let struct (v445 : int32, v446 : string) = v444 v431
    struct (v445, v446)
#endif
    |&gt; fun x -&gt; _v432 &lt;- Some x
    let struct (v447 : int32, v448 : string) = _v432.Value
    struct (v447, v448)
#endif
    |&gt; fun x -&gt; _v235 &lt;- Some x
    let struct (v449 : int32, v450 : string) = _v235.Value
    let v451 : string = method13(v3, v205)
    let v452 : string = method38(v451)
    let v453 : string option = None
    let v454 : System.Threading.CancellationToken option = None
    let v455 : (struct (string * string) []) = [||]
    let v456 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
    let v457 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
    let v458 : string = $"git hash-object \"{v452}\""
    let v459 : string option = Some v3 
    let v460 : struct (int32 * string) option = None
    let v461 : bool = true in let mutable _v460 = v460
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v462 : string = method39(v454, v458, v455, v456, v457, v459)
    let struct (v463 : string, v464 : string) = method40()
    let v465 : int32 = v462.Length
    let v466 : (char []) = Array.zeroCreate&lt;char&gt; (v465)
    let v467 : Mut5 = {l0 = 0} : Mut5
    while method26(v465, v467) do
        let v469 : int32 = v467.l0
        let v470 : char = v462.[int v469]
        v466.[int v469] &lt;- v470
        let v471 : int32 = v469 + 1
        v467.l0 &lt;- v471
        ()
    let v472 : ((char []) -&gt; char list) = Array.toList
    let v473 : char list = v472 v466
    let v474 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v475 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v476 : (char list -&gt; (UH0 -&gt; UH0)) = v474 v475
    let v477 : (UH0 -&gt; UH0) = v476 v473
    let v478 : UH0 = UH0_0
    let v479 : UH0 = v477 v478
    let v480 : US8 = US8_0
    let struct (v481 : string, v482 : string) = method42(v464, v463, v479, v480)
    let v483 : (string []) = method43(v482)
    let v484 : string = "$0.to_vec()"
    let v485 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v483 v484
    let v486 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
    let v487 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v485, v262) v486
    let v488 : US0 = US0_1
    let v489 : (unit -&gt; string) = closure29(v454, v458, v455, v456, v457, v459, v481, v487)
    let v490 : (unit -&gt; string) = method48()
    method3(v488, v489, v490)
    let v491 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v454, v458, v455, v456, v457, v459, v481, v487)
    let v492 : string = "futures_lite::future::block_on($0)"
    let v493 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v491 v492
    let (a, b) = v493
    let v494 : int32 = a
    let v495 : string = b
    struct (v494, v495)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v496 : int32, v497 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v496, v497)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v498 : int32, v499 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v498, v499)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v500 : int32, v501 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v500, v501)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v502 : int32, v503 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v502, v503)
#endif
    
#else
    let v504 : Async&lt;struct (int32 * string)&gt; option = None
    let v505 : bool = true in let mutable _v504 = v504
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v506 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v506
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v507 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v507
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v508 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v508
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v509 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v509
#endif
    
#if FABLE_COMPILER_PYTHON
    let v510 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v510
#endif
    
#else
    let v511 : Async&lt;struct (int32 * string)&gt; option = None
    let v512 : bool = true in let mutable _v511 = v511
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v513 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v513
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v514 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v514
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v515 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v515
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v516 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v516
#endif
    
#if FABLE_COMPILER_PYTHON
    let v517 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
    v517
#endif
    
#else
    let v518 : Async&lt;struct (int32 * string)&gt; option = None
    let mutable _v518 = v518
    async {
    let struct (v519 : string, v520 : string) = method40()
    let v521 : int32 = v458.Length
    let v522 : (char []) = Array.zeroCreate&lt;char&gt; (v521)
    let v523 : Mut5 = {l0 = 0} : Mut5
    while method26(v521, v523) do
        let v525 : int32 = v523.l0
        let v526 : char = v458.[int v525]
        v522.[int v525] &lt;- v526
        let v527 : int32 = v525 + 1
        v523.l0 &lt;- v527
        ()
    let v528 : ((char []) -&gt; char list) = Array.toList
    let v529 : char list = v528 v522
    let v530 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
    let v531 : (char -&gt; (UH0 -&gt; UH0)) = method41()
    let v532 : (char list -&gt; (UH0 -&gt; UH0)) = v530 v531
    let v533 : (UH0 -&gt; UH0) = v532 v529
    let v534 : UH0 = UH0_0
    let v535 : UH0 = v533 v534
    let v536 : US8 = US8_0
    let struct (v537 : string, v538 : string) = method42(v520, v519, v535, v536)
    let v539 : (string -&gt; US4) = method19()
    let v540 : US4 = US4_1
    let v541 : US4 = v459 |&gt; Option.map v539 |&gt; Option.defaultValue v540 
    let v544 : string =
        match v541 with
        | US4_1 -&gt; (* None *)
            v200
        | US4_0(v542) -&gt; (* Some *)
            v542
    let v545 : US0 = US0_1
    let v546 : (unit -&gt; string) = closure48(v454, v458, v455, v456, v457, v459)
    let v547 : (unit -&gt; string) = method48()
    method3(v545, v546, v547)
    let v548 : System.Text.Encoding = System.Text.Encoding.UTF8
    let v549 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v538, StandardOutputEncoding = v548, WorkingDirectory = v544, FileName = v537, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
    let v550 : int32 = v455.Length
    let v551 : Mut5 = {l0 = 0} : Mut5
    while method26(v550, v551) do
        let v553 : int32 = v551.l0
        let struct (v554 : string, v555 : string) = v455.[int v553]
        v549.EnvironmentVariables.[v554] &lt;- v555 
        let v556 : int32 = v553 + 1
        v551.l0 &lt;- v556
        ()
    let v557 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v549)
    use v557 = v557 
    let v558 : System.Diagnostics.Process = v557 
    let v559 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
    let v560 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v559 ()
    let v561 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v454, v458, v455, v456, v457, v459, v558, v560)
    v558.OutputDataReceived.Add v561 
    let v562 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v454, v458, v455, v456, v457, v459, v558, v560)
    v558.ErrorDataReceived.Add v562 
    let v563 : (unit -&gt; bool) = v558.Start
    let v564 : bool = v563 ()
    let v565 : bool = v564 = false
    if v565 then
        let v566 : string = $"execute_with_options_async / process_start error"
        failwith&lt;unit&gt; v566
    let v567 : (unit -&gt; unit) = v558.BeginErrorReadLine
    v567 ()
    let v568 : (unit -&gt; unit) = v558.BeginOutputReadLine
    v568 ()
    let v569 : (System.Threading.CancellationToken -&gt; US18) = method71()
    let v570 : US18 = US18_1
    let v571 : US18 = v454 |&gt; Option.map v569 |&gt; Option.defaultValue v570 
    let v575 : System.Threading.CancellationToken =
        match v571 with
        | US18_1 -&gt; (* None *)
            let v573 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
            v573
        | US18_0(v572) -&gt; (* Some *)
            v572
    let v576 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v577 : bool = true in let mutable _v576 = v576
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v578 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v578
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v579 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v579
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v580 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v580
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v581 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v581
#endif
    
#if FABLE_COMPILER_PYTHON
    let v582 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v582
#endif
    
#else
    let v583 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let v584 : bool = true in let mutable _v583 = v583
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v585 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v585
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v586 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v586
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v587 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v587
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v588 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v588
#endif
    
#if FABLE_COMPILER_PYTHON
    let v589 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
    v589
#endif
    
#else
    let v590 : Async&lt;System.Threading.CancellationToken&gt; option = None
    let mutable _v590 = v590
    async {
    let v591 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
    let! v591 = v591 
    let v592 : System.Threading.CancellationToken = v591 
    let v593 : System.Threading.CancellationToken = Async.DefaultCancellationToken
    let v594 : (System.Threading.CancellationToken []) = [|v592; v593; v575|]
    let v595 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
    let v596 : System.Threading.CancellationTokenSource = v595 v594
    let v597 : System.Threading.CancellationToken = v596.Token
    return v597 
    }
    |&gt; fun x -&gt; _v590 &lt;- Some x
    let v598 : Async&lt;System.Threading.CancellationToken&gt; = _v590 |&gt; Option.get
    v598
#endif
    |&gt; fun x -&gt; _v583 &lt;- Some x
    let v599 : Async&lt;System.Threading.CancellationToken&gt; = _v583.Value
    v599
#endif
    |&gt; fun x -&gt; _v576 &lt;- Some x
    let v600 : Async&lt;System.Threading.CancellationToken&gt; = _v576.Value
    let! v600 = v600 
    let v601 : System.Threading.CancellationToken = v600 
    let v602 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v601.Register
    let v603 : (unit -&gt; unit) = closure54(v558)
    let v604 : System.Threading.CancellationTokenRegistration = v602 v603
    use v604 = v604 
    let v605 : System.Threading.CancellationTokenRegistration = v604 
    let v606 : Async&lt;int32&gt; option = None
    let v607 : bool = true in let mutable _v606 = v606
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v608 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v608
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v609 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v609
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v610 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v610
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v611 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v611
#endif
    
#if FABLE_COMPILER_PYTHON
    let v612 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
    v612
#endif
    
#else
    let v613 : Async&lt;int32&gt; option = None
    let mutable _v613 = v613
    async {
    try
    let v614 : System.Threading.Tasks.Task = v558.WaitForExitAsync v601 
    let v615 : Async&lt;unit&gt; option = None
    let v616 : bool = true in let mutable _v615 = v615
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v617 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v617
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v618 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v618
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v619 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v619
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v620 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v620
#endif
    
#if FABLE_COMPILER_PYTHON
    let v621 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
    v621
#endif
    
#else
    let v622 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
    let v623 : Async&lt;unit&gt; = v622 v614
    v623
#endif
    |&gt; fun x -&gt; _v615 &lt;- Some x
    let v624 : Async&lt;unit&gt; = _v615.Value
    do! v624 
    let v625 : int32 = v558.ExitCode
    return v625 
    with ex -&gt;
    let v626 : exn = ex
    let v627 : string option = None
    let v628 : bool = true in let mutable _v627 = v627
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v629 : string = $"%A{v626}"
    v629
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v630 : string = $"%A{v626}"
    v630
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v631 : string = $"%A{v626}"
    v631
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v632 : string = $"%A{v626}"
    v632
#endif
    
#if FABLE_COMPILER_PYTHON
    let v633 : string = $"%A{v626}"
    v633
#endif
    
#else
    let v634 : string = $"{v626.GetType ()}: {v626.Message}"
    v634
#endif
    |&gt; fun x -&gt; _v627 &lt;- Some x
    let v635 : string = _v627.Value
    let v636 : (string -&gt; unit) = v560.Push
    v636 v635
    let v637 : System.Threading.Tasks.TaskCanceledException = v626 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
    let v638 : US0 = US0_3
    let v639 : (unit -&gt; string) = closure55(v637)
    let v640 : (unit -&gt; string) = method48()
    method3(v638, v639, v640)
    return -2147483648 
    (*
    *)
    }
    |&gt; fun x -&gt; _v613 &lt;- Some x
    let v641 : Async&lt;int32&gt; = _v613 |&gt; Option.get
    v641
#endif
    |&gt; fun x -&gt; _v606 &lt;- Some x
    let v642 : Async&lt;int32&gt; = _v606.Value
    let! v642 = v642 
    let v643 : int32 = v642 
    let v644 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
    let v645 : string seq = v644 v560
    let v646 : string = method72()
    let v647 : (string -&gt; (string seq -&gt; string)) = String.concat
    let v648 : (string seq -&gt; string) = v647 v646
    let v649 : string = v648 v645
    let v650 : US0 = US0_1
    let v651 : (unit -&gt; string) = closure56(v643, v649)
    let v652 : (unit -&gt; string) = method48()
    method3(v650, v651, v652)
    return struct (v643, v649) 
    }
    |&gt; fun x -&gt; _v518 &lt;- Some x
    let v653 : Async&lt;struct (int32 * string)&gt; = _v518 |&gt; Option.get
    v653
#endif
    |&gt; fun x -&gt; _v511 &lt;- Some x
    let v654 : Async&lt;struct (int32 * string)&gt; = _v511.Value
    v654
#endif
    |&gt; fun x -&gt; _v504 &lt;- Some x
    let v655 : Async&lt;struct (int32 * string)&gt; = _v504.Value
    let v656 : struct (int32 * string) option = None
    let v657 : bool = true in let mutable _v656 = v656
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let struct (v658 : int32, v659 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v658, v659)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let struct (v660 : int32, v661 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v660, v661)
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let struct (v662 : int32, v663 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v662, v663)
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let struct (v664 : int32, v665 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v664, v665)
#endif
    
#if FABLE_COMPILER_PYTHON
    let struct (v666 : int32, v667 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
    struct (v666, v667)
#endif
    
#else
    let v668 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
    let struct (v669 : int32, v670 : string) = v668 v655
    struct (v669, v670)
#endif
    |&gt; fun x -&gt; _v656 &lt;- Some x
    let struct (v671 : int32, v672 : string) = _v656.Value
    struct (v671, v672)
#endif
    |&gt; fun x -&gt; _v460 &lt;- Some x
    let struct (v673 : int32, v674 : string) = _v460.Value
    let v675 : string = method13(v4, v205)
    let v676 : string = method38(v675)
    let v677 : string = "hangul.md"
    let struct (v678 : string, v679 : string) = method73(v677, v452, v4)
    let v680 : bool = v450.Contains v674
    let v681 : bool = v680 = false
    let v1246 : UH2 =
        if v681 then
            let v682 : string option = None
            let v683 : bool = true in let mutable _v682 = v682
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v684 : string = method22()
            let v685 : string = method23(v452)
            let v686 : string = method24()
            let v687 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v688 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v684, v685, v686) v687
            let v689 : string = "String::from($0)"
            let v690 : std_string_String = Fable.Core.RustInterop.emitRustExpr v688 v689
            let v691 : string = "fable_library_rust::String_::fromString($0)"
            let v692 : string = Fable.Core.RustInterop.emitRustExpr v690 v691
            v692
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v693 : string = null |&gt; unbox&lt;string&gt;
            v693
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v694 : string = null |&gt; unbox&lt;string&gt;
            v694
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v695 : string = null |&gt; unbox&lt;string&gt;
            v695
#endif
            
#if FABLE_COMPILER_PYTHON
            let v696 : string = null |&gt; unbox&lt;string&gt;
            v696
#endif
            
#else
            let v697 : string = System.Text.RegularExpressions.Regex.Replace (v452, v221, v200)
            v697
#endif
            |&gt; fun x -&gt; _v682 &lt;- Some x
            let v698 : string = _v682.Value
            let v699 : string = $"{v698.[0] |&gt; string |&gt; _.ToLower()}{v698.[1..]}"
            let v700 : string = v699.Replace (v202, v203)
            let v701 : string option = None
            let v702 : System.Threading.CancellationToken option = None
            let v703 : (struct (string * string) []) = [||]
            let v704 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
            let v705 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
            let v706 : string = $"pwsh -c \"(Get-FileHash \\\"{v700}\\\" -Algorithm SHA256).Hash\""
            let v707 : struct (int32 * string) option = None
            let v708 : bool = true in let mutable _v707 = v707
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v709 : string = method39(v702, v706, v703, v704, v705, v701)
            let struct (v710 : string, v711 : string) = method40()
            let v712 : int32 = v709.Length
            let v713 : (char []) = Array.zeroCreate&lt;char&gt; (v712)
            let v714 : Mut5 = {l0 = 0} : Mut5
            while method26(v712, v714) do
                let v716 : int32 = v714.l0
                let v717 : char = v709.[int v716]
                v713.[int v716] &lt;- v717
                let v718 : int32 = v716 + 1
                v714.l0 &lt;- v718
                ()
            let v719 : ((char []) -&gt; char list) = Array.toList
            let v720 : char list = v719 v713
            let v721 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v722 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v723 : (char list -&gt; (UH0 -&gt; UH0)) = v721 v722
            let v724 : (UH0 -&gt; UH0) = v723 v720
            let v725 : UH0 = UH0_0
            let v726 : UH0 = v724 v725
            let v727 : US8 = US8_0
            let struct (v728 : string, v729 : string) = method42(v711, v710, v726, v727)
            let v730 : (string []) = method43(v729)
            let v731 : string = "$0.to_vec()"
            let v732 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v730 v731
            let v733 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
            let v734 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v732, v262) v733
            let v735 : US0 = US0_1
            let v736 : (unit -&gt; string) = closure29(v702, v706, v703, v704, v705, v701, v728, v734)
            let v737 : (unit -&gt; string) = method48()
            method3(v735, v736, v737)
            let v738 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v702, v706, v703, v704, v705, v701, v728, v734)
            let v739 : string = "futures_lite::future::block_on($0)"
            let v740 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v738 v739
            let (a, b) = v740
            let v741 : int32 = a
            let v742 : string = b
            struct (v741, v742)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v743 : int32, v744 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v743, v744)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v745 : int32, v746 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v745, v746)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v747 : int32, v748 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v747, v748)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v749 : int32, v750 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v749, v750)
#endif
            
#else
            let v751 : Async&lt;struct (int32 * string)&gt; option = None
            let v752 : bool = true in let mutable _v751 = v751
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v753 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v753
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v754 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v754
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v755 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v755
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v756 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v756
#endif
            
#if FABLE_COMPILER_PYTHON
            let v757 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v757
#endif
            
#else
            let v758 : Async&lt;struct (int32 * string)&gt; option = None
            let v759 : bool = true in let mutable _v758 = v758
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v760 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v760
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v761 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v761
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v762 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v762
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v763 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v763
#endif
            
#if FABLE_COMPILER_PYTHON
            let v764 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
            v764
#endif
            
#else
            let v765 : Async&lt;struct (int32 * string)&gt; option = None
            let mutable _v765 = v765
            async {
            let struct (v766 : string, v767 : string) = method40()
            let v768 : int32 = v706.Length
            let v769 : (char []) = Array.zeroCreate&lt;char&gt; (v768)
            let v770 : Mut5 = {l0 = 0} : Mut5
            while method26(v768, v770) do
                let v772 : int32 = v770.l0
                let v773 : char = v706.[int v772]
                v769.[int v772] &lt;- v773
                let v774 : int32 = v772 + 1
                v770.l0 &lt;- v774
                ()
            let v775 : ((char []) -&gt; char list) = Array.toList
            let v776 : char list = v775 v769
            let v777 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
            let v778 : (char -&gt; (UH0 -&gt; UH0)) = method41()
            let v779 : (char list -&gt; (UH0 -&gt; UH0)) = v777 v778
            let v780 : (UH0 -&gt; UH0) = v779 v776
            let v781 : UH0 = UH0_0
            let v782 : UH0 = v780 v781
            let v783 : US8 = US8_0
            let struct (v784 : string, v785 : string) = method42(v767, v766, v782, v783)
            let v786 : (string -&gt; US4) = method19()
            let v787 : US4 = US4_1
            let v788 : US4 = v701 |&gt; Option.map v786 |&gt; Option.defaultValue v787 
            let v791 : string =
                match v788 with
                | US4_1 -&gt; (* None *)
                    v200
                | US4_0(v789) -&gt; (* Some *)
                    v789
            let v792 : US0 = US0_1
            let v793 : (unit -&gt; string) = closure48(v702, v706, v703, v704, v705, v701)
            let v794 : (unit -&gt; string) = method48()
            method3(v792, v793, v794)
            let v795 : System.Text.Encoding = System.Text.Encoding.UTF8
            let v796 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v785, StandardOutputEncoding = v795, WorkingDirectory = v791, FileName = v784, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
            let v797 : int32 = v703.Length
            let v798 : Mut5 = {l0 = 0} : Mut5
            while method26(v797, v798) do
                let v800 : int32 = v798.l0
                let struct (v801 : string, v802 : string) = v703.[int v800]
                v796.EnvironmentVariables.[v801] &lt;- v802 
                let v803 : int32 = v800 + 1
                v798.l0 &lt;- v803
                ()
            let v804 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v796)
            use v804 = v804 
            let v805 : System.Diagnostics.Process = v804 
            let v806 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
            let v807 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v806 ()
            let v808 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v702, v706, v703, v704, v705, v701, v805, v807)
            v805.OutputDataReceived.Add v808 
            let v809 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v702, v706, v703, v704, v705, v701, v805, v807)
            v805.ErrorDataReceived.Add v809 
            let v810 : (unit -&gt; bool) = v805.Start
            let v811 : bool = v810 ()
            let v812 : bool = v811 = false
            if v812 then
                let v813 : string = $"execute_with_options_async / process_start error"
                failwith&lt;unit&gt; v813
            let v814 : (unit -&gt; unit) = v805.BeginErrorReadLine
            v814 ()
            let v815 : (unit -&gt; unit) = v805.BeginOutputReadLine
            v815 ()
            let v816 : (System.Threading.CancellationToken -&gt; US18) = method71()
            let v817 : US18 = US18_1
            let v818 : US18 = v702 |&gt; Option.map v816 |&gt; Option.defaultValue v817 
            let v822 : System.Threading.CancellationToken =
                match v818 with
                | US18_1 -&gt; (* None *)
                    let v820 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                    v820
                | US18_0(v819) -&gt; (* Some *)
                    v819
            let v823 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v824 : bool = true in let mutable _v823 = v823
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v825 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v825
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v826 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v826
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v827 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v827
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v828 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v828
#endif
            
#if FABLE_COMPILER_PYTHON
            let v829 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v829
#endif
            
#else
            let v830 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let v831 : bool = true in let mutable _v830 = v830
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v832 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v832
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v833 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v833
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v834 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v834
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v835 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v835
#endif
            
#if FABLE_COMPILER_PYTHON
            let v836 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
            v836
#endif
            
#else
            let v837 : Async&lt;System.Threading.CancellationToken&gt; option = None
            let mutable _v837 = v837
            async {
            let v838 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
            let! v838 = v838 
            let v839 : System.Threading.CancellationToken = v838 
            let v840 : System.Threading.CancellationToken = Async.DefaultCancellationToken
            let v841 : (System.Threading.CancellationToken []) = [|v839; v840; v822|]
            let v842 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
            let v843 : System.Threading.CancellationTokenSource = v842 v841
            let v844 : System.Threading.CancellationToken = v843.Token
            return v844 
            }
            |&gt; fun x -&gt; _v837 &lt;- Some x
            let v845 : Async&lt;System.Threading.CancellationToken&gt; = _v837 |&gt; Option.get
            v845
#endif
            |&gt; fun x -&gt; _v830 &lt;- Some x
            let v846 : Async&lt;System.Threading.CancellationToken&gt; = _v830.Value
            v846
#endif
            |&gt; fun x -&gt; _v823 &lt;- Some x
            let v847 : Async&lt;System.Threading.CancellationToken&gt; = _v823.Value
            let! v847 = v847 
            let v848 : System.Threading.CancellationToken = v847 
            let v849 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v848.Register
            let v850 : (unit -&gt; unit) = closure54(v805)
            let v851 : System.Threading.CancellationTokenRegistration = v849 v850
            use v851 = v851 
            let v852 : System.Threading.CancellationTokenRegistration = v851 
            let v853 : Async&lt;int32&gt; option = None
            let v854 : bool = true in let mutable _v853 = v853
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v855 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v855
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v856 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v856
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v857 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v857
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v858 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v858
#endif
            
#if FABLE_COMPILER_PYTHON
            let v859 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
            v859
#endif
            
#else
            let v860 : Async&lt;int32&gt; option = None
            let mutable _v860 = v860
            async {
            try
            let v861 : System.Threading.Tasks.Task = v805.WaitForExitAsync v848 
            let v862 : Async&lt;unit&gt; option = None
            let v863 : bool = true in let mutable _v862 = v862
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v864 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v864
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v865 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v865
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v866 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v866
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v867 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v867
#endif
            
#if FABLE_COMPILER_PYTHON
            let v868 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
            v868
#endif
            
#else
            let v869 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
            let v870 : Async&lt;unit&gt; = v869 v861
            v870
#endif
            |&gt; fun x -&gt; _v862 &lt;- Some x
            let v871 : Async&lt;unit&gt; = _v862.Value
            do! v871 
            let v872 : int32 = v805.ExitCode
            return v872 
            with ex -&gt;
            let v873 : exn = ex
            let v874 : string option = None
            let v875 : bool = true in let mutable _v874 = v874
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v876 : string = $"%A{v873}"
            v876
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v877 : string = $"%A{v873}"
            v877
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v878 : string = $"%A{v873}"
            v878
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v879 : string = $"%A{v873}"
            v879
#endif
            
#if FABLE_COMPILER_PYTHON
            let v880 : string = $"%A{v873}"
            v880
#endif
            
#else
            let v881 : string = $"{v873.GetType ()}: {v873.Message}"
            v881
#endif
            |&gt; fun x -&gt; _v874 &lt;- Some x
            let v882 : string = _v874.Value
            let v883 : (string -&gt; unit) = v807.Push
            v883 v882
            let v884 : System.Threading.Tasks.TaskCanceledException = v873 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
            let v885 : US0 = US0_3
            let v886 : (unit -&gt; string) = closure55(v884)
            let v887 : (unit -&gt; string) = method48()
            method3(v885, v886, v887)
            return -2147483648 
            (*
            *)
            }
            |&gt; fun x -&gt; _v860 &lt;- Some x
            let v888 : Async&lt;int32&gt; = _v860 |&gt; Option.get
            v888
#endif
            |&gt; fun x -&gt; _v853 &lt;- Some x
            let v889 : Async&lt;int32&gt; = _v853.Value
            let! v889 = v889 
            let v890 : int32 = v889 
            let v891 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
            let v892 : string seq = v891 v807
            let v893 : string = method72()
            let v894 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v895 : (string seq -&gt; string) = v894 v893
            let v896 : string = v895 v892
            let v897 : US0 = US0_1
            let v898 : (unit -&gt; string) = closure56(v890, v896)
            let v899 : (unit -&gt; string) = method48()
            method3(v897, v898, v899)
            return struct (v890, v896) 
            }
            |&gt; fun x -&gt; _v765 &lt;- Some x
            let v900 : Async&lt;struct (int32 * string)&gt; = _v765 |&gt; Option.get
            v900
#endif
            |&gt; fun x -&gt; _v758 &lt;- Some x
            let v901 : Async&lt;struct (int32 * string)&gt; = _v758.Value
            v901
#endif
            |&gt; fun x -&gt; _v751 &lt;- Some x
            let v902 : Async&lt;struct (int32 * string)&gt; = _v751.Value
            let v903 : struct (int32 * string) option = None
            let v904 : bool = true in let mutable _v903 = v903
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let struct (v905 : int32, v906 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v905, v906)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let struct (v907 : int32, v908 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v907, v908)
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let struct (v909 : int32, v910 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v909, v910)
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let struct (v911 : int32, v912 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v911, v912)
#endif
            
#if FABLE_COMPILER_PYTHON
            let struct (v913 : int32, v914 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
            struct (v913, v914)
#endif
            
#else
            let v915 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
            let struct (v916 : int32, v917 : string) = v915 v902
            struct (v916, v917)
#endif
            |&gt; fun x -&gt; _v903 &lt;- Some x
            let struct (v918 : int32, v919 : string) = _v903.Value
            struct (v918, v919)
#endif
            |&gt; fun x -&gt; _v707 &lt;- Some x
            let struct (v920 : int32, v921 : string) = _v707.Value
            let v922 : bool = v920 = 0
            let v925 : US20 =
                if v922 then
                    US20_0(v921)
                else
                    US20_1(v921)
            let v931 : string =
                match v925 with
                | US20_1(v927) -&gt; (* Error *)
                    let v928 : string = $"resultm.get / Result value was Error: {v927}"
                    failwith&lt;string&gt; v928
                | US20_0(v926) -&gt; (* Ok *)
                    v926
            let v932 : bool option = None
            let v933 : bool = true in let mutable _v932 = v932
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v934 : string = method14(v676)
            let v935 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v936 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v934 v935
            let v937 : string = "String::from($0)"
            let v938 : std_string_String = Fable.Core.RustInterop.emitRustExpr v936 v937
            let v939 : string = "std::path::PathBuf::from($0)"
            let v940 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v938 v939
            let v941 : string = "$0.exists()"
            let v942 : bool = Fable.Core.RustInterop.emitRustExpr v940 v941
            let v945 : bool =
                if v942 then
                    let v943 : string = "$0.is_file()"
                    let v944 : bool = Fable.Core.RustInterop.emitRustExpr v940 v943
                    v944
                else
                    false
            v945
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v946 : bool = null |&gt; unbox&lt;bool&gt;
            v946
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v947 : bool = null |&gt; unbox&lt;bool&gt;
            v947
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v948 : string = "fs"
            let v949 : IFsExistsSync = Fable.Core.JsInterop.importAll v948
            let v950 : string = "$0.existsSync($1)"
            let v951 : bool = Fable.Core.JsInterop.emitJsExpr struct (v949, v676) v950
            v951
#endif
            
#if FABLE_COMPILER_PYTHON
            let v952 : bool = null |&gt; unbox&lt;bool&gt;
            v952
#endif
            
#else
            let v953 : (string -&gt; bool) = System.IO.File.Exists
            let v954 : bool = v953 v676
            v954
#endif
            |&gt; fun x -&gt; _v932 &lt;- Some x
            let v955 : bool = _v932.Value
            let v1207 : US4 =
                if v955 then
                    let v956 : string option = None
                    let v957 : bool = true in let mutable _v956 = v956
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v958 : string = method22()
                    let v959 : string = method23(v676)
                    let v960 : string = method24()
                    let v961 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
                    let v962 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v958, v959, v960) v961
                    let v963 : string = "String::from($0)"
                    let v964 : std_string_String = Fable.Core.RustInterop.emitRustExpr v962 v963
                    let v965 : string = "fable_library_rust::String_::fromString($0)"
                    let v966 : string = Fable.Core.RustInterop.emitRustExpr v964 v965
                    v966
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v967 : string = null |&gt; unbox&lt;string&gt;
                    v967
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v968 : string = null |&gt; unbox&lt;string&gt;
                    v968
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v969 : string = null |&gt; unbox&lt;string&gt;
                    v969
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v970 : string = null |&gt; unbox&lt;string&gt;
                    v970
#endif
                    
#else
                    let v971 : string = System.Text.RegularExpressions.Regex.Replace (v676, v221, v200)
                    v971
#endif
                    |&gt; fun x -&gt; _v956 &lt;- Some x
                    let v972 : string = _v956.Value
                    let v973 : string = $"{v972.[0] |&gt; string |&gt; _.ToLower()}{v972.[1..]}"
                    let v974 : string = v973.Replace (v202, v203)
                    let v975 : string option = None
                    let v976 : System.Threading.CancellationToken option = None
                    let v977 : (struct (string * string) []) = [||]
                    let v978 : (struct (bool * string * int32) -&gt; Async&lt;unit&gt;) option = None
                    let v979 : (std_sync_Arc&lt;std_sync_Mutex&lt;std_process_ChildStdin&gt;&gt; -&gt; unit) option = None
                    let v980 : string = $"pwsh -c \"(Get-FileHash \\\"{v974}\\\" -Algorithm SHA256).Hash\""
                    let v981 : struct (int32 * string) option = None
                    let v982 : bool = true in let mutable _v981 = v981
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v983 : string = method39(v976, v980, v977, v978, v979, v975)
                    let struct (v984 : string, v985 : string) = method40()
                    let v986 : int32 = v983.Length
                    let v987 : (char []) = Array.zeroCreate&lt;char&gt; (v986)
                    let v988 : Mut5 = {l0 = 0} : Mut5
                    while method26(v986, v988) do
                        let v990 : int32 = v988.l0
                        let v991 : char = v983.[int v990]
                        v987.[int v990] &lt;- v991
                        let v992 : int32 = v990 + 1
                        v988.l0 &lt;- v992
                        ()
                    let v993 : ((char []) -&gt; char list) = Array.toList
                    let v994 : char list = v993 v987
                    let v995 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
                    let v996 : (char -&gt; (UH0 -&gt; UH0)) = method41()
                    let v997 : (char list -&gt; (UH0 -&gt; UH0)) = v995 v996
                    let v998 : (UH0 -&gt; UH0) = v997 v994
                    let v999 : UH0 = UH0_0
                    let v1000 : UH0 = v998 v999
                    let v1001 : US8 = US8_0
                    let struct (v1002 : string, v1003 : string) = method42(v985, v984, v1000, v1001)
                    let v1004 : (string []) = method43(v1003)
                    let v1005 : string = "$0.to_vec()"
                    let v1006 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr v1004 v1005
                    let v1007 : string = "$0.iter().map(|x| $1(x.clone())).collect()"
                    let v1008 : Vec&lt;std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr struct (v1006, v262) v1007
                    let v1009 : US0 = US0_1
                    let v1010 : (unit -&gt; string) = closure29(v976, v980, v977, v978, v979, v975, v1002, v1008)
                    let v1011 : (unit -&gt; string) = method48()
                    method3(v1009, v1010, v1011)
                    let v1012 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;(int32 * string)&gt;&gt;&gt;&gt; = method49(v976, v980, v977, v978, v979, v975, v1002, v1008)
                    let v1013 : string = "futures_lite::future::block_on($0)"
                    let v1014 : (int32 * string) = Fable.Core.RustInterop.emitRustExpr v1012 v1013
                    let (a, b) = v1014
                    let v1015 : int32 = a
                    let v1016 : string = b
                    struct (v1015, v1016)
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let struct (v1017 : int32, v1018 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1017, v1018)
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let struct (v1019 : int32, v1020 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1019, v1020)
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let struct (v1021 : int32, v1022 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1021, v1022)
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let struct (v1023 : int32, v1024 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1023, v1024)
#endif
                    
#else
                    let v1025 : Async&lt;struct (int32 * string)&gt; option = None
                    let v1026 : bool = true in let mutable _v1025 = v1025
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1027 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1027
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1028 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1028
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1029 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1029
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1030 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1030
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1031 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1031
#endif
                    
#else
                    let v1032 : Async&lt;struct (int32 * string)&gt; option = None
                    let v1033 : bool = true in let mutable _v1032 = v1032
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1034 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1034
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1035 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1035
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1036 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1036
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1037 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1037
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1038 : Async&lt;struct (int32 * string)&gt; = null |&gt; unbox&lt;Async&lt;struct (int32 * string)&gt;&gt;
                    v1038
#endif
                    
#else
                    let v1039 : Async&lt;struct (int32 * string)&gt; option = None
                    let mutable _v1039 = v1039
                    async {
                    let struct (v1040 : string, v1041 : string) = method40()
                    let v1042 : int32 = v980.Length
                    let v1043 : (char []) = Array.zeroCreate&lt;char&gt; (v1042)
                    let v1044 : Mut5 = {l0 = 0} : Mut5
                    while method26(v1042, v1044) do
                        let v1046 : int32 = v1044.l0
                        let v1047 : char = v980.[int v1046]
                        v1043.[int v1046] &lt;- v1047
                        let v1048 : int32 = v1046 + 1
                        v1044.l0 &lt;- v1048
                        ()
                    let v1049 : ((char []) -&gt; char list) = Array.toList
                    let v1050 : char list = v1049 v1043
                    let v1051 : ((char -&gt; (UH0 -&gt; UH0)) -&gt; (char list -&gt; (UH0 -&gt; UH0))) = List.foldBack
                    let v1052 : (char -&gt; (UH0 -&gt; UH0)) = method41()
                    let v1053 : (char list -&gt; (UH0 -&gt; UH0)) = v1051 v1052
                    let v1054 : (UH0 -&gt; UH0) = v1053 v1050
                    let v1055 : UH0 = UH0_0
                    let v1056 : UH0 = v1054 v1055
                    let v1057 : US8 = US8_0
                    let struct (v1058 : string, v1059 : string) = method42(v1041, v1040, v1056, v1057)
                    let v1060 : (string -&gt; US4) = method19()
                    let v1061 : US4 = US4_1
                    let v1062 : US4 = v975 |&gt; Option.map v1060 |&gt; Option.defaultValue v1061 
                    let v1065 : string =
                        match v1062 with
                        | US4_1 -&gt; (* None *)
                            v200
                        | US4_0(v1063) -&gt; (* Some *)
                            v1063
                    let v1066 : US0 = US0_1
                    let v1067 : (unit -&gt; string) = closure48(v976, v980, v977, v978, v979, v975)
                    let v1068 : (unit -&gt; string) = method48()
                    method3(v1066, v1067, v1068)
                    let v1069 : System.Text.Encoding = System.Text.Encoding.UTF8
                    let v1070 : System.Diagnostics.ProcessStartInfo = System.Diagnostics.ProcessStartInfo (Arguments = v1059, StandardOutputEncoding = v1069, WorkingDirectory = v1065, FileName = v1058, CreateNoWindow = true, RedirectStandardError = true, RedirectStandardOutput = true, UseShellExecute = false)
                    let v1071 : int32 = v977.Length
                    let v1072 : Mut5 = {l0 = 0} : Mut5
                    while method26(v1071, v1072) do
                        let v1074 : int32 = v1072.l0
                        let struct (v1075 : string, v1076 : string) = v977.[int v1074]
                        v1070.EnvironmentVariables.[v1075] &lt;- v1076 
                        let v1077 : int32 = v1074 + 1
                        v1072.l0 &lt;- v1077
                        ()
                    let v1078 : System.Diagnostics.Process = new System.Diagnostics.Process (StartInfo = v1070)
                    use v1078 = v1078 
                    let v1079 : System.Diagnostics.Process = v1078 
                    let v1080 : (unit -&gt; System.Collections.Concurrent.ConcurrentStack&lt;string&gt;) = System.Collections.Concurrent.ConcurrentStack&lt;string&gt;
                    let v1081 : System.Collections.Concurrent.ConcurrentStack&lt;string&gt; = v1080 ()
                    let v1082 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure49(v976, v980, v977, v978, v979, v975, v1079, v1081)
                    v1079.OutputDataReceived.Add v1082 
                    let v1083 : (System.Diagnostics.DataReceivedEventArgs -&gt; unit) = closure52(v976, v980, v977, v978, v979, v975, v1079, v1081)
                    v1079.ErrorDataReceived.Add v1083 
                    let v1084 : (unit -&gt; bool) = v1079.Start
                    let v1085 : bool = v1084 ()
                    let v1086 : bool = v1085 = false
                    if v1086 then
                        let v1087 : string = $"execute_with_options_async / process_start error"
                        failwith&lt;unit&gt; v1087
                    let v1088 : (unit -&gt; unit) = v1079.BeginErrorReadLine
                    v1088 ()
                    let v1089 : (unit -&gt; unit) = v1079.BeginOutputReadLine
                    v1089 ()
                    let v1090 : (System.Threading.CancellationToken -&gt; US18) = method71()
                    let v1091 : US18 = US18_1
                    let v1092 : US18 = v976 |&gt; Option.map v1090 |&gt; Option.defaultValue v1091 
                    let v1096 : System.Threading.CancellationToken =
                        match v1092 with
                        | US18_1 -&gt; (* None *)
                            let v1094 : System.Threading.CancellationToken = System.Threading.CancellationToken.None
                            v1094
                        | US18_0(v1093) -&gt; (* Some *)
                            v1093
                    let v1097 : Async&lt;System.Threading.CancellationToken&gt; option = None
                    let v1098 : bool = true in let mutable _v1097 = v1097
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1099 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1099
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1100 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1100
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1101 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1101
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1102 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1102
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1103 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1103
#endif
                    
#else
                    let v1104 : Async&lt;System.Threading.CancellationToken&gt; option = None
                    let v1105 : bool = true in let mutable _v1104 = v1104
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1106 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1106
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1107 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1107
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1108 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1108
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1109 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1109
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1110 : Async&lt;System.Threading.CancellationToken&gt; = null |&gt; unbox&lt;Async&lt;System.Threading.CancellationToken&gt;&gt;
                    v1110
#endif
                    
#else
                    let v1111 : Async&lt;System.Threading.CancellationToken&gt; option = None
                    let mutable _v1111 = v1111
                    async {
                    let v1112 : Async&lt;System.Threading.CancellationToken&gt; = Async.CancellationToken
                    let! v1112 = v1112 
                    let v1113 : System.Threading.CancellationToken = v1112 
                    let v1114 : System.Threading.CancellationToken = Async.DefaultCancellationToken
                    let v1115 : (System.Threading.CancellationToken []) = [|v1113; v1114; v1096|]
                    let v1116 : ((System.Threading.CancellationToken []) -&gt; System.Threading.CancellationTokenSource) = System.Threading.CancellationTokenSource.CreateLinkedTokenSource
                    let v1117 : System.Threading.CancellationTokenSource = v1116 v1115
                    let v1118 : System.Threading.CancellationToken = v1117.Token
                    return v1118 
                    }
                    |&gt; fun x -&gt; _v1111 &lt;- Some x
                    let v1119 : Async&lt;System.Threading.CancellationToken&gt; = _v1111 |&gt; Option.get
                    v1119
#endif
                    |&gt; fun x -&gt; _v1104 &lt;- Some x
                    let v1120 : Async&lt;System.Threading.CancellationToken&gt; = _v1104.Value
                    v1120
#endif
                    |&gt; fun x -&gt; _v1097 &lt;- Some x
                    let v1121 : Async&lt;System.Threading.CancellationToken&gt; = _v1097.Value
                    let! v1121 = v1121 
                    let v1122 : System.Threading.CancellationToken = v1121 
                    let v1123 : ((unit -&gt; unit) -&gt; System.Threading.CancellationTokenRegistration) = v1122.Register
                    let v1124 : (unit -&gt; unit) = closure54(v1079)
                    let v1125 : System.Threading.CancellationTokenRegistration = v1123 v1124
                    use v1125 = v1125 
                    let v1126 : System.Threading.CancellationTokenRegistration = v1125 
                    let v1127 : Async&lt;int32&gt; option = None
                    let v1128 : bool = true in let mutable _v1127 = v1127
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1129 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
                    v1129
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1130 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
                    v1130
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1131 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
                    v1131
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1132 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
                    v1132
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1133 : Async&lt;int32&gt; = null |&gt; unbox&lt;Async&lt;int32&gt;&gt;
                    v1133
#endif
                    
#else
                    let v1134 : Async&lt;int32&gt; option = None
                    let mutable _v1134 = v1134
                    async {
                    try
                    let v1135 : System.Threading.Tasks.Task = v1079.WaitForExitAsync v1122 
                    let v1136 : Async&lt;unit&gt; option = None
                    let v1137 : bool = true in let mutable _v1136 = v1136
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1138 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
                    v1138
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1139 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
                    v1139
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1140 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
                    v1140
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1141 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
                    v1141
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1142 : Async&lt;unit&gt; = null |&gt; unbox&lt;Async&lt;unit&gt;&gt;
                    v1142
#endif
                    
#else
                    let v1143 : (System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;) = Async.AwaitTask
                    let v1144 : Async&lt;unit&gt; = v1143 v1135
                    v1144
#endif
                    |&gt; fun x -&gt; _v1136 &lt;- Some x
                    let v1145 : Async&lt;unit&gt; = _v1136.Value
                    do! v1145 
                    let v1146 : int32 = v1079.ExitCode
                    return v1146 
                    with ex -&gt;
                    let v1147 : exn = ex
                    let v1148 : string option = None
                    let v1149 : bool = true in let mutable _v1148 = v1148
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1150 : string = $"%A{v1147}"
                    v1150
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1151 : string = $"%A{v1147}"
                    v1151
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1152 : string = $"%A{v1147}"
                    v1152
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1153 : string = $"%A{v1147}"
                    v1153
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1154 : string = $"%A{v1147}"
                    v1154
#endif
                    
#else
                    let v1155 : string = $"{v1147.GetType ()}: {v1147.Message}"
                    v1155
#endif
                    |&gt; fun x -&gt; _v1148 &lt;- Some x
                    let v1156 : string = _v1148.Value
                    let v1157 : (string -&gt; unit) = v1081.Push
                    v1157 v1156
                    let v1158 : System.Threading.Tasks.TaskCanceledException = v1147 |&gt; unbox&lt;System.Threading.Tasks.TaskCanceledException&gt;
                    let v1159 : US0 = US0_3
                    let v1160 : (unit -&gt; string) = closure55(v1158)
                    let v1161 : (unit -&gt; string) = method48()
                    method3(v1159, v1160, v1161)
                    return -2147483648 
                    (*
                    *)
                    }
                    |&gt; fun x -&gt; _v1134 &lt;- Some x
                    let v1162 : Async&lt;int32&gt; = _v1134 |&gt; Option.get
                    v1162
#endif
                    |&gt; fun x -&gt; _v1127 &lt;- Some x
                    let v1163 : Async&lt;int32&gt; = _v1127.Value
                    let! v1163 = v1163 
                    let v1164 : int32 = v1163 
                    let v1165 : (System.Collections.Concurrent.ConcurrentStack&lt;string&gt; -&gt; string seq) = Seq.rev
                    let v1166 : string seq = v1165 v1081
                    let v1167 : string = method72()
                    let v1168 : (string -&gt; (string seq -&gt; string)) = String.concat
                    let v1169 : (string seq -&gt; string) = v1168 v1167
                    let v1170 : string = v1169 v1166
                    let v1171 : US0 = US0_1
                    let v1172 : (unit -&gt; string) = closure56(v1164, v1170)
                    let v1173 : (unit -&gt; string) = method48()
                    method3(v1171, v1172, v1173)
                    return struct (v1164, v1170) 
                    }
                    |&gt; fun x -&gt; _v1039 &lt;- Some x
                    let v1174 : Async&lt;struct (int32 * string)&gt; = _v1039 |&gt; Option.get
                    v1174
#endif
                    |&gt; fun x -&gt; _v1032 &lt;- Some x
                    let v1175 : Async&lt;struct (int32 * string)&gt; = _v1032.Value
                    v1175
#endif
                    |&gt; fun x -&gt; _v1025 &lt;- Some x
                    let v1176 : Async&lt;struct (int32 * string)&gt; = _v1025.Value
                    let v1177 : struct (int32 * string) option = None
                    let v1178 : bool = true in let mutable _v1177 = v1177
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let struct (v1179 : int32, v1180 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1179, v1180)
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let struct (v1181 : int32, v1182 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1181, v1182)
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let struct (v1183 : int32, v1184 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1183, v1184)
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let struct (v1185 : int32, v1186 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1185, v1186)
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let struct (v1187 : int32, v1188 : string) = null |&gt; unbox&lt;struct (int32 * string)&gt;
                    struct (v1187, v1188)
#endif
                    
#else
                    let v1189 : (Async&lt;struct (int32 * string)&gt; -&gt; struct (int32 * string)) = Async.RunSynchronously
                    let struct (v1190 : int32, v1191 : string) = v1189 v1176
                    struct (v1190, v1191)
#endif
                    |&gt; fun x -&gt; _v1177 &lt;- Some x
                    let struct (v1192 : int32, v1193 : string) = _v1177.Value
                    struct (v1192, v1193)
#endif
                    |&gt; fun x -&gt; _v981 &lt;- Some x
                    let struct (v1194 : int32, v1195 : string) = _v981.Value
                    let v1196 : bool = v1194 = 0
                    let v1199 : US20 =
                        if v1196 then
                            US20_0(v1195)
                        else
                            US20_1(v1195)
                    match v1199 with
                    | US20_1(v1202) -&gt; (* Error *)
                        US4_1
                    | US20_0(v1200) -&gt; (* Ok *)
                        US4_0(v1200)
                else
                    US4_1
            let v1209 : bool =
                match v1207 with
                | US4_1 -&gt; (* None *)
                    true
                | _ -&gt;
                    false
            let v1215 : bool =
                if v1209 then
                    true
                else
                    let v1213 : string =
                        match v1207 with
                        | US4_1 -&gt; (* None *)
                            failwith&lt;string&gt; "Option does not have a value."
                        | US4_0(v1210) -&gt; (* Some *)
                            v1210
                    let v1214 : bool = v931 &lt;&gt; v1213
                    v1214
            if v1215 then
                let v1216 : US0 = US0_2
                let v1217 : (unit -&gt; string) = closure57()
                let v1218 : (unit -&gt; string) = closure58(v205, v225, v227, v450, v449, v452, v674, v673, v676, v931, v1207)
                method3(v1216, v1217, v1218)
                let v1219 : unit option = None
                let v1220 : bool = true in let mutable _v1219 = v1219
                
#if FABLE_COMPILER || WASM || CONTRACT
                
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                let v1221 : string = method74(v676)
                let v1222 : string = "std::fs::copy(&amp;*$0, &amp;*v1221)"
                let v1223 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v452 v1222
                let v1224 : string = "$0.unwrap()"
                let v1225 : uint64 = Fable.Core.RustInterop.emitRustExpr v1223 v1224
                ()
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                null |&gt; unbox&lt;unit&gt;
                ()
#endif
                
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                null |&gt; unbox&lt;unit&gt;
                ()
#endif
                
#if FABLE_COMPILER_TYPESCRIPT
                null |&gt; unbox&lt;unit&gt;
                ()
#endif
                
#if FABLE_COMPILER_PYTHON
                null |&gt; unbox&lt;unit&gt;
                ()
#endif
                
#else
                System.IO.File.Copy (v452, v676, true)
                ()
#endif
                |&gt; fun x -&gt; _v1219 &lt;- Some x
                _v1219.Value
                let v1226 : (string -&gt; (string -&gt; US19)) = closure59(v4, v3, v1, v0)
                let v1227 : UH3 = UH3_0
                let v1228 : UH3 = UH3_1(v677, v452, v1226, v1227)
                let v1229 : string = "html"
                let v1230 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                let v1231 : string = "pdf"
                let v1232 : string = "epub"
                let v1233 : UH3 = UH3_0
                let v1234 : UH3 = UH3_1(v1232, v679, v1230, v1233)
                let v1235 : UH3 = UH3_1(v1231, v679, v1230, v1234)
                let v1236 : UH3 = UH3_1(v1229, v679, v1230, v1235)
                let v1237 : UH3 = UH3_1(v1232, v452, v1230, v1236)
                let v1238 : UH3 = UH3_1(v1231, v452, v1230, v1237)
                let v1239 : UH3 = UH3_1(v1229, v452, v1230, v1238)
                let v1240 : UH2 = UH2_0
                let v1241 : UH2 = UH2_1(v1239, v1240)
                UH2_1(v1228, v1241)
            else
                UH2_0
        else
            UH2_0
    let v1248 : bool =
        match v1246 with
        | UH2_0 -&gt; (* Nil *)
            true
        | _ -&gt;
            false
    let v1249 : bool = v1248 &lt;&gt; true
    let v1709 : UH2 =
        if v1249 then
            v1246
        else
            let v1250 : string = "epub"
            let struct (v1251 : string, v1252 : string) = method73(v1250, v679, v4)
            let v1253 : bool option = None
            let v1254 : bool = true in let mutable _v1253 = v1253
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1255 : string = method14(v1252)
            let v1256 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1257 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1255 v1256
            let v1258 : string = "String::from($0)"
            let v1259 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1257 v1258
            let v1260 : string = "std::path::PathBuf::from($0)"
            let v1261 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1259 v1260
            let v1262 : string = "$0.exists()"
            let v1263 : bool = Fable.Core.RustInterop.emitRustExpr v1261 v1262
            let v1266 : bool =
                if v1263 then
                    let v1264 : string = "$0.is_file()"
                    let v1265 : bool = Fable.Core.RustInterop.emitRustExpr v1261 v1264
                    v1265
                else
                    false
            v1266
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1267 : bool = null |&gt; unbox&lt;bool&gt;
            v1267
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1268 : bool = null |&gt; unbox&lt;bool&gt;
            v1268
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1269 : string = "fs"
            let v1270 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1271 : string = "$0.existsSync($1)"
            let v1272 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1270, v1252) v1271
            v1272
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1273 : bool = null |&gt; unbox&lt;bool&gt;
            v1273
#endif
            
#else
            let v1274 : (string -&gt; bool) = System.IO.File.Exists
            let v1275 : bool = v1274 v1252
            v1275
#endif
            |&gt; fun x -&gt; _v1253 &lt;- Some x
            let v1276 : bool = _v1253.Value
            let v1277 : bool = v1276 = false
            let v1312 : bool =
                if v1277 then
                    let v1278 : bool option = None
                    let v1279 : bool = true in let mutable _v1278 = v1278
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1280 : string = method14(v1251)
                    let v1281 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1282 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1280 v1281
                    let v1283 : string = "String::from($0)"
                    let v1284 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1282 v1283
                    let v1285 : string = "std::path::PathBuf::from($0)"
                    let v1286 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1284 v1285
                    let v1287 : string = "$0.exists()"
                    let v1288 : bool = Fable.Core.RustInterop.emitRustExpr v1286 v1287
                    let v1291 : bool =
                        if v1288 then
                            let v1289 : string = "$0.is_file()"
                            let v1290 : bool = Fable.Core.RustInterop.emitRustExpr v1286 v1289
                            v1290
                        else
                            false
                    v1291
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1292 : bool = null |&gt; unbox&lt;bool&gt;
                    v1292
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1293 : bool = null |&gt; unbox&lt;bool&gt;
                    v1293
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1294 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1295 : string = "$0.existsSync($1)"
                    let v1296 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1294, v1251) v1295
                    v1296
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1297 : bool = null |&gt; unbox&lt;bool&gt;
                    v1297
#endif
                    
#else
                    let v1298 : (string -&gt; bool) = System.IO.File.Exists
                    let v1299 : bool = v1298 v1251
                    v1299
#endif
                    |&gt; fun x -&gt; _v1278 &lt;- Some x
                    let v1300 : bool = _v1278.Value
                    if v1300 then
                        let v1301 : US0 = US0_2
                        let v1302 : (unit -&gt; string) = closure70()
                        let v1303 : (unit -&gt; string) = closure71(v1251, v1252)
                        method3(v1301, v1302, v1303)
                        let v1304 : unit option = None
                        let v1305 : bool = true in let mutable _v1304 = v1304
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1306 : string = method74(v1252)
                        let v1307 : string = "std::fs::copy(&amp;*$0, &amp;*v1306)"
                        let v1308 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1251 v1307
                        let v1309 : string = "$0.unwrap()"
                        let v1310 : uint64 = Fable.Core.RustInterop.emitRustExpr v1308 v1309
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1251, v1252, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1304 &lt;- Some x
                        _v1304.Value
                        false
                    else
                        true
                else
                    true
            let v1317 : UH3 =
                if v1312 then
                    let v1313 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    let v1314 : UH3 = UH3_0
                    UH3_1(v1250, v679, v1313, v1314)
                else
                    UH3_0
            let v1318 : string = "pdf"
            let struct (v1319 : string, v1320 : string) = method73(v1318, v679, v4)
            let v1321 : bool option = None
            let v1322 : bool = true in let mutable _v1321 = v1321
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1323 : string = method14(v1320)
            let v1324 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1325 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1323 v1324
            let v1326 : string = "String::from($0)"
            let v1327 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1325 v1326
            let v1328 : string = "std::path::PathBuf::from($0)"
            let v1329 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1327 v1328
            let v1330 : string = "$0.exists()"
            let v1331 : bool = Fable.Core.RustInterop.emitRustExpr v1329 v1330
            let v1334 : bool =
                if v1331 then
                    let v1332 : string = "$0.is_file()"
                    let v1333 : bool = Fable.Core.RustInterop.emitRustExpr v1329 v1332
                    v1333
                else
                    false
            v1334
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1335 : bool = null |&gt; unbox&lt;bool&gt;
            v1335
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1336 : bool = null |&gt; unbox&lt;bool&gt;
            v1336
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1337 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1338 : string = "$0.existsSync($1)"
            let v1339 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1337, v1320) v1338
            v1339
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1340 : bool = null |&gt; unbox&lt;bool&gt;
            v1340
#endif
            
#else
            let v1341 : (string -&gt; bool) = System.IO.File.Exists
            let v1342 : bool = v1341 v1320
            v1342
#endif
            |&gt; fun x -&gt; _v1321 &lt;- Some x
            let v1343 : bool = _v1321.Value
            let v1344 : bool = v1343 = false
            let v1379 : bool =
                if v1344 then
                    let v1345 : bool option = None
                    let v1346 : bool = true in let mutable _v1345 = v1345
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1347 : string = method14(v1319)
                    let v1348 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1349 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1347 v1348
                    let v1350 : string = "String::from($0)"
                    let v1351 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1349 v1350
                    let v1352 : string = "std::path::PathBuf::from($0)"
                    let v1353 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1351 v1352
                    let v1354 : string = "$0.exists()"
                    let v1355 : bool = Fable.Core.RustInterop.emitRustExpr v1353 v1354
                    let v1358 : bool =
                        if v1355 then
                            let v1356 : string = "$0.is_file()"
                            let v1357 : bool = Fable.Core.RustInterop.emitRustExpr v1353 v1356
                            v1357
                        else
                            false
                    v1358
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1359 : bool = null |&gt; unbox&lt;bool&gt;
                    v1359
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1360 : bool = null |&gt; unbox&lt;bool&gt;
                    v1360
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1361 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1362 : string = "$0.existsSync($1)"
                    let v1363 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1361, v1319) v1362
                    v1363
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1364 : bool = null |&gt; unbox&lt;bool&gt;
                    v1364
#endif
                    
#else
                    let v1365 : (string -&gt; bool) = System.IO.File.Exists
                    let v1366 : bool = v1365 v1319
                    v1366
#endif
                    |&gt; fun x -&gt; _v1345 &lt;- Some x
                    let v1367 : bool = _v1345.Value
                    if v1367 then
                        let v1368 : US0 = US0_2
                        let v1369 : (unit -&gt; string) = closure70()
                        let v1370 : (unit -&gt; string) = closure71(v1319, v1320)
                        method3(v1368, v1369, v1370)
                        let v1371 : unit option = None
                        let v1372 : bool = true in let mutable _v1371 = v1371
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1373 : string = method74(v1320)
                        let v1374 : string = "std::fs::copy(&amp;*$0, &amp;*v1373)"
                        let v1375 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1319 v1374
                        let v1376 : string = "$0.unwrap()"
                        let v1377 : uint64 = Fable.Core.RustInterop.emitRustExpr v1375 v1376
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1319, v1320, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1371 &lt;- Some x
                        _v1371.Value
                        false
                    else
                        true
                else
                    true
            let v1382 : UH3 =
                if v1379 then
                    let v1380 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    UH3_1(v1318, v679, v1380, v1317)
                else
                    v1317
            let v1383 : string = "html"
            let struct (v1384 : string, v1385 : string) = method73(v1383, v679, v4)
            let v1386 : bool option = None
            let v1387 : bool = true in let mutable _v1386 = v1386
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1388 : string = method14(v1385)
            let v1389 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1390 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1388 v1389
            let v1391 : string = "String::from($0)"
            let v1392 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1390 v1391
            let v1393 : string = "std::path::PathBuf::from($0)"
            let v1394 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1392 v1393
            let v1395 : string = "$0.exists()"
            let v1396 : bool = Fable.Core.RustInterop.emitRustExpr v1394 v1395
            let v1399 : bool =
                if v1396 then
                    let v1397 : string = "$0.is_file()"
                    let v1398 : bool = Fable.Core.RustInterop.emitRustExpr v1394 v1397
                    v1398
                else
                    false
            v1399
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1400 : bool = null |&gt; unbox&lt;bool&gt;
            v1400
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1401 : bool = null |&gt; unbox&lt;bool&gt;
            v1401
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1402 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1403 : string = "$0.existsSync($1)"
            let v1404 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1402, v1385) v1403
            v1404
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1405 : bool = null |&gt; unbox&lt;bool&gt;
            v1405
#endif
            
#else
            let v1406 : (string -&gt; bool) = System.IO.File.Exists
            let v1407 : bool = v1406 v1385
            v1407
#endif
            |&gt; fun x -&gt; _v1386 &lt;- Some x
            let v1408 : bool = _v1386.Value
            let v1409 : bool = v1408 = false
            let v1444 : bool =
                if v1409 then
                    let v1410 : bool option = None
                    let v1411 : bool = true in let mutable _v1410 = v1410
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1412 : string = method14(v1384)
                    let v1413 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1414 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1412 v1413
                    let v1415 : string = "String::from($0)"
                    let v1416 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1414 v1415
                    let v1417 : string = "std::path::PathBuf::from($0)"
                    let v1418 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1416 v1417
                    let v1419 : string = "$0.exists()"
                    let v1420 : bool = Fable.Core.RustInterop.emitRustExpr v1418 v1419
                    let v1423 : bool =
                        if v1420 then
                            let v1421 : string = "$0.is_file()"
                            let v1422 : bool = Fable.Core.RustInterop.emitRustExpr v1418 v1421
                            v1422
                        else
                            false
                    v1423
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1424 : bool = null |&gt; unbox&lt;bool&gt;
                    v1424
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1425 : bool = null |&gt; unbox&lt;bool&gt;
                    v1425
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1426 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1427 : string = "$0.existsSync($1)"
                    let v1428 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1426, v1384) v1427
                    v1428
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1429 : bool = null |&gt; unbox&lt;bool&gt;
                    v1429
#endif
                    
#else
                    let v1430 : (string -&gt; bool) = System.IO.File.Exists
                    let v1431 : bool = v1430 v1384
                    v1431
#endif
                    |&gt; fun x -&gt; _v1410 &lt;- Some x
                    let v1432 : bool = _v1410.Value
                    if v1432 then
                        let v1433 : US0 = US0_2
                        let v1434 : (unit -&gt; string) = closure70()
                        let v1435 : (unit -&gt; string) = closure71(v1384, v1385)
                        method3(v1433, v1434, v1435)
                        let v1436 : unit option = None
                        let v1437 : bool = true in let mutable _v1436 = v1436
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1438 : string = method74(v1385)
                        let v1439 : string = "std::fs::copy(&amp;*$0, &amp;*v1438)"
                        let v1440 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1384 v1439
                        let v1441 : string = "$0.unwrap()"
                        let v1442 : uint64 = Fable.Core.RustInterop.emitRustExpr v1440 v1441
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1384, v1385, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1436 &lt;- Some x
                        _v1436.Value
                        false
                    else
                        true
                else
                    true
            let v1447 : UH3 =
                if v1444 then
                    let v1445 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    UH3_1(v1383, v679, v1445, v1382)
                else
                    v1382
            let struct (v1448 : string, v1449 : string) = method73(v1250, v452, v4)
            let v1450 : bool option = None
            let v1451 : bool = true in let mutable _v1450 = v1450
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1452 : string = method14(v1449)
            let v1453 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1454 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1452 v1453
            let v1455 : string = "String::from($0)"
            let v1456 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1454 v1455
            let v1457 : string = "std::path::PathBuf::from($0)"
            let v1458 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1456 v1457
            let v1459 : string = "$0.exists()"
            let v1460 : bool = Fable.Core.RustInterop.emitRustExpr v1458 v1459
            let v1463 : bool =
                if v1460 then
                    let v1461 : string = "$0.is_file()"
                    let v1462 : bool = Fable.Core.RustInterop.emitRustExpr v1458 v1461
                    v1462
                else
                    false
            v1463
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1464 : bool = null |&gt; unbox&lt;bool&gt;
            v1464
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1465 : bool = null |&gt; unbox&lt;bool&gt;
            v1465
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1466 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1467 : string = "$0.existsSync($1)"
            let v1468 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1466, v1449) v1467
            v1468
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1469 : bool = null |&gt; unbox&lt;bool&gt;
            v1469
#endif
            
#else
            let v1470 : (string -&gt; bool) = System.IO.File.Exists
            let v1471 : bool = v1470 v1449
            v1471
#endif
            |&gt; fun x -&gt; _v1450 &lt;- Some x
            let v1472 : bool = _v1450.Value
            let v1473 : bool = v1472 = false
            let v1508 : bool =
                if v1473 then
                    let v1474 : bool option = None
                    let v1475 : bool = true in let mutable _v1474 = v1474
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1476 : string = method14(v1448)
                    let v1477 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1478 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1476 v1477
                    let v1479 : string = "String::from($0)"
                    let v1480 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1478 v1479
                    let v1481 : string = "std::path::PathBuf::from($0)"
                    let v1482 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1480 v1481
                    let v1483 : string = "$0.exists()"
                    let v1484 : bool = Fable.Core.RustInterop.emitRustExpr v1482 v1483
                    let v1487 : bool =
                        if v1484 then
                            let v1485 : string = "$0.is_file()"
                            let v1486 : bool = Fable.Core.RustInterop.emitRustExpr v1482 v1485
                            v1486
                        else
                            false
                    v1487
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1488 : bool = null |&gt; unbox&lt;bool&gt;
                    v1488
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1489 : bool = null |&gt; unbox&lt;bool&gt;
                    v1489
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1490 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1491 : string = "$0.existsSync($1)"
                    let v1492 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1490, v1448) v1491
                    v1492
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1493 : bool = null |&gt; unbox&lt;bool&gt;
                    v1493
#endif
                    
#else
                    let v1494 : (string -&gt; bool) = System.IO.File.Exists
                    let v1495 : bool = v1494 v1448
                    v1495
#endif
                    |&gt; fun x -&gt; _v1474 &lt;- Some x
                    let v1496 : bool = _v1474.Value
                    if v1496 then
                        let v1497 : US0 = US0_2
                        let v1498 : (unit -&gt; string) = closure70()
                        let v1499 : (unit -&gt; string) = closure71(v1448, v1449)
                        method3(v1497, v1498, v1499)
                        let v1500 : unit option = None
                        let v1501 : bool = true in let mutable _v1500 = v1500
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1502 : string = method74(v1449)
                        let v1503 : string = "std::fs::copy(&amp;*$0, &amp;*v1502)"
                        let v1504 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1448 v1503
                        let v1505 : string = "$0.unwrap()"
                        let v1506 : uint64 = Fable.Core.RustInterop.emitRustExpr v1504 v1505
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1448, v1449, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1500 &lt;- Some x
                        _v1500.Value
                        false
                    else
                        true
                else
                    true
            let v1511 : UH3 =
                if v1508 then
                    let v1509 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    UH3_1(v1250, v452, v1509, v1447)
                else
                    v1447
            let struct (v1512 : string, v1513 : string) = method73(v1318, v452, v4)
            let v1514 : bool option = None
            let v1515 : bool = true in let mutable _v1514 = v1514
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1516 : string = method14(v1513)
            let v1517 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1518 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1516 v1517
            let v1519 : string = "String::from($0)"
            let v1520 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1518 v1519
            let v1521 : string = "std::path::PathBuf::from($0)"
            let v1522 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1520 v1521
            let v1523 : string = "$0.exists()"
            let v1524 : bool = Fable.Core.RustInterop.emitRustExpr v1522 v1523
            let v1527 : bool =
                if v1524 then
                    let v1525 : string = "$0.is_file()"
                    let v1526 : bool = Fable.Core.RustInterop.emitRustExpr v1522 v1525
                    v1526
                else
                    false
            v1527
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1528 : bool = null |&gt; unbox&lt;bool&gt;
            v1528
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1529 : bool = null |&gt; unbox&lt;bool&gt;
            v1529
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1530 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1531 : string = "$0.existsSync($1)"
            let v1532 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1530, v1513) v1531
            v1532
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1533 : bool = null |&gt; unbox&lt;bool&gt;
            v1533
#endif
            
#else
            let v1534 : (string -&gt; bool) = System.IO.File.Exists
            let v1535 : bool = v1534 v1513
            v1535
#endif
            |&gt; fun x -&gt; _v1514 &lt;- Some x
            let v1536 : bool = _v1514.Value
            let v1537 : bool = v1536 = false
            let v1572 : bool =
                if v1537 then
                    let v1538 : bool option = None
                    let v1539 : bool = true in let mutable _v1538 = v1538
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1540 : string = method14(v1512)
                    let v1541 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1542 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1540 v1541
                    let v1543 : string = "String::from($0)"
                    let v1544 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1542 v1543
                    let v1545 : string = "std::path::PathBuf::from($0)"
                    let v1546 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1544 v1545
                    let v1547 : string = "$0.exists()"
                    let v1548 : bool = Fable.Core.RustInterop.emitRustExpr v1546 v1547
                    let v1551 : bool =
                        if v1548 then
                            let v1549 : string = "$0.is_file()"
                            let v1550 : bool = Fable.Core.RustInterop.emitRustExpr v1546 v1549
                            v1550
                        else
                            false
                    v1551
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1552 : bool = null |&gt; unbox&lt;bool&gt;
                    v1552
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1553 : bool = null |&gt; unbox&lt;bool&gt;
                    v1553
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1554 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1555 : string = "$0.existsSync($1)"
                    let v1556 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1554, v1512) v1555
                    v1556
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1557 : bool = null |&gt; unbox&lt;bool&gt;
                    v1557
#endif
                    
#else
                    let v1558 : (string -&gt; bool) = System.IO.File.Exists
                    let v1559 : bool = v1558 v1512
                    v1559
#endif
                    |&gt; fun x -&gt; _v1538 &lt;- Some x
                    let v1560 : bool = _v1538.Value
                    if v1560 then
                        let v1561 : US0 = US0_2
                        let v1562 : (unit -&gt; string) = closure70()
                        let v1563 : (unit -&gt; string) = closure71(v1512, v1513)
                        method3(v1561, v1562, v1563)
                        let v1564 : unit option = None
                        let v1565 : bool = true in let mutable _v1564 = v1564
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1566 : string = method74(v1513)
                        let v1567 : string = "std::fs::copy(&amp;*$0, &amp;*v1566)"
                        let v1568 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1512 v1567
                        let v1569 : string = "$0.unwrap()"
                        let v1570 : uint64 = Fable.Core.RustInterop.emitRustExpr v1568 v1569
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1512, v1513, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1564 &lt;- Some x
                        _v1564.Value
                        false
                    else
                        true
                else
                    true
            let v1575 : UH3 =
                if v1572 then
                    let v1573 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    UH3_1(v1318, v452, v1573, v1511)
                else
                    v1511
            let struct (v1576 : string, v1577 : string) = method73(v1383, v452, v4)
            let v1578 : bool option = None
            let v1579 : bool = true in let mutable _v1578 = v1578
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1580 : string = method14(v1577)
            let v1581 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1582 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1580 v1581
            let v1583 : string = "String::from($0)"
            let v1584 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1582 v1583
            let v1585 : string = "std::path::PathBuf::from($0)"
            let v1586 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1584 v1585
            let v1587 : string = "$0.exists()"
            let v1588 : bool = Fable.Core.RustInterop.emitRustExpr v1586 v1587
            let v1591 : bool =
                if v1588 then
                    let v1589 : string = "$0.is_file()"
                    let v1590 : bool = Fable.Core.RustInterop.emitRustExpr v1586 v1589
                    v1590
                else
                    false
            v1591
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1592 : bool = null |&gt; unbox&lt;bool&gt;
            v1592
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1593 : bool = null |&gt; unbox&lt;bool&gt;
            v1593
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1594 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1595 : string = "$0.existsSync($1)"
            let v1596 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1594, v1577) v1595
            v1596
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1597 : bool = null |&gt; unbox&lt;bool&gt;
            v1597
#endif
            
#else
            let v1598 : (string -&gt; bool) = System.IO.File.Exists
            let v1599 : bool = v1598 v1577
            v1599
#endif
            |&gt; fun x -&gt; _v1578 &lt;- Some x
            let v1600 : bool = _v1578.Value
            let v1601 : bool = v1600 = false
            let v1636 : bool =
                if v1601 then
                    let v1602 : bool option = None
                    let v1603 : bool = true in let mutable _v1602 = v1602
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1604 : string = method14(v1576)
                    let v1605 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1606 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1604 v1605
                    let v1607 : string = "String::from($0)"
                    let v1608 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1606 v1607
                    let v1609 : string = "std::path::PathBuf::from($0)"
                    let v1610 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1608 v1609
                    let v1611 : string = "$0.exists()"
                    let v1612 : bool = Fable.Core.RustInterop.emitRustExpr v1610 v1611
                    let v1615 : bool =
                        if v1612 then
                            let v1613 : string = "$0.is_file()"
                            let v1614 : bool = Fable.Core.RustInterop.emitRustExpr v1610 v1613
                            v1614
                        else
                            false
                    v1615
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1616 : bool = null |&gt; unbox&lt;bool&gt;
                    v1616
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1617 : bool = null |&gt; unbox&lt;bool&gt;
                    v1617
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1618 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1619 : string = "$0.existsSync($1)"
                    let v1620 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1618, v1576) v1619
                    v1620
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1621 : bool = null |&gt; unbox&lt;bool&gt;
                    v1621
#endif
                    
#else
                    let v1622 : (string -&gt; bool) = System.IO.File.Exists
                    let v1623 : bool = v1622 v1576
                    v1623
#endif
                    |&gt; fun x -&gt; _v1602 &lt;- Some x
                    let v1624 : bool = _v1602.Value
                    if v1624 then
                        let v1625 : US0 = US0_2
                        let v1626 : (unit -&gt; string) = closure70()
                        let v1627 : (unit -&gt; string) = closure71(v1576, v1577)
                        method3(v1625, v1626, v1627)
                        let v1628 : unit option = None
                        let v1629 : bool = true in let mutable _v1628 = v1628
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1630 : string = method74(v1577)
                        let v1631 : string = "std::fs::copy(&amp;*$0, &amp;*v1630)"
                        let v1632 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1576 v1631
                        let v1633 : string = "$0.unwrap()"
                        let v1634 : uint64 = Fable.Core.RustInterop.emitRustExpr v1632 v1633
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1576, v1577, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1628 &lt;- Some x
                        _v1628.Value
                        false
                    else
                        true
                else
                    true
            let v1639 : UH3 =
                if v1636 then
                    let v1637 : (string -&gt; (string -&gt; US19)) = closure66(v4, v3)
                    UH3_1(v1383, v452, v1637, v1575)
                else
                    v1575
            let struct (v1640 : string, v1641 : string) = method73(v677, v452, v4)
            let v1642 : bool option = None
            let v1643 : bool = true in let mutable _v1642 = v1642
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v1644 : string = method14(v1641)
            let v1645 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
            let v1646 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1644 v1645
            let v1647 : string = "String::from($0)"
            let v1648 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1646 v1647
            let v1649 : string = "std::path::PathBuf::from($0)"
            let v1650 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1648 v1649
            let v1651 : string = "$0.exists()"
            let v1652 : bool = Fable.Core.RustInterop.emitRustExpr v1650 v1651
            let v1655 : bool =
                if v1652 then
                    let v1653 : string = "$0.is_file()"
                    let v1654 : bool = Fable.Core.RustInterop.emitRustExpr v1650 v1653
                    v1654
                else
                    false
            v1655
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v1656 : bool = null |&gt; unbox&lt;bool&gt;
            v1656
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v1657 : bool = null |&gt; unbox&lt;bool&gt;
            v1657
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v1658 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
            let v1659 : string = "$0.existsSync($1)"
            let v1660 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1658, v1641) v1659
            v1660
#endif
            
#if FABLE_COMPILER_PYTHON
            let v1661 : bool = null |&gt; unbox&lt;bool&gt;
            v1661
#endif
            
#else
            let v1662 : (string -&gt; bool) = System.IO.File.Exists
            let v1663 : bool = v1662 v1641
            v1663
#endif
            |&gt; fun x -&gt; _v1642 &lt;- Some x
            let v1664 : bool = _v1642.Value
            let v1665 : bool = v1664 = false
            let v1700 : bool =
                if v1665 then
                    let v1666 : bool option = None
                    let v1667 : bool = true in let mutable _v1666 = v1666
                    
#if FABLE_COMPILER || WASM || CONTRACT
                    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                    let v1668 : string = method14(v1640)
                    let v1669 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
                    let v1670 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v1668 v1669
                    let v1671 : string = "String::from($0)"
                    let v1672 : std_string_String = Fable.Core.RustInterop.emitRustExpr v1670 v1671
                    let v1673 : string = "std::path::PathBuf::from($0)"
                    let v1674 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v1672 v1673
                    let v1675 : string = "$0.exists()"
                    let v1676 : bool = Fable.Core.RustInterop.emitRustExpr v1674 v1675
                    let v1679 : bool =
                        if v1676 then
                            let v1677 : string = "$0.is_file()"
                            let v1678 : bool = Fable.Core.RustInterop.emitRustExpr v1674 v1677
                            v1678
                        else
                            false
                    v1679
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                    let v1680 : bool = null |&gt; unbox&lt;bool&gt;
                    v1680
#endif
                    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                    let v1681 : bool = null |&gt; unbox&lt;bool&gt;
                    v1681
#endif
                    
#if FABLE_COMPILER_TYPESCRIPT
                    let v1682 : IFsExistsSync = Fable.Core.JsInterop.importAll v1269
                    let v1683 : string = "$0.existsSync($1)"
                    let v1684 : bool = Fable.Core.JsInterop.emitJsExpr struct (v1682, v1640) v1683
                    v1684
#endif
                    
#if FABLE_COMPILER_PYTHON
                    let v1685 : bool = null |&gt; unbox&lt;bool&gt;
                    v1685
#endif
                    
#else
                    let v1686 : (string -&gt; bool) = System.IO.File.Exists
                    let v1687 : bool = v1686 v1640
                    v1687
#endif
                    |&gt; fun x -&gt; _v1666 &lt;- Some x
                    let v1688 : bool = _v1666.Value
                    if v1688 then
                        let v1689 : US0 = US0_2
                        let v1690 : (unit -&gt; string) = closure70()
                        let v1691 : (unit -&gt; string) = closure71(v1640, v1641)
                        method3(v1689, v1690, v1691)
                        let v1692 : unit option = None
                        let v1693 : bool = true in let mutable _v1692 = v1692
                        
#if FABLE_COMPILER || WASM || CONTRACT
                        
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
                        let v1694 : string = method74(v1641)
                        let v1695 : string = "std::fs::copy(&amp;*$0, &amp;*v1694)"
                        let v1696 : Result&lt;uint64, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v1640 v1695
                        let v1697 : string = "$0.unwrap()"
                        let v1698 : uint64 = Fable.Core.RustInterop.emitRustExpr v1696 v1697
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; WASM
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_TYPESCRIPT
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#if FABLE_COMPILER_PYTHON
                        null |&gt; unbox&lt;unit&gt;
                        ()
#endif
                        
#else
                        System.IO.File.Copy (v1640, v1641, true)
                        ()
#endif
                        |&gt; fun x -&gt; _v1692 &lt;- Some x
                        _v1692.Value
                        false
                    else
                        true
                else
                    true
            let v1705 : UH3 =
                if v1700 then
                    let v1701 : (string -&gt; (string -&gt; US19)) = closure59(v4, v3, v1, v0)
                    let v1702 : UH3 = UH3_0
                    UH3_1(v677, v452, v1701, v1702)
                else
                    UH3_0
            let v1706 : UH2 = UH2_0
            let v1707 : UH2 = UH2_1(v1639, v1706)
            UH2_1(v1705, v1707)
    let v1710 : UH3 list = []
    let v1711 : UH3 list = method82(v1709, v1710)
    let v1712 : (UH3 list -&gt; (UH3 [])) = List.toArray
    let v1713 : (UH3 []) = v1712 v1711
    let v1714 : string = "$0.to_vec()"
    let v1715 : Vec&lt;UH3&gt; = Fable.Core.RustInterop.emitRustExpr v1713 v1714
    let v1716 : (Result&lt;string, (string * string)&gt; option []) = [||]
    let v1717 : string = "$0.to_vec()"
    let v1718 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr v1716 v1717
    let v1719 : string = "fable_library_rust::NativeArray_::array_from($0)"
    let v1720 : (UH3 []) = Fable.Core.RustInterop.emitRustExpr v1715 v1719
    let v1721 : int32 = v1720.Length
    let v1722 : Mut8 = {l0 = 0; l1 = v1718} : Mut8
    while method83(v1721, v1722) do
        let v1724 : int32 = v1722.l0
        let v1725 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = v1722.l1
        let v1726 : UH3 = v1720.[int v1724]
        let v1727 : struct (string * string * (string -&gt; (string -&gt; US19))) list = []
        let v1728 : struct (string * string * (string -&gt; (string -&gt; US19))) list = method84(v1726, v1727)
        let v1729 : (struct (string * string * (string -&gt; (string -&gt; US19))) list -&gt; (struct (string * string * (string -&gt; (string -&gt; US19))) [])) = List.toArray
        let v1730 : (struct (string * string * (string -&gt; (string -&gt; US19))) []) = v1729 v1728
        let v1731 : string = "$0.to_vec()"
        let v1732 : Vec&lt;struct (string * string * (string -&gt; (string -&gt; US19)))&gt; = Fable.Core.RustInterop.emitRustExpr v1730 v1731
        let v1733 : string = "rayon::iter::IntoParallelIterator::into_par_iter(v1732)"
        let v1734 : rayon_vec_IntoIter&lt;struct (string * string * (string -&gt; (string -&gt; US19)))&gt; = Fable.Core.RustInterop.emitRustExpr () v1733
        let v1735 : string = "rayon::iter::ParallelIterator::map($0, |x| $1(x))"
        let v1736 : (struct (string * string * (string -&gt; (string -&gt; US19))) -&gt; Result&lt;string, (string * string)&gt; option) = closure72()
        let v1737 : rayon_iter_Map&lt;rayon_vec_IntoIter&lt;struct (string * string * (string -&gt; (string -&gt; US19)))&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v1734, v1736) v1735
        let v1738 : string = "rayon::iter::ParallelIterator::collect($0)"
        let v1739 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr v1737 v1738
        let v1740 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = method85(v1739)
        let v1741 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = method86(v1725)
        let v1742 : string = "let mut v1741 = v1741"
        Fable.Core.RustInterop.emitRustExpr () v1742
        let v1743 : string = "v1741.extend(v1740)"
        Fable.Core.RustInterop.emitRustExpr () v1743
        let v1744 : string = "v1741"
        let v1745 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = Fable.Core.RustInterop.emitRustExpr () v1744
        let v1746 : int32 = v1724 + 1
        v1722.l0 &lt;- v1746
        v1722.l1 &lt;- v1745
        ()
    let v1747 : Vec&lt;Result&lt;string, (string * string)&gt; option&gt; = v1722.l1
    let v1748 : (string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;) = v225, v1747
    let v1749 : Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt; = Ok v1748
    v1749
and closure73 () () : string =
    let v0 : string = "documents.run"
    v0
and closure74 (v0 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;) () : string =
    let v1 : string = "$0.len()"
    let v2 : unativeint = Fable.Core.RustInterop.emitRustExpr v0 v1
    let v3 : (unit -&gt; string) = closure6()
    let v4 : string = $"result_len: {v2} / {v3 ()}"
    v4
and method87 (v0 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;) : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; =
    v0
and method29 (v0 : string, v1 : string, v2 : string, v3 : string, v4 : string) : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; =
    let v5 : string = "let __result = Box::pin(async move { //"
    Fable.Core.RustInterop.emitRustExpr () v5
    let v6 : string = "async_walkdir::WalkDir::new(&amp;*$0)"
    let v7 : async_walkdir_WalkDir = Fable.Core.RustInterop.emitRustExpr v3 v6
    let v8 : string = "async_walkdir::WalkDir::filter($0, |x| $1(x))"
    let v9 : (async_walkdir_DirEntry -&gt; std_pin_Pin&lt;Box&lt;Send&lt;Dyn&lt;std_future_Future&lt;async_walkdir_Filtering&gt;&gt;&gt;&gt;&gt;) = closure14()
    let v10 : async_walkdir_WalkDir = Fable.Core.RustInterop.emitRustExpr struct (v7, v9) v8
    let v11 : (Result&lt;async_walkdir_DirEntry, std_io_Error&gt; -&gt; string option) = method37()
    let v12 : string = "futures_lite::stream::StreamExt::collect(futures_lite::stream::StreamExt::filter_map(v10, |x| v11(x))).await"
    let v13 : Vec&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr () v12
    let v14 : US0 = US0_1
    let v15 : (unit -&gt; string) = closure23()
    let v16 : (unit -&gt; string) = closure24(v13)
    method3(v14, v15, v16)
    let v17 : string = "rayon::iter::IntoParallelIterator::into_par_iter(v13)"
    let v18 : rayon_vec_IntoIter&lt;string&gt; = Fable.Core.RustInterop.emitRustExpr () v17
    let v19 : string = "rayon::iter::ParallelIterator::map($0, |x| $1(x))"
    let v20 : (string -&gt; Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;) = closure25(v0, v1, v2, v3, v4)
    let v21 : rayon_iter_Map&lt;rayon_vec_IntoIter&lt;string&gt;&gt; = Fable.Core.RustInterop.emitRustExpr struct (v18, v20) v19
    let v22 : string = "rayon::iter::ParallelIterator::collect($0)"
    let v23 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v21 v22
    let v24 : US0 = US0_1
    let v25 : (unit -&gt; string) = closure73()
    let v26 : (unit -&gt; string) = closure74(v23)
    method3(v24, v25, v26)
    let v27 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = Ok v23
    let v28 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = method87(v27)
    let v29 : string = "v28 }}}})"
    Fable.Core.RustInterop.emitRustExpr () v29
    let v30 : string = "{{{ //"
    Fable.Core.RustInterop.emitRustExpr () v30
    let v31 : string = "__result"
    let v32 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; = Fable.Core.RustInterop.emitRustExpr () v31
    v32
and method12 (v0 : string, v1 : string, v2 : string, v3 : string) : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; =
    let v4 : string = __SOURCE_DIRECTORY__
    let v5 : string = "polyglot"
    let v6 : string = ".paket"
    let v7 : string = method13(v5, v6)
    let v8 : string = method17(v7, v4)
    let v9 : string = method13(v8, v5)
    let v10 : string option = None
    let v11 : bool = true in let mutable _v10 = v10
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v12 : string = method21(v3)
    let v13 : string = method14(v12)
    let v14 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v15 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v13 v14
    let v16 : string = "String::from($0)"
    let v17 : std_string_String = Fable.Core.RustInterop.emitRustExpr v15 v16
    let v18 : string = "std::path::PathBuf::from($0)"
    let v19 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v17 v18
    let v20 : string = "$0.exists()"
    let v21 : bool = Fable.Core.RustInterop.emitRustExpr v19 v20
    let v22 : bool = v21 = false
    let v172 : string =
        if v22 then
            let v23 : string option = None
            let v24 : bool = true in let mutable _v23 = v23
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v25 : string = "std::env::current_dir()"
            let v26 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v25
            let v27 : string = "$0.unwrap()"
            let v28 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v26 v27
            let v29 : string = "$0.display()"
            let v30 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v28 v29
            let v31 : std_string_String option = None
            let v32 : bool = true in let mutable _v31 = v31
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v33 : string = @$"format!(""{{}}"", $0)"
            let v34 : std_string_String = Fable.Core.RustInterop.emitRustExpr v30 v33
            v34
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v35 : string = @$"format!(""{{}}"", $0)"
            let v36 : std_string_String = Fable.Core.RustInterop.emitRustExpr v30 v35
            v36
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v37 : string = @$"format!(""{{}}"", $0)"
            let v38 : std_string_String = Fable.Core.RustInterop.emitRustExpr v30 v37
            v38
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v39 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v39
#endif
            
#if FABLE_COMPILER_PYTHON
            let v40 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v40
#endif
            
#else
            let v41 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v41
#endif
            |&gt; fun x -&gt; _v31 &lt;- Some x
            let v42 : std_string_String = _v31.Value
            let v43 : string = "fable_library_rust::String_::fromString($0)"
            let v44 : string = Fable.Core.RustInterop.emitRustExpr v42 v43
            v44
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v45 : string = null |&gt; unbox&lt;string&gt;
            v45
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v46 : string = null |&gt; unbox&lt;string&gt;
            v46
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v47 : string = null |&gt; unbox&lt;string&gt;
            v47
#endif
            
#if FABLE_COMPILER_PYTHON
            let v48 : string = null |&gt; unbox&lt;string&gt;
            v48
#endif
            
#else
            let v49 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v50 : string = v49 ()
            v50
#endif
            |&gt; fun x -&gt; _v23 &lt;- Some x
            let v51 : string = _v23.Value
            let v52 : string = method13(v51, v12)
            let v53 : string option = None
            let v54 : bool = true in let mutable _v53 = v53
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v55 : string = method22()
            let v56 : string = method23(v52)
            let v57 : string = method24()
            let v58 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v59 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v55, v56, v57) v58
            let v60 : string = "String::from($0)"
            let v61 : std_string_String = Fable.Core.RustInterop.emitRustExpr v59 v60
            let v62 : string = "fable_library_rust::String_::fromString($0)"
            let v63 : string = Fable.Core.RustInterop.emitRustExpr v61 v62
            v63
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v64 : string = null |&gt; unbox&lt;string&gt;
            v64
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v65 : string = null |&gt; unbox&lt;string&gt;
            v65
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v66 : string = null |&gt; unbox&lt;string&gt;
            v66
#endif
            
#if FABLE_COMPILER_PYTHON
            let v67 : string = null |&gt; unbox&lt;string&gt;
            v67
#endif
            
#else
            let v68 : string = "^\\\\\\\\\\?\\\\"
            let v69 : string = ""
            let v70 : string = System.Text.RegularExpressions.Regex.Replace (v52, v68, v69)
            v70
#endif
            |&gt; fun x -&gt; _v53 &lt;- Some x
            let v71 : string = _v53.Value
            let v72 : string = $"{v71.[0] |&gt; string |&gt; _.ToLower()}{v71.[1..]}"
            let v73 : string = "\\"
            let v74 : string = "/"
            let v75 : string = v72.Replace (v73, v74)
            let v76 : (string []) = v75.Split v74
            let v77 : (string []) = [||]
            let v78 : int32 = v76.Length
            let v79 : Mut4 = {l0 = 0; l1 = 0; l2 = v77} : Mut4
            while method25(v78, v79) do
                let v81 : int32 = v79.l0
                let v82 : int32 =  -v81
                let v83 : int32 = v82 + v78
                let v84 : int32 = v83 - 1
                let struct (v85 : int32, v86 : (string [])) = v79.l1, v79.l2
                let v87 : string = v76.[int v84]
                let v88 : bool = ".." = v87
                let struct (v130 : int32, v131 : (string [])) =
                    if v88 then
                        let v89 : int32 = v85 + 1
                        struct (v89, v86)
                    else
                        let v90 : bool = "." = v87
                        if v90 then
                            struct (v85, v86)
                        else
                            let v91 : bool = 0 = v85
                            if v91 then
                                let v92 : string = ":"
                                let v93 : bool = v87.EndsWith v92
                                if v93 then
                                    let v94 : string = $"{v51.[0]}:"
                                    let v95 : (string []) = [|v94|]
                                    let v96 : int32 = v95.Length
                                    let v97 : int32 = v86.Length
                                    let v98 : int32 = v96 + v97
                                    let v99 : (string []) = Array.zeroCreate&lt;string&gt; (v98)
                                    let v100 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v98, v100) do
                                        let v102 : int32 = v100.l0
                                        let v103 : bool = v102 &lt; v96
                                        let v107 : string =
                                            if v103 then
                                                let v104 : string = v95.[int v102]
                                                v104
                                            else
                                                let v105 : int32 = v102 - v96
                                                let v106 : string = v86.[int v105]
                                                v106
                                        v99.[int v102] &lt;- v107
                                        let v108 : int32 = v102 + 1
                                        v100.l0 &lt;- v108
                                        ()
                                    struct (0, v99)
                                else
                                    let v109 : (string []) = [|v87|]
                                    let v110 : int32 = v109.Length
                                    let v111 : int32 = v86.Length
                                    let v112 : int32 = v110 + v111
                                    let v113 : (string []) = Array.zeroCreate&lt;string&gt; (v112)
                                    let v114 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v112, v114) do
                                        let v116 : int32 = v114.l0
                                        let v117 : bool = v116 &lt; v110
                                        let v121 : string =
                                            if v117 then
                                                let v118 : string = v109.[int v116]
                                                v118
                                            else
                                                let v119 : int32 = v116 - v110
                                                let v120 : string = v86.[int v119]
                                                v120
                                        v113.[int v116] &lt;- v121
                                        let v122 : int32 = v116 + 1
                                        v114.l0 &lt;- v122
                                        ()
                                    struct (0, v113)
                            else
                                let v125 : int32 = v85 - 1
                                struct (v125, v86)
                let v132 : int32 = v81 + 1
                v79.l0 &lt;- v132
                v79.l1 &lt;- v130
                v79.l2 &lt;- v131
                ()
            let struct (v133 : int32, v134 : (string [])) = v79.l1, v79.l2
            let v135 : string seq = seq { for i = 0 to v134.Length - 1 do yield v134.[i] }
            let v136 : char option = None
            let v137 : bool = true in let mutable _v136 = v136
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v138 : string = "std::path::MAIN_SEPARATOR"
            let v139 : char = Fable.Core.RustInterop.emitRustExpr () v138
            v139
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v140 : char = null |&gt; unbox&lt;char&gt;
            v140
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v141 : char = null |&gt; unbox&lt;char&gt;
            v141
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v142 : char = null |&gt; unbox&lt;char&gt;
            v142
#endif
            
#if FABLE_COMPILER_PYTHON
            let v143 : char = null |&gt; unbox&lt;char&gt;
            v143
#endif
            
#else
            let v144 : char = System.IO.Path.DirectorySeparatorChar
            v144
#endif
            |&gt; fun x -&gt; _v136 &lt;- Some x
            let v145 : char = _v136.Value
            let v146 : (char -&gt; string) = _.ToString()
            let v147 : string = v146 v145
            let v148 : string = method27(v147)
            let v149 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v150 : (string seq -&gt; string) = v149 v148
            v150 v135
        else
            let v152 : string = "std::fs::canonicalize(&amp;*$0)"
            let v153 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v12 v152
            let v154 : string = "$0.unwrap()"
            let v155 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v153 v154
            let v156 : string = "$0.display()"
            let v157 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v155 v156
            let v158 : std_string_String option = None
            let v159 : bool = true in let mutable _v158 = v158
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v160 : string = @$"format!(""{{}}"", $0)"
            let v161 : std_string_String = Fable.Core.RustInterop.emitRustExpr v157 v160
            v161
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v162 : string = @$"format!(""{{}}"", $0)"
            let v163 : std_string_String = Fable.Core.RustInterop.emitRustExpr v157 v162
            v163
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v164 : string = @$"format!(""{{}}"", $0)"
            let v165 : std_string_String = Fable.Core.RustInterop.emitRustExpr v157 v164
            v165
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v166 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v166
#endif
            
#if FABLE_COMPILER_PYTHON
            let v167 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v167
#endif
            
#else
            let v168 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v168
#endif
            |&gt; fun x -&gt; _v158 &lt;- Some x
            let v169 : std_string_String = _v158.Value
            let v170 : string = "fable_library_rust::String_::fromString($0)"
            let v171 : string = Fable.Core.RustInterop.emitRustExpr v169 v170
            v171
    v172
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v173 : string = null |&gt; unbox&lt;string&gt;
    v173
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v174 : string = null |&gt; unbox&lt;string&gt;
    v174
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v175 : string = null |&gt; unbox&lt;string&gt;
    v175
#endif
    
#if FABLE_COMPILER_PYTHON
    let v176 : string = null |&gt; unbox&lt;string&gt;
    v176
#endif
    
#else
    let v177 : string = method28(v3)
    let v178 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v179 : string = v178 v177
    v179
#endif
    |&gt; fun x -&gt; _v10 &lt;- Some x
    let v180 : string = _v10.Value
    let v181 : string option = None
    let v182 : bool = true in let mutable _v181 = v181
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v183 : string = method21(v2)
    let v184 : string = method14(v183)
    let v185 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v186 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v184 v185
    let v187 : string = "String::from($0)"
    let v188 : std_string_String = Fable.Core.RustInterop.emitRustExpr v186 v187
    let v189 : string = "std::path::PathBuf::from($0)"
    let v190 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v188 v189
    let v191 : string = "$0.exists()"
    let v192 : bool = Fable.Core.RustInterop.emitRustExpr v190 v191
    let v193 : bool = v192 = false
    let v343 : string =
        if v193 then
            let v194 : string option = None
            let v195 : bool = true in let mutable _v194 = v194
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v196 : string = "std::env::current_dir()"
            let v197 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v196
            let v198 : string = "$0.unwrap()"
            let v199 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v197 v198
            let v200 : string = "$0.display()"
            let v201 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v199 v200
            let v202 : std_string_String option = None
            let v203 : bool = true in let mutable _v202 = v202
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v204 : string = @$"format!(""{{}}"", $0)"
            let v205 : std_string_String = Fable.Core.RustInterop.emitRustExpr v201 v204
            v205
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v206 : string = @$"format!(""{{}}"", $0)"
            let v207 : std_string_String = Fable.Core.RustInterop.emitRustExpr v201 v206
            v207
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v208 : string = @$"format!(""{{}}"", $0)"
            let v209 : std_string_String = Fable.Core.RustInterop.emitRustExpr v201 v208
            v209
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v210 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v210
#endif
            
#if FABLE_COMPILER_PYTHON
            let v211 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v211
#endif
            
#else
            let v212 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v212
#endif
            |&gt; fun x -&gt; _v202 &lt;- Some x
            let v213 : std_string_String = _v202.Value
            let v214 : string = "fable_library_rust::String_::fromString($0)"
            let v215 : string = Fable.Core.RustInterop.emitRustExpr v213 v214
            v215
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v216 : string = null |&gt; unbox&lt;string&gt;
            v216
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v217 : string = null |&gt; unbox&lt;string&gt;
            v217
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v218 : string = null |&gt; unbox&lt;string&gt;
            v218
#endif
            
#if FABLE_COMPILER_PYTHON
            let v219 : string = null |&gt; unbox&lt;string&gt;
            v219
#endif
            
#else
            let v220 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v221 : string = v220 ()
            v221
#endif
            |&gt; fun x -&gt; _v194 &lt;- Some x
            let v222 : string = _v194.Value
            let v223 : string = method13(v222, v183)
            let v224 : string option = None
            let v225 : bool = true in let mutable _v224 = v224
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v226 : string = method22()
            let v227 : string = method23(v223)
            let v228 : string = method24()
            let v229 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v230 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v226, v227, v228) v229
            let v231 : string = "String::from($0)"
            let v232 : std_string_String = Fable.Core.RustInterop.emitRustExpr v230 v231
            let v233 : string = "fable_library_rust::String_::fromString($0)"
            let v234 : string = Fable.Core.RustInterop.emitRustExpr v232 v233
            v234
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v235 : string = null |&gt; unbox&lt;string&gt;
            v235
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v236 : string = null |&gt; unbox&lt;string&gt;
            v236
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v237 : string = null |&gt; unbox&lt;string&gt;
            v237
#endif
            
#if FABLE_COMPILER_PYTHON
            let v238 : string = null |&gt; unbox&lt;string&gt;
            v238
#endif
            
#else
            let v239 : string = "^\\\\\\\\\\?\\\\"
            let v240 : string = ""
            let v241 : string = System.Text.RegularExpressions.Regex.Replace (v223, v239, v240)
            v241
#endif
            |&gt; fun x -&gt; _v224 &lt;- Some x
            let v242 : string = _v224.Value
            let v243 : string = $"{v242.[0] |&gt; string |&gt; _.ToLower()}{v242.[1..]}"
            let v244 : string = "\\"
            let v245 : string = "/"
            let v246 : string = v243.Replace (v244, v245)
            let v247 : (string []) = v246.Split v245
            let v248 : (string []) = [||]
            let v249 : int32 = v247.Length
            let v250 : Mut4 = {l0 = 0; l1 = 0; l2 = v248} : Mut4
            while method25(v249, v250) do
                let v252 : int32 = v250.l0
                let v253 : int32 =  -v252
                let v254 : int32 = v253 + v249
                let v255 : int32 = v254 - 1
                let struct (v256 : int32, v257 : (string [])) = v250.l1, v250.l2
                let v258 : string = v247.[int v255]
                let v259 : bool = ".." = v258
                let struct (v301 : int32, v302 : (string [])) =
                    if v259 then
                        let v260 : int32 = v256 + 1
                        struct (v260, v257)
                    else
                        let v261 : bool = "." = v258
                        if v261 then
                            struct (v256, v257)
                        else
                            let v262 : bool = 0 = v256
                            if v262 then
                                let v263 : string = ":"
                                let v264 : bool = v258.EndsWith v263
                                if v264 then
                                    let v265 : string = $"{v222.[0]}:"
                                    let v266 : (string []) = [|v265|]
                                    let v267 : int32 = v266.Length
                                    let v268 : int32 = v257.Length
                                    let v269 : int32 = v267 + v268
                                    let v270 : (string []) = Array.zeroCreate&lt;string&gt; (v269)
                                    let v271 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v269, v271) do
                                        let v273 : int32 = v271.l0
                                        let v274 : bool = v273 &lt; v267
                                        let v278 : string =
                                            if v274 then
                                                let v275 : string = v266.[int v273]
                                                v275
                                            else
                                                let v276 : int32 = v273 - v267
                                                let v277 : string = v257.[int v276]
                                                v277
                                        v270.[int v273] &lt;- v278
                                        let v279 : int32 = v273 + 1
                                        v271.l0 &lt;- v279
                                        ()
                                    struct (0, v270)
                                else
                                    let v280 : (string []) = [|v258|]
                                    let v281 : int32 = v280.Length
                                    let v282 : int32 = v257.Length
                                    let v283 : int32 = v281 + v282
                                    let v284 : (string []) = Array.zeroCreate&lt;string&gt; (v283)
                                    let v285 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v283, v285) do
                                        let v287 : int32 = v285.l0
                                        let v288 : bool = v287 &lt; v281
                                        let v292 : string =
                                            if v288 then
                                                let v289 : string = v280.[int v287]
                                                v289
                                            else
                                                let v290 : int32 = v287 - v281
                                                let v291 : string = v257.[int v290]
                                                v291
                                        v284.[int v287] &lt;- v292
                                        let v293 : int32 = v287 + 1
                                        v285.l0 &lt;- v293
                                        ()
                                    struct (0, v284)
                            else
                                let v296 : int32 = v256 - 1
                                struct (v296, v257)
                let v303 : int32 = v252 + 1
                v250.l0 &lt;- v303
                v250.l1 &lt;- v301
                v250.l2 &lt;- v302
                ()
            let struct (v304 : int32, v305 : (string [])) = v250.l1, v250.l2
            let v306 : string seq = seq { for i = 0 to v305.Length - 1 do yield v305.[i] }
            let v307 : char option = None
            let v308 : bool = true in let mutable _v307 = v307
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v309 : string = "std::path::MAIN_SEPARATOR"
            let v310 : char = Fable.Core.RustInterop.emitRustExpr () v309
            v310
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v311 : char = null |&gt; unbox&lt;char&gt;
            v311
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v312 : char = null |&gt; unbox&lt;char&gt;
            v312
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v313 : char = null |&gt; unbox&lt;char&gt;
            v313
#endif
            
#if FABLE_COMPILER_PYTHON
            let v314 : char = null |&gt; unbox&lt;char&gt;
            v314
#endif
            
#else
            let v315 : char = System.IO.Path.DirectorySeparatorChar
            v315
#endif
            |&gt; fun x -&gt; _v307 &lt;- Some x
            let v316 : char = _v307.Value
            let v317 : (char -&gt; string) = _.ToString()
            let v318 : string = v317 v316
            let v319 : string = method27(v318)
            let v320 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v321 : (string seq -&gt; string) = v320 v319
            v321 v306
        else
            let v323 : string = "std::fs::canonicalize(&amp;*$0)"
            let v324 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v183 v323
            let v325 : string = "$0.unwrap()"
            let v326 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v324 v325
            let v327 : string = "$0.display()"
            let v328 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v326 v327
            let v329 : std_string_String option = None
            let v330 : bool = true in let mutable _v329 = v329
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v331 : string = @$"format!(""{{}}"", $0)"
            let v332 : std_string_String = Fable.Core.RustInterop.emitRustExpr v328 v331
            v332
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v333 : string = @$"format!(""{{}}"", $0)"
            let v334 : std_string_String = Fable.Core.RustInterop.emitRustExpr v328 v333
            v334
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v335 : string = @$"format!(""{{}}"", $0)"
            let v336 : std_string_String = Fable.Core.RustInterop.emitRustExpr v328 v335
            v336
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v337 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v337
#endif
            
#if FABLE_COMPILER_PYTHON
            let v338 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v338
#endif
            
#else
            let v339 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v339
#endif
            |&gt; fun x -&gt; _v329 &lt;- Some x
            let v340 : std_string_String = _v329.Value
            let v341 : string = "fable_library_rust::String_::fromString($0)"
            let v342 : string = Fable.Core.RustInterop.emitRustExpr v340 v341
            v342
    v343
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v344 : string = null |&gt; unbox&lt;string&gt;
    v344
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v345 : string = null |&gt; unbox&lt;string&gt;
    v345
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v346 : string = null |&gt; unbox&lt;string&gt;
    v346
#endif
    
#if FABLE_COMPILER_PYTHON
    let v347 : string = null |&gt; unbox&lt;string&gt;
    v347
#endif
    
#else
    let v348 : string = method28(v2)
    let v349 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v350 : string = v349 v348
    v350
#endif
    |&gt; fun x -&gt; _v181 &lt;- Some x
    let v351 : string = _v181.Value
    let v352 : string option = None
    let v353 : bool = true in let mutable _v352 = v352
    
#if FABLE_COMPILER || WASM || CONTRACT
    
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
    let v354 : string = method21(v1)
    let v355 : string = method14(v354)
    let v356 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v357 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v355 v356
    let v358 : string = "String::from($0)"
    let v359 : std_string_String = Fable.Core.RustInterop.emitRustExpr v357 v358
    let v360 : string = "std::path::PathBuf::from($0)"
    let v361 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v359 v360
    let v362 : string = "$0.exists()"
    let v363 : bool = Fable.Core.RustInterop.emitRustExpr v361 v362
    let v364 : bool = v363 = false
    let v514 : string =
        if v364 then
            let v365 : string option = None
            let v366 : bool = true in let mutable _v365 = v365
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v367 : string = "std::env::current_dir()"
            let v368 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr () v367
            let v369 : string = "$0.unwrap()"
            let v370 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v368 v369
            let v371 : string = "$0.display()"
            let v372 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v370 v371
            let v373 : std_string_String option = None
            let v374 : bool = true in let mutable _v373 = v373
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v375 : string = @$"format!(""{{}}"", $0)"
            let v376 : std_string_String = Fable.Core.RustInterop.emitRustExpr v372 v375
            v376
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v377 : string = @$"format!(""{{}}"", $0)"
            let v378 : std_string_String = Fable.Core.RustInterop.emitRustExpr v372 v377
            v378
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v379 : string = @$"format!(""{{}}"", $0)"
            let v380 : std_string_String = Fable.Core.RustInterop.emitRustExpr v372 v379
            v380
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v381 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v381
#endif
            
#if FABLE_COMPILER_PYTHON
            let v382 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v382
#endif
            
#else
            let v383 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v383
#endif
            |&gt; fun x -&gt; _v373 &lt;- Some x
            let v384 : std_string_String = _v373.Value
            let v385 : string = "fable_library_rust::String_::fromString($0)"
            let v386 : string = Fable.Core.RustInterop.emitRustExpr v384 v385
            v386
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v387 : string = null |&gt; unbox&lt;string&gt;
            v387
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v388 : string = null |&gt; unbox&lt;string&gt;
            v388
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v389 : string = null |&gt; unbox&lt;string&gt;
            v389
#endif
            
#if FABLE_COMPILER_PYTHON
            let v390 : string = null |&gt; unbox&lt;string&gt;
            v390
#endif
            
#else
            let v391 : (unit -&gt; string) = System.IO.Directory.GetCurrentDirectory
            let v392 : string = v391 ()
            v392
#endif
            |&gt; fun x -&gt; _v365 &lt;- Some x
            let v393 : string = _v365.Value
            let v394 : string = method13(v393, v354)
            let v395 : string option = None
            let v396 : bool = true in let mutable _v395 = v395
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v397 : string = method22()
            let v398 : string = method23(v394)
            let v399 : string = method24()
            let v400 : string = $"regex::Regex::new(&amp;$0).unwrap().replace_all(&amp;$1, &amp;*$2)"
            let v401 : std_borrow_Cow&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr struct (v397, v398, v399) v400
            let v402 : string = "String::from($0)"
            let v403 : std_string_String = Fable.Core.RustInterop.emitRustExpr v401 v402
            let v404 : string = "fable_library_rust::String_::fromString($0)"
            let v405 : string = Fable.Core.RustInterop.emitRustExpr v403 v404
            v405
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v406 : string = null |&gt; unbox&lt;string&gt;
            v406
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v407 : string = null |&gt; unbox&lt;string&gt;
            v407
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v408 : string = null |&gt; unbox&lt;string&gt;
            v408
#endif
            
#if FABLE_COMPILER_PYTHON
            let v409 : string = null |&gt; unbox&lt;string&gt;
            v409
#endif
            
#else
            let v410 : string = "^\\\\\\\\\\?\\\\"
            let v411 : string = ""
            let v412 : string = System.Text.RegularExpressions.Regex.Replace (v394, v410, v411)
            v412
#endif
            |&gt; fun x -&gt; _v395 &lt;- Some x
            let v413 : string = _v395.Value
            let v414 : string = $"{v413.[0] |&gt; string |&gt; _.ToLower()}{v413.[1..]}"
            let v415 : string = "\\"
            let v416 : string = "/"
            let v417 : string = v414.Replace (v415, v416)
            let v418 : (string []) = v417.Split v416
            let v419 : (string []) = [||]
            let v420 : int32 = v418.Length
            let v421 : Mut4 = {l0 = 0; l1 = 0; l2 = v419} : Mut4
            while method25(v420, v421) do
                let v423 : int32 = v421.l0
                let v424 : int32 =  -v423
                let v425 : int32 = v424 + v420
                let v426 : int32 = v425 - 1
                let struct (v427 : int32, v428 : (string [])) = v421.l1, v421.l2
                let v429 : string = v418.[int v426]
                let v430 : bool = ".." = v429
                let struct (v472 : int32, v473 : (string [])) =
                    if v430 then
                        let v431 : int32 = v427 + 1
                        struct (v431, v428)
                    else
                        let v432 : bool = "." = v429
                        if v432 then
                            struct (v427, v428)
                        else
                            let v433 : bool = 0 = v427
                            if v433 then
                                let v434 : string = ":"
                                let v435 : bool = v429.EndsWith v434
                                if v435 then
                                    let v436 : string = $"{v393.[0]}:"
                                    let v437 : (string []) = [|v436|]
                                    let v438 : int32 = v437.Length
                                    let v439 : int32 = v428.Length
                                    let v440 : int32 = v438 + v439
                                    let v441 : (string []) = Array.zeroCreate&lt;string&gt; (v440)
                                    let v442 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v440, v442) do
                                        let v444 : int32 = v442.l0
                                        let v445 : bool = v444 &lt; v438
                                        let v449 : string =
                                            if v445 then
                                                let v446 : string = v437.[int v444]
                                                v446
                                            else
                                                let v447 : int32 = v444 - v438
                                                let v448 : string = v428.[int v447]
                                                v448
                                        v441.[int v444] &lt;- v449
                                        let v450 : int32 = v444 + 1
                                        v442.l0 &lt;- v450
                                        ()
                                    struct (0, v441)
                                else
                                    let v451 : (string []) = [|v429|]
                                    let v452 : int32 = v451.Length
                                    let v453 : int32 = v428.Length
                                    let v454 : int32 = v452 + v453
                                    let v455 : (string []) = Array.zeroCreate&lt;string&gt; (v454)
                                    let v456 : Mut5 = {l0 = 0} : Mut5
                                    while method26(v454, v456) do
                                        let v458 : int32 = v456.l0
                                        let v459 : bool = v458 &lt; v452
                                        let v463 : string =
                                            if v459 then
                                                let v460 : string = v451.[int v458]
                                                v460
                                            else
                                                let v461 : int32 = v458 - v452
                                                let v462 : string = v428.[int v461]
                                                v462
                                        v455.[int v458] &lt;- v463
                                        let v464 : int32 = v458 + 1
                                        v456.l0 &lt;- v464
                                        ()
                                    struct (0, v455)
                            else
                                let v467 : int32 = v427 - 1
                                struct (v467, v428)
                let v474 : int32 = v423 + 1
                v421.l0 &lt;- v474
                v421.l1 &lt;- v472
                v421.l2 &lt;- v473
                ()
            let struct (v475 : int32, v476 : (string [])) = v421.l1, v421.l2
            let v477 : string seq = seq { for i = 0 to v476.Length - 1 do yield v476.[i] }
            let v478 : char option = None
            let v479 : bool = true in let mutable _v478 = v478
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v480 : string = "std::path::MAIN_SEPARATOR"
            let v481 : char = Fable.Core.RustInterop.emitRustExpr () v480
            v481
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v482 : char = null |&gt; unbox&lt;char&gt;
            v482
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v483 : char = null |&gt; unbox&lt;char&gt;
            v483
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v484 : char = null |&gt; unbox&lt;char&gt;
            v484
#endif
            
#if FABLE_COMPILER_PYTHON
            let v485 : char = null |&gt; unbox&lt;char&gt;
            v485
#endif
            
#else
            let v486 : char = System.IO.Path.DirectorySeparatorChar
            v486
#endif
            |&gt; fun x -&gt; _v478 &lt;- Some x
            let v487 : char = _v478.Value
            let v488 : (char -&gt; string) = _.ToString()
            let v489 : string = v488 v487
            let v490 : string = method27(v489)
            let v491 : (string -&gt; (string seq -&gt; string)) = String.concat
            let v492 : (string seq -&gt; string) = v491 v490
            v492 v477
        else
            let v494 : string = "std::fs::canonicalize(&amp;*$0)"
            let v495 : Result&lt;std_path_PathBuf, std_io_Error&gt; = Fable.Core.RustInterop.emitRustExpr v354 v494
            let v496 : string = "$0.unwrap()"
            let v497 : std_path_PathBuf = Fable.Core.RustInterop.emitRustExpr v495 v496
            let v498 : string = "$0.display()"
            let v499 : std_path_Display = Fable.Core.RustInterop.emitRustExpr v497 v498
            let v500 : std_string_String option = None
            let v501 : bool = true in let mutable _v500 = v500
            
#if FABLE_COMPILER || WASM || CONTRACT
            
#if FABLE_COMPILER_RUST &amp;&amp; !WASM &amp;&amp; !CONTRACT
            let v502 : string = @$"format!(""{{}}"", $0)"
            let v503 : std_string_String = Fable.Core.RustInterop.emitRustExpr v499 v502
            v503
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; WASM
            let v504 : string = @$"format!(""{{}}"", $0)"
            let v505 : std_string_String = Fable.Core.RustInterop.emitRustExpr v499 v504
            v505
#endif
            
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
            let v506 : string = @$"format!(""{{}}"", $0)"
            let v507 : std_string_String = Fable.Core.RustInterop.emitRustExpr v499 v506
            v507
#endif
            
#if FABLE_COMPILER_TYPESCRIPT
            let v508 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v508
#endif
            
#if FABLE_COMPILER_PYTHON
            let v509 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v509
#endif
            
#else
            let v510 : std_string_String = null |&gt; unbox&lt;std_string_String&gt;
            v510
#endif
            |&gt; fun x -&gt; _v500 &lt;- Some x
            let v511 : std_string_String = _v500.Value
            let v512 : string = "fable_library_rust::String_::fromString($0)"
            let v513 : string = Fable.Core.RustInterop.emitRustExpr v511 v512
            v513
    v514
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; WASM
    let v515 : string = null |&gt; unbox&lt;string&gt;
    v515
#endif
    
#if FABLE_COMPILER_RUST &amp;&amp; CONTRACT
    let v516 : string = null |&gt; unbox&lt;string&gt;
    v516
#endif
    
#if FABLE_COMPILER_TYPESCRIPT
    let v517 : string = null |&gt; unbox&lt;string&gt;
    v517
#endif
    
#if FABLE_COMPILER_PYTHON
    let v518 : string = null |&gt; unbox&lt;string&gt;
    v518
#endif
    
#else
    let v519 : string = method28(v1)
    let v520 : (string -&gt; string) = System.IO.Path.GetFullPath
    let v521 : string = v520 v519
    v521
#endif
    |&gt; fun x -&gt; _v352 &lt;- Some x
    let v522 : string = _v352.Value
    let v523 : US0 = US0_1
    let v524 : (unit -&gt; string) = closure12()
    let v525 : (unit -&gt; string) = closure13(v0, v180, v351, v522)
    method3(v523, v524, v525)
    method29(v0, v9, v180, v351, v522)
and closure1 () (v0 : (string [])) : int32 =
    let v1 : (unit -&gt; struct (Mut0 * Mut1 * Mut2 * int64 option * Mut3)) = closure2()
    if State.trace_state.IsNone then State.trace_state &lt;- v1 () |&gt; Some
    let struct (v2 : Mut0, v3 : Mut1, v4 : Mut2, v5 : int64 option, v6 : Mut3) = State.trace_state.Value
    let v7 : US0 = US0_2
    v4.l0 &lt;- v7
    let v8 : US0 = US0_2
    let v9 : (unit -&gt; string) = closure4()
    let v10 : (unit -&gt; string) = closure5(v0)
    method3(v8, v9, v10)
    let v11 : clap_Command = method0()
    let v12 : string = "clap::Command::get_matches($0)"
    let v13 : clap_ArgMatches = Fable.Core.RustInterop.emitRustExpr v11 v12
    let v14 : string = method7()
    let v15 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v16 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v14 v15
    let v17 : string = "clap::ArgMatches::get_one(&amp;v13, v16).cloned()"
    let v18 : std_string_String option = Fable.Core.RustInterop.emitRustExpr () v17
    let v19 : (std_string_String -&gt; US3) = method8()
    let v20 : US3 = US3_1
    let v21 : US3 = v18 |&gt; Option.map v19 |&gt; Option.defaultValue v20 
    let v25 : std_string_String =
        match v21 with
        | US3_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US3_0(v22) -&gt; (* Some *)
            v22
    let v26 : string = "fable_library_rust::String_::fromString($0)"
    let v27 : string = Fable.Core.RustInterop.emitRustExpr v25 v26
    let v28 : string = method9()
    let v29 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v30 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v28 v29
    let v31 : string = "clap::ArgMatches::get_one(&amp;v13, v30).cloned()"
    let v32 : std_string_String option = Fable.Core.RustInterop.emitRustExpr () v31
    let v33 : (std_string_String -&gt; US3) = method8()
    let v34 : US3 = US3_1
    let v35 : US3 = v32 |&gt; Option.map v33 |&gt; Option.defaultValue v34 
    let v39 : std_string_String =
        match v35 with
        | US3_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US3_0(v36) -&gt; (* Some *)
            v36
    let v40 : string = "fable_library_rust::String_::fromString($0)"
    let v41 : string = Fable.Core.RustInterop.emitRustExpr v39 v40
    let v42 : string = method10()
    let v43 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v44 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v42 v43
    let v45 : string = "clap::ArgMatches::get_one(&amp;v13, v44).cloned()"
    let v46 : std_string_String option = Fable.Core.RustInterop.emitRustExpr () v45
    let v47 : (std_string_String -&gt; US3) = method8()
    let v48 : US3 = US3_1
    let v49 : US3 = v46 |&gt; Option.map v47 |&gt; Option.defaultValue v48 
    let v53 : std_string_String =
        match v49 with
        | US3_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US3_0(v50) -&gt; (* Some *)
            v50
    let v54 : string = "fable_library_rust::String_::fromString($0)"
    let v55 : string = Fable.Core.RustInterop.emitRustExpr v53 v54
    let v56 : string = method11()
    let v57 : string = "fable_library_rust::String_::LrcStr::as_str(&amp;$0)"
    let v58 : Ref&lt;Str&gt; = Fable.Core.RustInterop.emitRustExpr v56 v57
    let v59 : string = "clap::ArgMatches::get_one(&amp;v13, v58).cloned()"
    let v60 : std_string_String option = Fable.Core.RustInterop.emitRustExpr () v59
    let v61 : (std_string_String -&gt; US3) = method8()
    let v62 : US3 = US3_1
    let v63 : US3 = v60 |&gt; Option.map v61 |&gt; Option.defaultValue v62 
    let v67 : std_string_String =
        match v63 with
        | US3_1 -&gt; (* None *)
            failwith&lt;std_string_String&gt; "Option does not have a value."
        | US3_0(v64) -&gt; (* Some *)
            v64
    let v68 : string = "fable_library_rust::String_::fromString($0)"
    let v69 : string = Fable.Core.RustInterop.emitRustExpr v67 v68
    let v70 : std_pin_Pin&lt;Box&lt;Dyn&lt;std_future_Future&lt;Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt;&gt;&gt;&gt;&gt; = method12(v69, v55, v41, v27)
    let v71 : string = "futures_lite::future::block_on($0)"
    let v72 : Result&lt;Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt;, std_string_String&gt; = Fable.Core.RustInterop.emitRustExpr v70 v71
    let v73 : string = "$0.unwrap()"
    let v74 : Vec&lt;Result&lt;(string * Vec&lt;Result&lt;string, (string * string)&gt; option&gt;), std_string_String&gt;&gt; = Fable.Core.RustInterop.emitRustExpr v72 v73
    0
let v0 : (unit -&gt; unit) = closure0()
let tests () = v0 ()
let v1 : ((string []) -&gt; int32) = closure1()
let main args = v1 args
()


</pre>
</div>
</div>
</div>
</div>
</div>
</main>
</body>
</html>

